/* automatically generated by rust-bindgen 0.69.1 */

#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ihipStream_t {
    _unused: [u8; 0],
}
pub type hipStream_t = *mut ihipStream_t;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum hipDataType {
    HIP_R_32F = 0,
    HIP_R_64F = 1,
    HIP_R_16F = 2,
    HIP_R_8I = 3,
    HIP_C_32F = 4,
    HIP_C_64F = 5,
    HIP_C_16F = 6,
    HIP_C_8I = 7,
    HIP_R_8U = 8,
    HIP_C_8U = 9,
    HIP_R_32I = 10,
    HIP_C_32I = 11,
    HIP_R_32U = 12,
    HIP_C_32U = 13,
    HIP_R_16BF = 14,
    HIP_C_16BF = 15,
    HIP_R_4I = 16,
    HIP_C_4I = 17,
    HIP_R_4U = 18,
    HIP_C_4U = 19,
    HIP_R_16I = 20,
    HIP_C_16I = 21,
    HIP_R_16U = 22,
    HIP_C_16U = 23,
    HIP_R_64I = 24,
    HIP_C_64I = 25,
    HIP_R_64U = 26,
    HIP_C_64U = 27,
    HIP_R_8F_E4M3_FNUZ = 1000,
    HIP_R_8F_E5M2_FNUZ = 1001,
}
#[repr(u32)]
#[doc = " \\brief hipblas status codes definition"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum hipblasStatus_t {
    #[doc = "< Function succeeds"]
    HIPBLAS_STATUS_SUCCESS = 0,
    #[doc = "< HIPBLAS library not initialized"]
    HIPBLAS_STATUS_NOT_INITIALIZED = 1,
    #[doc = "< resource allocation failed"]
    HIPBLAS_STATUS_ALLOC_FAILED = 2,
    #[doc = "< unsupported numerical value was passed to function"]
    HIPBLAS_STATUS_INVALID_VALUE = 3,
    #[doc = "< access to GPU memory space failed"]
    HIPBLAS_STATUS_MAPPING_ERROR = 4,
    #[doc = "< GPU program failed to execute"]
    HIPBLAS_STATUS_EXECUTION_FAILED = 5,
    #[doc = "< an internal HIPBLAS operation failed"]
    HIPBLAS_STATUS_INTERNAL_ERROR = 6,
    #[doc = "< function not implemented"]
    HIPBLAS_STATUS_NOT_SUPPORTED = 7,
    #[doc = "< architecture mismatch"]
    HIPBLAS_STATUS_ARCH_MISMATCH = 8,
    #[doc = "< hipBLAS handle is null pointer"]
    HIPBLAS_STATUS_HANDLE_IS_NULLPTR = 9,
    #[doc = "<  unsupported enum value was passed to function"]
    HIPBLAS_STATUS_INVALID_ENUM = 10,
    #[doc = "<  back-end returned an unsupported status code"]
    HIPBLAS_STATUS_UNKNOWN = 11,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum hipblasComputeType_t {
    #[doc = "< compute will be at least 16-bit precision"]
    HIPBLAS_COMPUTE_16F = 0,
    #[doc = "< compute will be exactly 16-bit precision"]
    HIPBLAS_COMPUTE_16F_PEDANTIC = 1,
    #[doc = "< compute will be at least 32-bit precision"]
    HIPBLAS_COMPUTE_32F = 2,
    #[doc = "< compute will be exactly 32-bit precision"]
    HIPBLAS_COMPUTE_32F_PEDANTIC = 3,
    #[doc = "< 32-bit input can use 16-bit compute"]
    HIPBLAS_COMPUTE_32F_FAST_16F = 4,
    #[doc = "< 32-bit input can is bf16 compute"]
    HIPBLAS_COMPUTE_32F_FAST_16BF = 5,
    HIPBLAS_COMPUTE_32F_FAST_TF32 = 6,
    #[doc = "< compute will be at least 64-bit precision"]
    HIPBLAS_COMPUTE_64F = 7,
    #[doc = "< compute will be exactly 64-bit precision"]
    HIPBLAS_COMPUTE_64F_PEDANTIC = 8,
    #[doc = "< compute will be at least 32-bit integer precision"]
    HIPBLAS_COMPUTE_32I = 9,
    #[doc = "< compute will be exactly 32-bit integer precision"]
    HIPBLAS_COMPUTE_32I_PEDANTIC = 10,
}
#[doc = " \\brief Struct to represent a 16 bit brain floating point number."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct hip_bfloat16 {
    pub data: u16,
}
#[test]
fn bindgen_test_layout_hip_bfloat16() {
    const UNINIT: ::core::mem::MaybeUninit<hip_bfloat16> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<hip_bfloat16>(),
        2usize,
        concat!("Size of: ", stringify!(hip_bfloat16))
    );
    assert_eq!(
        ::core::mem::align_of::<hip_bfloat16>(),
        2usize,
        concat!("Alignment of ", stringify!(hip_bfloat16))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hip_bfloat16),
            "::",
            stringify!(data)
        )
    );
}
#[doc = " \\brief Single precision floating point type"]
pub type hipblasLtFloat = f32;
#[doc = " \\brief Structure definition for hipblasLtHalf"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _hipblasLtHalf {
    pub data: u16,
}
#[test]
fn bindgen_test_layout__hipblasLtHalf() {
    const UNINIT: ::core::mem::MaybeUninit<_hipblasLtHalf> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_hipblasLtHalf>(),
        2usize,
        concat!("Size of: ", stringify!(_hipblasLtHalf))
    );
    assert_eq!(
        ::core::mem::align_of::<_hipblasLtHalf>(),
        2usize,
        concat!("Alignment of ", stringify!(_hipblasLtHalf))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_hipblasLtHalf),
            "::",
            stringify!(data)
        )
    );
}
#[doc = " \\brief Structure definition for hipblasLtHalf"]
pub type hipblasLtHalf = _hipblasLtHalf;
#[doc = " \\brief Struct to represent a 16 bit brain floating point number."]
pub type hipblasLtBfloat16 = hip_bfloat16;
pub type hipblasLtInt8 = i8;
pub type hipblasLtInt32 = i32;
#[repr(u32)]
#[doc = " \\ingroup types_module\n  \\brief Specify the enum type to set the postprocessing options for the epilogue."]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum hipblasLtEpilogue_t {
    #[doc = "<No special postprocessing, just scale and quantize the results if necessary."]
    HIPBLASLT_EPILOGUE_DEFAULT = 1,
    #[doc = "<Apply ReLU point-wise transform to the results:(x:=max(x, 0))"]
    HIPBLASLT_EPILOGUE_RELU = 2,
    #[doc = "<Apply (broadcast) bias from the bias vector. Bias vector length must match matrix D rows, and it must be packed (such as stride between vector elements is 1). Bias vector is broadcast to all columns and added before applying the final postprocessing."]
    HIPBLASLT_EPILOGUE_BIAS = 4,
    #[doc = "<Apply bias and then ReLU transform."]
    HIPBLASLT_EPILOGUE_RELU_BIAS = 6,
    #[doc = "<Apply GELU point-wise transform to the results (x:=GELU(x))."]
    HIPBLASLT_EPILOGUE_GELU = 32,
    #[doc = "<Apply Bias and then GELU transform."]
    HIPBLASLT_EPILOGUE_GELU_BIAS = 36,
    #[doc = "<Output GEMM results before applying GELU transform."]
    HIPBLASLT_EPILOGUE_GELU_AUX = 160,
    #[doc = "<Output GEMM results after applying bias but before applying GELU transform."]
    HIPBLASLT_EPILOGUE_GELU_AUX_BIAS = 164,
    #[doc = "<Apply gradient GELU transform. Requires additional aux input."]
    HIPBLASLT_EPILOGUE_DGELU = 192,
    #[doc = "<Apply gradient GELU transform and bias gradient to the results. Requires additional aux input."]
    HIPBLASLT_EPILOGUE_DGELU_BGRAD = 208,
    #[doc = "<Apply bias gradient to A and output gemm result."]
    HIPBLASLT_EPILOGUE_BGRADA = 256,
    #[doc = "<Apply bias gradient to B and output gemm result."]
    HIPBLASLT_EPILOGUE_BGRADB = 512,
}
#[repr(u32)]
#[doc = " \\ingroup types_module\n  \\brief Specify the attributes that define the details of the matrix."]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum hipblasLtMatrixLayoutAttribute_t {
    #[doc = "<Number of batch of this matrix. Default value is 1. Data Type: int32_t"]
    HIPBLASLT_MATRIX_LAYOUT_BATCH_COUNT = 0,
    #[doc = "<Stride (in elements) to the next matrix for the strided batch operation. Default value is 0. Data Type: int64_t"]
    HIPBLASLT_MATRIX_LAYOUT_STRIDED_BATCH_OFFSET = 1,
    #[doc = " Data type, see hipDataType.\n\n uint32_t"]
    HIPBLASLT_MATRIX_LAYOUT_TYPE = 2,
    #[doc = " Memory order of the data, see cublasLtOrder_t.\n\n int32_t, default: HIPBLASLT_ORDER_COL"]
    HIPBLASLT_MATRIX_LAYOUT_ORDER = 3,
    #[doc = " Number of rows.\n\n Usually only values that can be expressed as int32_t are supported.\n\n uint64_t"]
    HIPBLASLT_MATRIX_LAYOUT_ROWS = 4,
    #[doc = " Number of columns.\n\n Usually only values that can be expressed as int32_t are supported.\n\n uint64_t"]
    HIPBLASLT_MATRIX_LAYOUT_COLS = 5,
    #[doc = " Matrix leading dimension.\n\n For HIPBLASLT_ORDER_COL this is stride (in elements) of matrix column, for more details and documentation for\n other memory orders see documentation for cublasLtOrder_t values.\n\n Currently only non-negative values are supported, must be large enough so that matrix memory locations are not\n overlapping (e.g. greater or equal to HIPBLASLT_MATRIX_LAYOUT_ROWS in case of HIPBLASLT_ORDER_COL).\n\n int64_t;"]
    HIPBLASLT_MATRIX_LAYOUT_LD = 6,
}
#[repr(u32)]
#[doc = " \\ingroup types_module\n  \\brief Pointer mode to use for alpha."]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum hipblasLtPointerMode_t {
    HIPBLASLT_POINTER_MODE_HOST = 0,
    #[doc = " targets host memory"]
    HIPBLASLT_POINTER_MODE_ALPHA_DEVICE_VECTOR_BETA_HOST = 1,
}
#[repr(u32)]
#[doc = " \\ingroup types_module\n  \\brief Specify the attributes that define the specifics of the matrix multiply operation."]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum hipblasLtMatmulDescAttributes_t {
    #[doc = "<Specifies the type of transformation operation that should be performed on matrix A. Default value is HIPBLAS_OP_N (for example, non-transpose operation). See hipblasOperation_t. Data Type:int32_t"]
    HIPBLASLT_MATMUL_DESC_TRANSA = 0,
    #[doc = "<Specifies the type of transformation operation that should be performed on matrix B. Default value is HIPBLAS_OP_N (for example, non-transpose operation). See hipblasOperation_t. Data Type:int32_t"]
    HIPBLASLT_MATMUL_DESC_TRANSB = 1,
    #[doc = "<Epilogue function. See hipblasLtEpilogue_t. Default value is: HIPBLASLT_EPILOGUE_DEFAULT. Data Type: uint32_t"]
    HIPBLASLT_MATMUL_DESC_EPILOGUE = 2,
    #[doc = "<Bias or Bias gradient vector pointer in the device memory. Data Type:void* /const void*"]
    HIPBLASLT_MATMUL_DESC_BIAS_POINTER = 3,
    #[doc = "<Type of the bias vector in the device memory. Can be set same as D matrix type or Scale type. Bias case: see HIPBLASLT_EPILOGUE_BIAS. Data Type:int32_t based on hipDataType"]
    HIPBLASLT_MATMUL_DESC_BIAS_DATA_TYPE = 4,
    #[doc = "<Device pointer to the scale factor value that converts data in matrix A to the compute data type range. The scaling factor must have the same type as the compute type. If not specified, or set to NULL, the scaling factor is assumed to be 1. If set for an unsupported matrix data, scale, and compute type combination, calling hipblasLtMatmul() will return HIPBLAS_INVALID_VALUE. Default value: NULL Data Type: void* /const void*"]
    HIPBLASLT_MATMUL_DESC_A_SCALE_POINTER = 5,
    #[doc = "<Equivalent to HIPBLASLT_MATMUL_DESC_A_SCALE_POINTER for matrix B. Default value: NULL Type: void* /const void*"]
    HIPBLASLT_MATMUL_DESC_B_SCALE_POINTER = 6,
    #[doc = "<Equivalent to HIPBLASLT_MATMUL_DESC_A_SCALE_POINTER for matrix C. Default value: NULL Type: void* /const void*"]
    HIPBLASLT_MATMUL_DESC_C_SCALE_POINTER = 7,
    #[doc = "<Equivalent to HIPBLASLT_MATMUL_DESC_A_SCALE_POINTER for matrix D. Default value: NULL Type: void* /const void*"]
    HIPBLASLT_MATMUL_DESC_D_SCALE_POINTER = 8,
    #[doc = "<Equivalent to HIPBLASLT_MATMUL_DESC_A_SCALE_POINTER for matrix AUX. Default value: NULL Type: void* /const void*"]
    HIPBLASLT_MATMUL_DESC_EPILOGUE_AUX_SCALE_POINTER = 9,
    #[doc = "<Epilogue auxiliary buffer pointer in the device memory. Data Type:void* /const void*"]
    HIPBLASLT_MATMUL_DESC_EPILOGUE_AUX_POINTER = 10,
    #[doc = "<The leading dimension of the epilogue auxiliary buffer pointer in the device memory. Data Type:int64_t"]
    HIPBLASLT_MATMUL_DESC_EPILOGUE_AUX_LD = 11,
    #[doc = "<The batch stride of the epilogue auxiliary buffer pointer in the device memory. Data Type:int64_t"]
    HIPBLASLT_MATMUL_DESC_EPILOGUE_AUX_BATCH_STRIDE = 12,
    #[doc = "<Specifies alpha and beta are passed by reference, whether they are scalars on the host or on the device, or device vectors. Default value is: HIPBLASLT_POINTER_MODE_HOST (i.e., on the host). Data Type: int32_t based on hipblasLtPointerMode_t"]
    HIPBLASLT_MATMUL_DESC_POINTER_MODE = 13,
    HIPBLASLT_MATMUL_DESC_MAX = 101,
}
#[repr(u32)]
#[doc = " \\ingroup types_module\n  \\brief It is an enumerated type used to apply algorithm search preferences while fine-tuning the heuristic function."]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum hipblasLtMatmulPreferenceAttributes_t {
    #[doc = "<Search mode. Data Type: uint32_t"]
    HIPBLASLT_MATMUL_PREF_SEARCH_MODE = 0,
    #[doc = "<Maximum allowed workspace memory. Default is 0 (no workspace memory allowed). Data Type: uint64_t"]
    HIPBLASLT_MATMUL_PREF_MAX_WORKSPACE_BYTES = 1,
    HIPBLASLT_MATMUL_PREF_MAX = 2,
}
#[repr(u32)]
#[doc = " Enum for data ordering"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum hipblasLtOrder_t {
    #[doc = " Column-major\n\n Leading dimension is the stride (in elements) to the beginning of next column in memory."]
    HIPBLASLT_ORDER_COL = 0,
    #[doc = " Row major\n\n Leading dimension is the stride (in elements) to the beginning of next row in memory."]
    HIPBLASLT_ORDER_ROW = 1,
}
#[repr(u32)]
#[doc = " Matrix transform descriptor attributes to define details of the operation."]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum hipblasLtMatrixTransformDescAttributes_t {
    #[doc = " Scale type, see hipDataType. Inputs are converted to scale type for scaling and summation and results are then\n converted to output type to store in memory.\n\n int32_t"]
    HIPBLASLT_MATRIX_TRANSFORM_DESC_SCALE_TYPE = 0,
    #[doc = " Pointer mode of alpha and beta, see cublasLtPointerMode_t.\n\n int32_t, default: HIPBLASLT_POINTER_MODE_HOST"]
    HIPBLASLT_MATRIX_TRANSFORM_DESC_POINTER_MODE = 1,
    #[doc = " Transform of matrix A, see cublasOperation_t.\n\n int32_t, default: HIPBLAS_OP_N"]
    HIPBLASLT_MATRIX_TRANSFORM_DESC_TRANSA = 2,
    #[doc = " Transform of matrix B, see cublasOperation_t.\n\n int32_t, default: HIPBLAS_OP_N"]
    HIPBLASLT_MATRIX_TRANSFORM_DESC_TRANSB = 3,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct hipblasLtMatmulDescOpaque_t {
    pub data: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_hipblasLtMatmulDescOpaque_t() {
    const UNINIT: ::core::mem::MaybeUninit<hipblasLtMatmulDescOpaque_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<hipblasLtMatmulDescOpaque_t>(),
        32usize,
        concat!("Size of: ", stringify!(hipblasLtMatmulDescOpaque_t))
    );
    assert_eq!(
        ::core::mem::align_of::<hipblasLtMatmulDescOpaque_t>(),
        8usize,
        concat!("Alignment of ", stringify!(hipblasLtMatmulDescOpaque_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipblasLtMatmulDescOpaque_t),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct hipblasLtMatrixLayoutOpaque_t {
    pub data: [u64; 4usize],
}
#[test]
fn bindgen_test_layout_hipblasLtMatrixLayoutOpaque_t() {
    const UNINIT: ::core::mem::MaybeUninit<hipblasLtMatrixLayoutOpaque_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<hipblasLtMatrixLayoutOpaque_t>(),
        32usize,
        concat!("Size of: ", stringify!(hipblasLtMatrixLayoutOpaque_t))
    );
    assert_eq!(
        ::core::mem::align_of::<hipblasLtMatrixLayoutOpaque_t>(),
        8usize,
        concat!("Alignment of ", stringify!(hipblasLtMatrixLayoutOpaque_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipblasLtMatrixLayoutOpaque_t),
            "::",
            stringify!(data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct hipblasLtMatmulPreferenceOpaque_t {
    pub data: [u64; 5usize],
}
#[test]
fn bindgen_test_layout_hipblasLtMatmulPreferenceOpaque_t() {
    const UNINIT: ::core::mem::MaybeUninit<hipblasLtMatmulPreferenceOpaque_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<hipblasLtMatmulPreferenceOpaque_t>(),
        40usize,
        concat!("Size of: ", stringify!(hipblasLtMatmulPreferenceOpaque_t))
    );
    assert_eq!(
        ::core::mem::align_of::<hipblasLtMatmulPreferenceOpaque_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(hipblasLtMatmulPreferenceOpaque_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipblasLtMatmulPreferenceOpaque_t),
            "::",
            stringify!(data)
        )
    );
}
#[doc = " Semi-opaque descriptor for hipblasLtMatrixTransform() operation details"]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct hipblasLtMatrixTransformDescOpaque_t {
    pub data: [u64; 8usize],
}
#[test]
fn bindgen_test_layout_hipblasLtMatrixTransformDescOpaque_t() {
    const UNINIT: ::core::mem::MaybeUninit<hipblasLtMatrixTransformDescOpaque_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<hipblasLtMatrixTransformDescOpaque_t>(),
        64usize,
        concat!(
            "Size of: ",
            stringify!(hipblasLtMatrixTransformDescOpaque_t)
        )
    );
    assert_eq!(
        ::core::mem::align_of::<hipblasLtMatrixTransformDescOpaque_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(hipblasLtMatrixTransformDescOpaque_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipblasLtMatrixTransformDescOpaque_t),
            "::",
            stringify!(data)
        )
    );
}
#[doc = " Opaque descriptor for hipblasLtMatrixTransform() operation details"]
pub type hipblasLtMatrixTransformDesc_t = *mut hipblasLtMatrixTransformDescOpaque_t;
#[doc = " \\ingroup types_module\n  \\brief Handle to the hipBLASLt library context queue\n\n  \\details\n  The hipblasLtHandle_t type is a pointer type to an opaque structure holding the hipBLASLt library context. Use the following functions to manipulate this library context:\n\n  \\ref hipblasLtCreate():\n  To initialize the hipBLASLt library context and return a handle to an opaque structure holding the hipBLASLt library context.\n  \\ref hipblasLtDestroy():\n  To destroy a previously created hipBLASLt library context descriptor and release the resources."]
pub type hipblasLtHandle_t = *mut ::core::ffi::c_void;
#[doc = " \\ingroup types_module\n  \\brief Descriptor of the matrix multiplication operation\n\n  \\details\n  This is a pointer to an opaque structure holding the description of the matrix multiplication operation \\ref hipblasLtMatmul().\n  Use the following functions to manipulate this descriptor:\n  \\ref hipblasLtMatmulDescCreate(): To create one instance of the descriptor.\n  \\ref hipblasLtMatmulDescDestroy(): To destroy a previously created descriptor and release the resources."]
pub type hipblasLtMatmulDesc_t = *mut hipblasLtMatmulDescOpaque_t;
#[doc = " \\ingroup types_module\n  \\brief Descriptor of the matrix layout\n\n  \\details\n  This is a pointer to an opaque structure holding the description of a matrix layout.\n  Use the following functions to manipulate this descriptor:\n  \\ref hipblasLtMatrixLayoutCreate(): To create one instance of the descriptor.\n  \\ref hipblasLtMatrixLayoutDestroy(): To destroy a previously created descriptor and release the resources."]
pub type hipblasLtMatrixLayout_t = *mut hipblasLtMatrixLayoutOpaque_t;
#[doc = " \\ingroup types_module\n  \\brief Descriptor of the matrix multiplication preference\n\n  \\details\n  This is a pointer to an opaque structure holding the description of the preferences for \\ref hipblasLtMatmulAlgoGetHeuristic() configuration.\n  Use the following functions to manipulate this descriptor:\n  \\ref hipblasLtMatmulPreferenceCreate(): To create one instance of the descriptor.\n  \\ref hipblasLtMatmulPreferenceDestroy(): To destroy a previously created descriptor and release the resources."]
pub type hipblasLtMatmulPreference_t = *mut hipblasLtMatmulPreferenceOpaque_t;
#[doc = " \\ingroup types_module\n  \\struct hipblasLtMatmulAlgo_t\n  \\brief Description of the matrix multiplication algorithm\n\n  \\details\n  This is an opaque structure holding the description of the matrix multiplication algorithm.\n  This structure can be trivially serialized and later restored for use with the same version of hipBLASLt library to save on selecting the right configuration again."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct _hipblasLtMatmulAlgo_t {
    pub data: [u8; 16usize],
    pub max_workspace_bytes: usize,
}
#[test]
fn bindgen_test_layout__hipblasLtMatmulAlgo_t() {
    const UNINIT: ::core::mem::MaybeUninit<_hipblasLtMatmulAlgo_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_hipblasLtMatmulAlgo_t>(),
        24usize,
        concat!("Size of: ", stringify!(_hipblasLtMatmulAlgo_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_hipblasLtMatmulAlgo_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_hipblasLtMatmulAlgo_t))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_hipblasLtMatmulAlgo_t),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).max_workspace_bytes) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_hipblasLtMatmulAlgo_t),
            "::",
            stringify!(max_workspace_bytes)
        )
    );
}
#[doc = " \\ingroup types_module\n  \\struct hipblasLtMatmulAlgo_t\n  \\brief Description of the matrix multiplication algorithm\n\n  \\details\n  This is an opaque structure holding the description of the matrix multiplication algorithm.\n  This structure can be trivially serialized and later restored for use with the same version of hipBLASLt library to save on selecting the right configuration again."]
pub type hipblasLtMatmulAlgo_t = _hipblasLtMatmulAlgo_t;
#[doc = " \\ingroup types_module\n  \\brief Description of the matrix multiplication algorithm\n\n  \\details\n  This is a descriptor that holds the configured matrix multiplication algorithm descriptor and its runtime properties.\n  This structure can be trivially serialized and later restored for use with the same version of hipBLASLt library to save on selecting the right configuration again."]
#[repr(C)]
#[derive(Debug, Copy, Clone, PartialOrd, PartialEq)]
pub struct _hipblasLtMatmulHeuristicResult_t {
    #[doc = "<Algo struct"]
    pub algo: hipblasLtMatmulAlgo_t,
    #[doc = "<Actual size of workspace memory required."]
    pub workspaceSize: usize,
    #[doc = "<Result status. Other fields are valid only if, after call to hipblasLtMatmulAlgoGetHeuristic(), this member is set to HIPBLAS_STATUS_SUCCESS.."]
    pub state: hipblasStatus_t,
    #[doc = "<Waves count is a device utilization metric. A wavesCount value of 1.0f suggests that when the kernel is launched it will fully occupy the GPU."]
    pub wavesCount: f32,
    #[doc = "<Reserved."]
    pub reserved: [::core::ffi::c_int; 4usize],
}
#[test]
fn bindgen_test_layout__hipblasLtMatmulHeuristicResult_t() {
    const UNINIT: ::core::mem::MaybeUninit<_hipblasLtMatmulHeuristicResult_t> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<_hipblasLtMatmulHeuristicResult_t>(),
        56usize,
        concat!("Size of: ", stringify!(_hipblasLtMatmulHeuristicResult_t))
    );
    assert_eq!(
        ::core::mem::align_of::<_hipblasLtMatmulHeuristicResult_t>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(_hipblasLtMatmulHeuristicResult_t)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).algo) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_hipblasLtMatmulHeuristicResult_t),
            "::",
            stringify!(algo)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).workspaceSize) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_hipblasLtMatmulHeuristicResult_t),
            "::",
            stringify!(workspaceSize)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).state) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_hipblasLtMatmulHeuristicResult_t),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).wavesCount) as usize - ptr as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_hipblasLtMatmulHeuristicResult_t),
            "::",
            stringify!(wavesCount)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).reserved) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_hipblasLtMatmulHeuristicResult_t),
            "::",
            stringify!(reserved)
        )
    );
}
impl Default for _hipblasLtMatmulHeuristicResult_t {
    fn default() -> Self {
        let mut s = ::core::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::core::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\ingroup types_module\n  \\brief Description of the matrix multiplication algorithm\n\n  \\details\n  This is a descriptor that holds the configured matrix multiplication algorithm descriptor and its runtime properties.\n  This structure can be trivially serialized and later restored for use with the same version of hipBLASLt library to save on selecting the right configuration again."]
pub type hipblasLtMatmulHeuristicResult_t = _hipblasLtMatmulHeuristicResult_t;
extern "C" {
    pub fn hipblasLtGetVersion(
        handle: hipblasLtHandle_t,
        version: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasLtGetGitRevision(
        handle: hipblasLtHandle_t,
        rev: *mut ::core::ffi::c_char,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasLtGetArchName(archName: *mut *mut ::core::ffi::c_char) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " \\ingroup library_module\n  \\brief Create a hipblaslt handle\n\n  \\details\n  This function initializes the hipBLASLt library and creates a handle to an\n opaque structure holding the hipBLASLt library context. It allocates light\n hardware resources on the host and device, and must be called prior to making\n any other hipBLASLt library calls. The hipBLASLt library context is tied to\n the current CUDA device. To use the library on multiple devices, one\n hipBLASLt handle should be created for each device.\n\n  @param[out]\n  handle  Pointer to the allocated hipBLASLt handle for the created hipBLASLt\n context.\n\n  \\retval HIPBLAS_STATUS_SUCCESS The allocation completed successfully.\n  \\retval HIPBLAS_STATUS_INVALID_VALUE \\p handle == NULL."]
    pub fn hipblasLtCreate(handle: *mut hipblasLtHandle_t) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " \\ingroup library_module\n  \\brief Destory a hipblaslt handle\n\n  \\details\n  This function releases hardware resources used by the hipBLASLt library.\n  This function is usually the last call with a particular handle to the\n hipBLASLt library. Because hipblasLtCreate() allocates some internal\n resources and the release of those resources by calling hipblasLtDestroy()\n will implicitly call hipDeviceSynchronize(), it is recommended to minimize\n the number of hipblasLtCreate()/hipblasLtDestroy() occurrences.\n\n  @param[in]\n  handle  Pointer to the hipBLASLt handle to be destroyed.\n\n  \\retval HIPBLAS_STATUS_SUCCESS The hipBLASLt context was successfully\n destroyed. \\retval HIPBLAS_STATUS_NOT_INITIALIZED The hipBLASLt library was\n not initialized. \\retval HIPBLAS_STATUS_INVALID_VALUE \\p handle == NULL."]
    pub fn hipblasLtDestroy(handle: hipblasLtHandle_t) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " \\ingroup library_module\n  \\brief Create a matrix layout descriptor\n\n  \\details\n  This function creates a matrix layout descriptor by allocating the memory\n needed to hold its opaque structure.\n\n  @param[out]\n  matLayout Pointer to the structure holding the matrix layout descriptor\n created by this function. see \\ref hipblasLtMatrixLayout_t .\n  @param[in]\n  type Enumerant that specifies the data precision for the matrix layout\n descriptor this function creates. See hipDataType.\n  @param[in]\n  rows Number of rows of the matrix.\n  @param[in]\n  cols Number of columns of the matrix.\n  @param[in]\n  ld The leading dimension of the matrix. In column major layout, this is the\n number of elements to jump to reach the next column. Thus ld >= m (number of\n rows).\n\n  \\retval HIPBLAS_STATUS_SUCCESS If the descriptor was created successfully.\n  \\retval HIPBLAS_STATUS_ALLOC_FAILED If the memory could not be allocated."]
    pub fn hipblasLtMatrixLayoutCreate(
        matLayout: *mut hipblasLtMatrixLayout_t,
        type_: hipDataType,
        rows: u64,
        cols: u64,
        ld: i64,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " \\ingroup library_module\n  \\brief Destory a matrix layout descriptor\n\n  \\details\n  This function destroys a previously created matrix layout descriptor object.\n\n  @param[in]\n  matLayout Pointer to the structure holding the matrix layout descriptor that\n should be destroyed by this function. see \\ref hipblasLtMatrixLayout_t .\n\n  \\retval HIPBLAS_STATUS_SUCCESS If the operation was successful."]
    pub fn hipblasLtMatrixLayoutDestroy(matLayout: hipblasLtMatrixLayout_t) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " \\ingroup library_module\n  \\brief  Set attribute to a matrix descriptor\n\n  \\details\n  This function sets the value of the specified attribute belonging to a\n previously created matrix descriptor.\n\n  @param[in]\n  matLayout  Pointer to the previously created structure holding the matrix\n mdescriptor queried by this function. See \\ref hipblasLtMatrixLayout_t.\n  @param[in]\n  attr  \tThe attribute that will be set by this function. See \\ref\n hipblasLtMatrixLayoutAttribute_t.\n  @param[in]\n  buf  The value to which the specified attribute should be set.\n  @param[in]\n  sizeInBytes Size of buf buffer (in bytes) for verification.\n\n  \\retval HIPBLAS_STATUS_SUCCESS If the attribute was set successfully..\n  \\retval HIPBLAS_STATUS_INVALID_VALUE If \\p buf is NULL or \\p sizeInBytes\n doesn't match the size of the internal storage for the selected attribute."]
    pub fn hipblasLtMatrixLayoutSetAttribute(
        matLayout: hipblasLtMatrixLayout_t,
        attr: hipblasLtMatrixLayoutAttribute_t,
        buf: *const ::core::ffi::c_void,
        sizeInBytes: usize,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " \\ingroup library_module\n  \\brief Query attribute from a matrix descriptor\n\n  \\details\n  This function returns the value of the queried attribute belonging to a\n previously created matrix descriptor.\n\n  @param[in]\n  matLayout  Pointer to the previously created structure holding the matrix\n descriptor queried by this function. See \\ref hipblasLtMatrixLayout_t.\n  @param[in]\n  attr  \t    The attribute that will be retrieved by this function. See\n \\ref hipblasLtMatrixLayoutAttribute_t.\n  @param[out]\n  buf         Memory address containing the attribute value retrieved by this\n function.\n  @param[in]\n  sizeInBytes Size of \\p buf buffer (in bytes) for verification.\n  @param[out]\n  sizeWritten Valid only when the return value is HIPBLAS_STATUS_SUCCESS. If\n sizeInBytes is non-zero: then sizeWritten is the number of bytes actually\n written; if sizeInBytes is 0: then sizeWritten is the number of bytes needed\n to write full contents.\n\n  \\retval HIPBLAS_STATUS_SUCCESS       If attribute's value was successfully\n written to user memory. \\retval HIPBLAS_STATUS_INVALID_VALUE If \\p\n sizeInBytes is 0 and \\p sizeWritten is NULL, or if \\p sizeInBytes is non-zero\n and \\p buf is NULL, or \\p sizeInBytes doesn't match size of internal storage\n for the selected attribute."]
    pub fn hipblasLtMatrixLayoutGetAttribute(
        matLayout: hipblasLtMatrixLayout_t,
        attr: hipblasLtMatrixLayoutAttribute_t,
        buf: *mut ::core::ffi::c_void,
        sizeInBytes: usize,
        sizeWritten: *mut usize,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " \\ingroup library_module\n  \\brief Create a matrix multiply descriptor\n\n  \\details\n  This function creates a matrix multiply descriptor by allocating the memory\n needed to hold its opaque structure.\n\n  @param[out]\n  matmulDesc  Pointer to the structure holding the matrix multiply descriptor\n created by this function. See \\ref hipblasLtMatmulDesc_t .\n  @param[in]\n  computeType  Enumerant that specifies the data precision for the matrix\n multiply descriptor this function creates. See hipblasComputeType_t .\n  @param[in]\n  scaleType  Enumerant that specifies the data precision for the matrix\n transform descriptor this function creates. See hipDataType.\n\n  \\retval HIPBLAS_STATUS_SUCCESS If the descriptor was created successfully.\n  \\retval HIPBLAS_STATUS_ALLOC_FAILED If the memory could not be allocated."]
    pub fn hipblasLtMatmulDescCreate(
        matmulDesc: *mut hipblasLtMatmulDesc_t,
        computeType: hipblasComputeType_t,
        scaleType: hipDataType,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " \\ingroup library_module\n  \\brief Destory a matrix multiply descriptor\n\n  \\details\n  This function destroys a previously created matrix multiply descriptor\n object.\n\n  @param[in]\n  matmulDesc  Pointer to the structure holding the matrix multiply descriptor\n that should be destroyed by this function. See \\ref hipblasLtMatmulDesc_t .\n\n  \\retval HIPBLAS_STATUS_SUCCESS If operation was successful."]
    pub fn hipblasLtMatmulDescDestroy(matmulDesc: hipblasLtMatmulDesc_t) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " \\ingroup library_module\n  \\brief  Set attribute to a matrix multiply descriptor\n\n  \\details\n  This function sets the value of the specified attribute belonging to a\n previously created matrix multiply descriptor.\n\n  @param[in]\n  matmulDesc  Pointer to the previously created structure holding the matrix\n multiply descriptor queried by this function. See \\ref hipblasLtMatmulDesc_t.\n  @param[in]\n  attr  \tThe attribute that will be set by this function. See \\ref\n hipblasLtMatmulDescAttributes_t.\n  @param[in]\n  buf  The value to which the specified attribute should be set.\n  @param[in]\n  sizeInBytes Size of buf buffer (in bytes) for verification.\n\n  \\retval HIPBLAS_STATUS_SUCCESS If the attribute was set successfully..\n  \\retval HIPBLAS_STATUS_INVALID_VALUE If \\p buf is NULL or \\p sizeInBytes\n doesn't match the size of the internal storage for the selected attribute."]
    pub fn hipblasLtMatmulDescSetAttribute(
        matmulDesc: hipblasLtMatmulDesc_t,
        attr: hipblasLtMatmulDescAttributes_t,
        buf: *const ::core::ffi::c_void,
        sizeInBytes: usize,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " \\ingroup library_module\n  \\brief Query attribute from a matrix multiply descriptor\n\n  \\details\n  This function returns the value of the queried attribute belonging to a\n previously created matrix multiply descriptor.\n\n  @param[in]\n  matmulDesc  Pointer to the previously created structure holding the matrix\n multiply descriptor queried by this function. See \\ref hipblasLtMatmulDesc_t.\n  @param[in]\n  attr  \t    The attribute that will be retrieved by this function. See\n \\ref hipblasLtMatmulDescAttributes_t.\n  @param[out]\n  buf         Memory address containing the attribute value retrieved by this\n function.\n  @param[in]\n  sizeInBytes Size of \\p buf buffer (in bytes) for verification.\n  @param[out]\n  sizeWritten Valid only when the return value is HIPBLAS_STATUS_SUCCESS. If\n sizeInBytes is non-zero: then sizeWritten is the number of bytes actually\n written; if sizeInBytes is 0: then sizeWritten is the number of bytes needed\n to write full contents.\n\n  \\retval HIPBLAS_STATUS_SUCCESS       If attribute's value was successfully\n written to user memory. \\retval HIPBLAS_STATUS_INVALID_VALUE If \\p\n sizeInBytes is 0 and \\p sizeWritten is NULL, or if \\p sizeInBytes is non-zero\n and \\p buf is NULL, or \\p sizeInBytes doesn't match size of internal storage\n for the selected attribute."]
    pub fn hipblasLtMatmulDescGetAttribute(
        matmulDesc: hipblasLtMatmulDesc_t,
        attr: hipblasLtMatmulDescAttributes_t,
        buf: *mut ::core::ffi::c_void,
        sizeInBytes: usize,
        sizeWritten: *mut usize,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " \\ingroup library_module\n  \\brief Create a preference descriptor\n\n  \\details\n  This function creates a matrix multiply heuristic search preferences\n descriptor by allocating the memory needed to hold its opaque structure.\n\n  @param[out]\n  pref  Pointer to the structure holding the matrix multiply preferences\n descriptor created by this function. see \\ref hipblasLtMatmulPreference_t .\n\n  \\retval HIPBLAS_STATUS_SUCCESS         If the descriptor was created\n successfully. \\retval HIPBLAS_STATUS_ALLOC_FAILED    If memory could not be\n allocated."]
    pub fn hipblasLtMatmulPreferenceCreate(
        pref: *mut hipblasLtMatmulPreference_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " \\ingroup library_module\n  \\brief Destory a preferences descriptor\n\n  \\details\n  This function destroys a previously created matrix multiply preferences\n descriptor object.\n\n  @param[in]\n  pref  Pointer to the structure holding the matrix multiply preferences\n descriptor that should be destroyed by this function. See \\ref\n hipblasLtMatmulPreference_t .\n\n  \\retval HIPBLAS_STATUS_SUCCESS If operation was successful."]
    pub fn hipblasLtMatmulPreferenceDestroy(pref: hipblasLtMatmulPreference_t) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " \\ingroup library_module\n  \\brief Set attribute to a preference descriptor\n\n  \\details\n  This function sets the value of the specified attribute belonging to a\n previously created matrix multiply preferences descriptor.\n\n  @param[in]\n  pref        Pointer to the previously created structure holding the matrix\n multiply preferences descriptor queried by this function. See \\ref\n hipblasLtMatmulPreference_t\n  @param[in]\n  attr  \t    The attribute that will be set by this function. See \\ref\n hipblasLtMatmulPreferenceAttributes_t.\n  @param[in]\n  buf         The value to which the specified attribute should be set.\n  @param[in]\n  sizeInBytes Size of \\p buf buffer (in bytes) for verification.\n\n  \\retval HIPBLAS_STATUS_SUCCESS If the attribute was set successfully..\n  \\retval HIPBLAS_STATUS_INVALID_VALUE If \\p buf is NULL or \\p sizeInBytes\n doesn't match the size of the internal storage for the selected attribute."]
    pub fn hipblasLtMatmulPreferenceSetAttribute(
        pref: hipblasLtMatmulPreference_t,
        attr: hipblasLtMatmulPreferenceAttributes_t,
        buf: *const ::core::ffi::c_void,
        sizeInBytes: usize,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " \\ingroup library_module\n  \\brief Query attribute from a preference descriptor\n\n  \\details\n  This function returns the value of the queried attribute belonging to a\n previously created matrix multiply heuristic search preferences descriptor.\n\n  @param[in]\n  pref        Pointer to the previously created structure holding the matrix\n multiply heuristic search preferences descriptor queried by this function.\n See \\ref hipblasLtMatmulPreference_t.\n  @param[in]\n  attr  \t    The attribute that will be retrieved by this function. See\n \\ref hipblasLtMatmulPreferenceAttributes_t.\n  @param[out]\n  buf         Memory address containing the attribute value retrieved by this\n function.\n  @param[in]\n  sizeInBytes Size of \\p buf buffer (in bytes) for verification.\n  @param[out]\n  sizeWritten Valid only when the return value is HIPBLAS_STATUS_SUCCESS. If\n sizeInBytes is non-zero: then sizeWritten is the number of bytes actually\n written; if sizeInBytes is 0: then sizeWritten is the number of bytes needed\n to write full contents.\n\n  \\retval HIPBLAS_STATUS_SUCCESS       If attribute's value was successfully\n written to user memory. \\retval HIPBLAS_STATUS_INVALID_VALUE If \\p\n sizeInBytes is 0 and \\p sizeWritten is NULL, or if \\p sizeInBytes is non-zero\n and \\p buf is NULL, or \\p sizeInBytes doesn't match size of internal storage\n for the selected attribute."]
    pub fn hipblasLtMatmulPreferenceGetAttribute(
        pref: hipblasLtMatmulPreference_t,
        attr: hipblasLtMatmulPreferenceAttributes_t,
        buf: *mut ::core::ffi::c_void,
        sizeInBytes: usize,
        sizeWritten: *mut usize,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " \\ingroup library_module\n  \\brief Retrieve the possible algorithms\n\n  \\details\n  This function retrieves the possible algorithms for the matrix multiply\n operation hipblasLtMatmul() function with the given input matrices A, B and\n C, and the output matrix D. The output is placed in heuristicResultsArray[]\n in the order of increasing estimated compute time.\n\n  @param[in]\n  handle                  Pointer to the allocated hipBLASLt handle for the\n hipBLASLt context. See \\ref hipblasLtHandle_t .\n  @param[in]\n  matmulDesc              Handle to a previously created matrix multiplication\n descriptor of type \\ref hipblasLtMatmulDesc_t .\n  @param[in]\n  Adesc,Bdesc,Cdesc,Ddesc Handles to the previously created matrix layout\n descriptors of the type \\ref hipblasLtMatrixLayout_t .\n  @param[in]\n  pref                    Pointer to the structure holding the heuristic\n search preferences descriptor. See \\ref hipblasLtMatmulPreference_t .\n  @param[in]\n  requestedAlgoCount      Size of the \\p heuristicResultsArray (in elements).\n This is the requested maximum number of algorithms to return.\n  @param[out]\n  heuristicResultsArray[] Array containing the algorithm heuristics and\n associated runtime characteristics, returned by this function, in the order\n of increasing estimated compute time.\n  @param[out]\n  returnAlgoCount         Number of algorithms returned by this function. This\n is the number of \\p heuristicResultsArray elements written.\n\n  \\retval HIPBLAS_STATUS_SUCCESS           If query was successful. Inspect\n heuristicResultsArray[0 to (returnAlgoCount -1)].state for the status of the\n results. \\retval HIPBLAS_STATUS_NOT_SUPPORTED     If no heuristic function\n available for current configuration. \\retval HIPBLAS_STATUS_INVALID_VALUE If\n \\p requestedAlgoCount is less or equal to zero."]
    pub fn hipblasLtMatmulAlgoGetHeuristic(
        handle: hipblasLtHandle_t,
        matmulDesc: hipblasLtMatmulDesc_t,
        Adesc: hipblasLtMatrixLayout_t,
        Bdesc: hipblasLtMatrixLayout_t,
        Cdesc: hipblasLtMatrixLayout_t,
        Ddesc: hipblasLtMatrixLayout_t,
        pref: hipblasLtMatmulPreference_t,
        requestedAlgoCount: ::core::ffi::c_int,
        heuristicResultsArray: *mut hipblasLtMatmulHeuristicResult_t,
        returnAlgoCount: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " \\ingroup library_module\n  \\brief Retrieve the possible algorithms\n\n  \\details\n  This function computes the matrix multiplication of matrices A and B to\n produce the output matrix D, according to the following operation: \\p D = \\p\n alpha*( \\p A *\\p B) + \\p beta*( \\p C ), where \\p A, \\p B, and \\p C are input\n matrices, and \\p alpha and \\p beta are input scalars. Note: This function\n supports both in-place matrix multiplication (C == D and Cdesc == Ddesc) and\n out-of-place matrix multiplication (C != D, both matrices must have the same\n data type, number of rows, number of columns, batch size, and memory order).\n In the out-of-place case, the leading dimension of C can be different from\n the leading dimension of D. Specifically the leading dimension of C can be 0\n to achieve row or column broadcast. If Cdesc is omitted, this function\n assumes it to be equal to Ddesc.\n\n  @param[in]\n  handle                  Pointer to the allocated hipBLASLt handle for the\n hipBLASLt context. See \\ref hipblasLtHandle_t .\n  @param[in]\n  matmulDesc              Handle to a previously created matrix multiplication\n descriptor of type \\ref hipblasLtMatmulDesc_t .\n  @param[in]\n  alpha,beta              Pointers to the scalars used in the multiplication.\n  @param[in]\n  Adesc,Bdesc,Cdesc,Ddesc Handles to the previously created matrix layout\n descriptors of the type \\ref hipblasLtMatrixLayout_t .\n  @param[in]\n  A,B,C                   Pointers to the GPU memory associated with the\n corresponding descriptors \\p Adesc, \\p Bdesc and \\p Cdesc .\n  @param[out]\n  D                       Pointer to the GPU memory associated with the\n descriptor \\p Ddesc .\n  @param[in]\n  algo                    Handle for matrix multiplication algorithm to be\n used. See \\ref hipblasLtMatmulAlgo_t . When NULL, an implicit heuristics query\n with default search preferences will be performed to determine actual\n algorithm to use.\n  @param[in]\n  workspace               Pointer to the workspace buffer allocated in the GPU\n memory. Pointer must be 16B aligned (that is, lowest 4 bits of address must\n be 0).\n  @param[in]\n  workspaceSizeInBytes    Size of the workspace.\n  @param[in]\n  stream                  The HIP stream where all the GPU work will be\n submitted.\n\n  \\retval HIPBLAS_STATUS_SUCCESS           If the operation completed\n successfully. \\retval HIPBLAS_STATUS_EXECUTION_FAILED  If HIP reported an\n execution error from the device. \\retval HIPBLAS_STATUS_ARCH_MISMATCH     If\n the configured operation cannot be run using the selected device. \\retval\n HIPBLAS_STATUS_NOT_SUPPORTED     If the current implementation on the\n selected device doesn't support the configured operation. \\retval\n HIPBLAS_STATUS_INVALID_VALUE     If the parameters are unexpectedly NULL, in\n conflict or in an impossible configuration. For example, when\n workspaceSizeInBytes is less than workspace required by the configured algo.\n  \\retval HIBLAS_STATUS_NOT_INITIALIZED    If hipBLASLt handle has not been\n initialized."]
    pub fn hipblasLtMatmul(
        handle: hipblasLtHandle_t,
        matmulDesc: hipblasLtMatmulDesc_t,
        alpha: *const ::core::ffi::c_void,
        A: *const ::core::ffi::c_void,
        Adesc: hipblasLtMatrixLayout_t,
        B: *const ::core::ffi::c_void,
        Bdesc: hipblasLtMatrixLayout_t,
        beta: *const ::core::ffi::c_void,
        C: *const ::core::ffi::c_void,
        Cdesc: hipblasLtMatrixLayout_t,
        D: *mut ::core::ffi::c_void,
        Ddesc: hipblasLtMatrixLayout_t,
        algo: *const hipblasLtMatmulAlgo_t,
        workspace: *mut ::core::ffi::c_void,
        workspaceSizeInBytes: usize,
        stream: hipStream_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " Create new matrix transform operation descriptor.\n\n \\retval     HIPBLAS_STATUS_ALLOC_FAILED  if memory could not be allocated\n \\retval     HIPBLAS_STATUS_SUCCESS       if desciptor was created successfully"]
    pub fn hipblasLtMatrixTransformDescCreate(
        transformDesc: *mut hipblasLtMatrixTransformDesc_t,
        scaleType: hipDataType,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " Destroy matrix transform operation descriptor.\n\n \\retval     HIPBLAS_STATUS_SUCCESS  if operation was successful"]
    pub fn hipblasLtMatrixTransformDescDestroy(
        transformDesc: hipblasLtMatrixTransformDesc_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " Set matrix transform operation descriptor attribute.\n\n \\param[in]  transformDesc  The descriptor\n \\param[in]  attr           The attribute\n \\param[in]  buf            memory address containing the new value\n \\param[in]  sizeInBytes    size of buf buffer for verification (in bytes)\n\n \\retval     HIPBLAS_STATUS_INVALID_VALUE  if buf is NULL or sizeInBytes doesn't match size of internal storage for\n                                          selected attribute\n \\retval     HIPBLAS_STATUS_SUCCESS        if attribute was set successfully"]
    pub fn hipblasLtMatrixTransformDescSetAttribute(
        transformDesc: hipblasLtMatrixTransformDesc_t,
        attr: hipblasLtMatrixTransformDescAttributes_t,
        buf: *const ::core::ffi::c_void,
        sizeInBytes: usize,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " Get matrix transform operation descriptor attribute.\n\n \\param[in]  transformDesc  The descriptor\n \\param[in]  attr           The attribute\n \\param[out] buf            memory address containing the new value\n \\param[in]  sizeInBytes    size of buf buffer for verification (in bytes)\n \\param[out] sizeWritten    only valid when return value is CUBLAS_STATUS_SUCCESS. If sizeInBytes is non-zero: number\n of bytes actually written, if sizeInBytes is 0: number of bytes needed to write full contents\n\n \\retval     HIPBLAS_STATUS_INVALID_VALUE  if sizeInBytes is 0 and sizeWritten is NULL, or if  sizeInBytes is non-zero\n                                          and buf is NULL or sizeInBytes doesn't match size of internal storage for\n                                          selected attribute\n \\retval     HIPBLAS_STATUS_SUCCESS        if attribute's value was successfully written to user memory"]
    pub fn hipblasLtMatrixTransformDescGetAttribute(
        transformDesc: hipblasLtMatrixTransformDesc_t,
        attr: hipblasLtMatrixTransformDescAttributes_t,
        buf: *mut ::core::ffi::c_void,
        sizeInBytes: usize,
        sizeWritten: *mut usize,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " Matrix layout conversion helper (C = alpha * op(A) + beta * op(B))\n\n Can be used to change memory order of data or to scale and shift the values.\n\n \\retval     HIPBLAS_STATUS_NOT_INITIALIZED   if hipBLASLt handle has not been initialized\n \\retval     HIPBLAS_STATUS_INVALID_VALUE     if parameters are in conflict or in an impossible configuration; e.g.\n                                              when A is not NULL, but Adesc is NULL\n \\retval     HIPBLAS_STATUS_NOT_SUPPORTED     if current implementation on selected device doesn't support configured\n                                              operation\n \\retval     HIPBLAS_STATUS_ARCH_MISMATCH     if configured operation cannot be run using selected device\n \\retval     HIPBLAS_STATUS_EXECUTION_FAILED  if cuda reported execution error from the device\n \\retval     HIPBLAS_STATUS_SUCCESS           if the operation completed successfully"]
    pub fn hipblasLtMatrixTransform(
        lightHandle: hipblasLtHandle_t,
        transformDesc: hipblasLtMatrixTransformDesc_t,
        alpha: *const ::core::ffi::c_void,
        A: *const ::core::ffi::c_void,
        Adesc: hipblasLtMatrixLayout_t,
        beta: *const ::core::ffi::c_void,
        B: *const ::core::ffi::c_void,
        Bdesc: hipblasLtMatrixLayout_t,
        C: *mut ::core::ffi::c_void,
        Cdesc: hipblasLtMatrixLayout_t,
        stream: hipStream_t,
    ) -> hipblasStatus_t;
}
