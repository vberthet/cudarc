/* automatically generated by rust-bindgen 0.69.1 */

#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, PartialEq)]
pub struct float2 {
    pub x: f32,
    pub y: f32,
}
#[test]
fn bindgen_test_layout_float2() {
    const UNINIT: ::core::mem::MaybeUninit<float2> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<float2>(),
        8usize,
        concat!("Size of: ", stringify!(float2))
    );
    assert_eq!(
        ::core::mem::align_of::<float2>(),
        4usize,
        concat!("Alignment of ", stringify!(float2))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!("Offset of field: ", stringify!(float2), "::", stringify!(x))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        4usize,
        concat!("Offset of field: ", stringify!(float2), "::", stringify!(y))
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, PartialEq)]
pub struct double2 {
    pub x: f64,
    pub y: f64,
}
#[test]
fn bindgen_test_layout_double2() {
    const UNINIT: ::core::mem::MaybeUninit<double2> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<double2>(),
        16usize,
        concat!("Size of: ", stringify!(double2))
    );
    assert_eq!(
        ::core::mem::align_of::<double2>(),
        8usize,
        concat!("Alignment of ", stringify!(double2))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(double2),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(double2),
            "::",
            stringify!(y)
        )
    );
}
pub type hipFloatComplex = float2;
pub type hipDoubleComplex = double2;
pub type hipComplex = hipFloatComplex;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ihipStream_t {
    _unused: [u8; 0],
}
pub type hipStream_t = *mut ihipStream_t;
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum hipDataType {
    HIP_R_32F = 0,
    HIP_R_64F = 1,
    HIP_R_16F = 2,
    HIP_R_8I = 3,
    HIP_C_32F = 4,
    HIP_C_64F = 5,
    HIP_C_16F = 6,
    HIP_C_8I = 7,
    HIP_R_8U = 8,
    HIP_C_8U = 9,
    HIP_R_32I = 10,
    HIP_C_32I = 11,
    HIP_R_32U = 12,
    HIP_C_32U = 13,
    HIP_R_16BF = 14,
    HIP_C_16BF = 15,
    HIP_R_4I = 16,
    HIP_C_4I = 17,
    HIP_R_4U = 18,
    HIP_C_4U = 19,
    HIP_R_16I = 20,
    HIP_C_16I = 21,
    HIP_R_16U = 22,
    HIP_C_16U = 23,
    HIP_R_64I = 24,
    HIP_C_64I = 25,
    HIP_R_64U = 26,
    HIP_C_64U = 27,
    HIP_R_8F_E4M3_FNUZ = 1000,
    HIP_R_8F_E5M2_FNUZ = 1001,
}
#[doc = " \\brief hipblasHanlde_t is a void pointer, to store the library context (either rocBLAS or cuBLAS)"]
pub type hipblasHandle_t = *mut ::core::ffi::c_void;
pub type hipblasHalf = u16;
#[doc = " \\brief  To specify the datatype to be signed char"]
pub type hipblasInt8 = i8;
#[doc = " \\brief  Stride between matrices or vectors in strided_batched functions."]
pub type hipblasStride = i64;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub struct hipblasBfloat16 {
    pub data: u16,
}
#[test]
fn bindgen_test_layout_hipblasBfloat16() {
    const UNINIT: ::core::mem::MaybeUninit<hipblasBfloat16> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<hipblasBfloat16>(),
        2usize,
        concat!("Size of: ", stringify!(hipblasBfloat16))
    );
    assert_eq!(
        ::core::mem::align_of::<hipblasBfloat16>(),
        2usize,
        concat!("Alignment of ", stringify!(hipblasBfloat16))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).data) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipblasBfloat16),
            "::",
            stringify!(data)
        )
    );
}
#[doc = " \\brief Struct to represent a complex number with single precision real and imaginary parts."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, PartialEq)]
pub struct hipblasComplex {
    pub x: f32,
    pub y: f32,
}
#[test]
fn bindgen_test_layout_hipblasComplex() {
    const UNINIT: ::core::mem::MaybeUninit<hipblasComplex> = ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<hipblasComplex>(),
        8usize,
        concat!("Size of: ", stringify!(hipblasComplex))
    );
    assert_eq!(
        ::core::mem::align_of::<hipblasComplex>(),
        4usize,
        concat!("Alignment of ", stringify!(hipblasComplex))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipblasComplex),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(hipblasComplex),
            "::",
            stringify!(y)
        )
    );
}
#[doc = " \\brief Struct to represent a complex number with double precision real and imaginary parts."]
#[repr(C)]
#[derive(Debug, Default, Copy, Clone, PartialOrd, PartialEq)]
pub struct hipblasDoubleComplex {
    pub x: f64,
    pub y: f64,
}
#[test]
fn bindgen_test_layout_hipblasDoubleComplex() {
    const UNINIT: ::core::mem::MaybeUninit<hipblasDoubleComplex> =
        ::core::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::core::mem::size_of::<hipblasDoubleComplex>(),
        16usize,
        concat!("Size of: ", stringify!(hipblasDoubleComplex))
    );
    assert_eq!(
        ::core::mem::align_of::<hipblasDoubleComplex>(),
        8usize,
        concat!("Alignment of ", stringify!(hipblasDoubleComplex))
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).x) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(hipblasDoubleComplex),
            "::",
            stringify!(x)
        )
    );
    assert_eq!(
        unsafe { ::core::ptr::addr_of!((*ptr).y) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(hipblasDoubleComplex),
            "::",
            stringify!(y)
        )
    );
}
#[repr(u32)]
#[doc = " \\brief hipblas status codes definition"]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum hipblasStatus_t {
    #[doc = "< Function succeeds"]
    HIPBLAS_STATUS_SUCCESS = 0,
    #[doc = "< HIPBLAS library not initialized"]
    HIPBLAS_STATUS_NOT_INITIALIZED = 1,
    #[doc = "< resource allocation failed"]
    HIPBLAS_STATUS_ALLOC_FAILED = 2,
    #[doc = "< unsupported numerical value was passed to function"]
    HIPBLAS_STATUS_INVALID_VALUE = 3,
    #[doc = "< access to GPU memory space failed"]
    HIPBLAS_STATUS_MAPPING_ERROR = 4,
    #[doc = "< GPU program failed to execute"]
    HIPBLAS_STATUS_EXECUTION_FAILED = 5,
    #[doc = "< an internal HIPBLAS operation failed"]
    HIPBLAS_STATUS_INTERNAL_ERROR = 6,
    #[doc = "< function not implemented"]
    HIPBLAS_STATUS_NOT_SUPPORTED = 7,
    #[doc = "< architecture mismatch"]
    HIPBLAS_STATUS_ARCH_MISMATCH = 8,
    #[doc = "< hipBLAS handle is null pointer"]
    HIPBLAS_STATUS_HANDLE_IS_NULLPTR = 9,
    #[doc = "<  unsupported enum value was passed to function"]
    HIPBLAS_STATUS_INVALID_ENUM = 10,
    #[doc = "<  back-end returned an unsupported status code"]
    HIPBLAS_STATUS_UNKNOWN = 11,
}
#[repr(u32)]
#[doc = " \\brief Indicates if scalar pointers are on host or device. This is used for scalars alpha and beta and for scalar function return values."]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum hipblasPointerMode_t {
    #[doc = "< Scalar values affected by this variable will be located on the host."]
    HIPBLAS_POINTER_MODE_HOST = 0,
    #[doc = "<  Scalar values affected by this variable will be located on the device."]
    HIPBLAS_POINTER_MODE_DEVICE = 1,
}
#[repr(u32)]
#[doc = " \\brief Used to specify whether the matrix is to be transposed or not."]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum hipblasOperation_t {
    #[doc = "<  Operate with the matrix."]
    HIPBLAS_OP_N = 111,
    #[doc = "<  Operate with the transpose of the matrix."]
    HIPBLAS_OP_T = 112,
    #[doc = "< Operate with the conjugate transpose of the matrix."]
    HIPBLAS_OP_C = 113,
}
#[repr(u32)]
#[doc = " \\brief Used by the Hermitian, symmetric and triangular matrix routines to specify whether the upper or lower triangle is being referenced."]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum hipblasFillMode_t {
    #[doc = "<  Upper triangle"]
    HIPBLAS_FILL_MODE_UPPER = 121,
    #[doc = "<  Lower triangle"]
    HIPBLAS_FILL_MODE_LOWER = 122,
    HIPBLAS_FILL_MODE_FULL = 123,
}
#[repr(u32)]
#[doc = " \\brief It is used by the triangular matrix routines to specify whether the matrix is unit triangular."]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum hipblasDiagType_t {
    #[doc = "<  Non-unit triangular."]
    HIPBLAS_DIAG_NON_UNIT = 131,
    #[doc = "<  Unit triangular."]
    HIPBLAS_DIAG_UNIT = 132,
}
#[repr(u32)]
#[doc = " \\brief Indicates the side matrix A is located relative to matrix B during multiplication."]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum hipblasSideMode_t {
    HIPBLAS_SIDE_LEFT = 141,
    HIPBLAS_SIDE_RIGHT = 142,
    HIPBLAS_SIDE_BOTH = 143,
}
#[repr(u32)]
#[doc = " \\brief Indicates the precision of data used. hipblasDatatype_t is deprecated as of hipBLAS 2.0.0 and will\nbe removed in a future release as generally replaced by hipDataType."]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum hipblasDatatype_t {
    #[doc = "< 16 bit floating point, real"]
    HIPBLAS_R_16F = 150,
    #[doc = "< 32 bit floating point, real"]
    HIPBLAS_R_32F = 151,
    #[doc = "< 64 bit floating point, real"]
    HIPBLAS_R_64F = 152,
    #[doc = "< 16 bit floating point, complex"]
    HIPBLAS_C_16F = 153,
    #[doc = "< 32 bit floating point, complex"]
    HIPBLAS_C_32F = 154,
    #[doc = "< 64 bit floating point, complex"]
    HIPBLAS_C_64F = 155,
    #[doc = "<  8 bit signed integer, real"]
    HIPBLAS_R_8I = 160,
    #[doc = "<  8 bit unsigned integer, real"]
    HIPBLAS_R_8U = 161,
    #[doc = "< 32 bit signed integer, real"]
    HIPBLAS_R_32I = 162,
    #[doc = "< 32 bit unsigned integer, real"]
    HIPBLAS_R_32U = 163,
    #[doc = "<  8 bit signed integer, complex"]
    HIPBLAS_C_8I = 164,
    #[doc = "<  8 bit unsigned integer, complex"]
    HIPBLAS_C_8U = 165,
    #[doc = "< 32 bit signed integer, complex"]
    HIPBLAS_C_32I = 166,
    #[doc = "< 32 bit unsigned integer, complex"]
    HIPBLAS_C_32U = 167,
    #[doc = "< 16 bit bfloat, real"]
    HIPBLAS_R_16B = 168,
    #[doc = "< 16 bit bfloat, complex"]
    HIPBLAS_C_16B = 169,
    #[doc = "< Invalid datatype value, do not use"]
    HIPBLAS_DATATYPE_INVALID = 255,
}
#[repr(u32)]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum hipblasComputeType_t {
    #[doc = "< compute will be at least 16-bit precision"]
    HIPBLAS_COMPUTE_16F = 0,
    #[doc = "< compute will be exactly 16-bit precision"]
    HIPBLAS_COMPUTE_16F_PEDANTIC = 1,
    #[doc = "< compute will be at least 32-bit precision"]
    HIPBLAS_COMPUTE_32F = 2,
    #[doc = "< compute will be exactly 32-bit precision"]
    HIPBLAS_COMPUTE_32F_PEDANTIC = 3,
    #[doc = "< 32-bit input can use 16-bit compute"]
    HIPBLAS_COMPUTE_32F_FAST_16F = 4,
    #[doc = "< 32-bit input can is bf16 compute"]
    HIPBLAS_COMPUTE_32F_FAST_16BF = 5,
    HIPBLAS_COMPUTE_32F_FAST_TF32 = 6,
    #[doc = "< compute will be at least 64-bit precision"]
    HIPBLAS_COMPUTE_64F = 7,
    #[doc = "< compute will be exactly 64-bit precision"]
    HIPBLAS_COMPUTE_64F_PEDANTIC = 8,
    #[doc = "< compute will be at least 32-bit integer precision"]
    HIPBLAS_COMPUTE_32I = 9,
    #[doc = "< compute will be exactly 32-bit integer precision"]
    HIPBLAS_COMPUTE_32I_PEDANTIC = 10,
}
#[repr(u32)]
#[doc = " \\brief Indicates if layer is active with bitmask."]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum hipblasGemmAlgo_t {
    #[doc = "<  enumerator rocblas_gemm_algo_standard"]
    HIPBLAS_GEMM_DEFAULT = 160,
}
#[repr(u32)]
#[doc = " \\brief Indicates if atomics operations are allowed. Not allowing atomic operations may generally improve determinism and repeatability of results at a cost of performance.\n         By default, the rocBLAS backend will allow atomic operations while the cuBLAS backend will disallow atomic operations. See backend documentation\n         for more detail."]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum hipblasAtomicsMode_t {
    #[doc = "<  Algorithms will refrain from atomics where applicable."]
    HIPBLAS_ATOMICS_NOT_ALLOWED = 0,
    #[doc = "< Algorithms will take advantage of atomics where applicable."]
    HIPBLAS_ATOMICS_ALLOWED = 1,
}
#[repr(u32)]
#[doc = " \\brief Control flags passed into gemm ex with flags algorithms. Only relevant with rocBLAS backend. See rocBLAS documentation\n         for more information."]
#[derive(Debug, Copy, Clone, Hash, PartialOrd, Ord, PartialEq, Eq)]
pub enum hipblasGemmFlags_t {
    #[doc = "< Default empty flags"]
    HIPBLAS_GEMM_FLAGS_NONE = 0,
    HIPBLAS_GEMM_FLAGS_USE_CU_EFFICIENCY = 2,
    #[doc = "< enumerator rocblas_gemm_flags_fp16_alt_impl"]
    HIPBLAS_GEMM_FLAGS_FP16_ALT_IMPL = 4,
    HIPBLAS_GEMM_FLAGS_CHECK_SOLUTION_INDEX = 8,
    HIPBLAS_GEMM_FLAGS_FP16_ALT_IMPL_RNZ = 16,
}
extern "C" {
    #[doc = " \\brief Create hipblas handle."]
    pub fn hipblasCreate(handle: *mut hipblasHandle_t) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " \\brief Destroys the library context created using hipblasCreate()"]
    pub fn hipblasDestroy(handle: hipblasHandle_t) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " \\brief Set stream for handle"]
    pub fn hipblasSetStream(handle: hipblasHandle_t, streamId: hipStream_t) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " \\brief Get stream[0] for handle"]
    pub fn hipblasGetStream(handle: hipblasHandle_t, streamId: *mut hipStream_t)
        -> hipblasStatus_t;
}
extern "C" {
    #[doc = " \\brief Set hipblas pointer mode"]
    pub fn hipblasSetPointerMode(
        handle: hipblasHandle_t,
        mode: hipblasPointerMode_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " \\brief Get hipblas pointer mode"]
    pub fn hipblasGetPointerMode(
        handle: hipblasHandle_t,
        mode: *mut hipblasPointerMode_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " \\brief copy vector from host to device\n@param[in]\nn           [int]\nnumber of elements in the vector\n@param[in]\nelemSize    [int]\nSize of both vectors in bytes\n@param[in]\nx           pointer to vector on the host\n@param[in]\nincx        [int]\nspecifies the increment for the elements of the vector\n@param[out]\ny           pointer to vector on the device\n@param[in]\nincy        [int]\nspecifies the increment for the elements of the vector"]
    pub fn hipblasSetVector(
        n: ::core::ffi::c_int,
        elemSize: ::core::ffi::c_int,
        x: *const ::core::ffi::c_void,
        incx: ::core::ffi::c_int,
        y: *mut ::core::ffi::c_void,
        incy: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " \\brief copy vector from device to host\n@param[in]\nn           [int]\nnumber of elements in the vector\n@param[in]\nelemSize    [int]\nSize of both vectors in bytes\n@param[in]\nx           pointer to vector on the device\n@param[in]\nincx        [int]\nspecifies the increment for the elements of the vector\n@param[out]\ny           pointer to vector on the host\n@param[in]\nincy        [int]\nspecifies the increment for the elements of the vector"]
    pub fn hipblasGetVector(
        n: ::core::ffi::c_int,
        elemSize: ::core::ffi::c_int,
        x: *const ::core::ffi::c_void,
        incx: ::core::ffi::c_int,
        y: *mut ::core::ffi::c_void,
        incy: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " \\brief copy matrix from host to device\n@param[in]\nrows        [int]\nnumber of rows in matrices\n@param[in]\ncols        [int]\nnumber of columns in matrices\n@param[in]\nelemSize   [int]\nnumber of bytes per element in the matrix\n@param[in]\nAP          pointer to matrix on the host\n@param[in]\nlda         [int]\nspecifies the leading dimension of A, lda >= rows\n@param[out]\nBP           pointer to matrix on the GPU\n@param[in]\nldb         [int]\nspecifies the leading dimension of B, ldb >= rows"]
    pub fn hipblasSetMatrix(
        rows: ::core::ffi::c_int,
        cols: ::core::ffi::c_int,
        elemSize: ::core::ffi::c_int,
        AP: *const ::core::ffi::c_void,
        lda: ::core::ffi::c_int,
        BP: *mut ::core::ffi::c_void,
        ldb: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " \\brief copy matrix from device to host\n@param[in]\nrows        [int]\nnumber of rows in matrices\n@param[in]\ncols        [int]\nnumber of columns in matrices\n@param[in]\nelemSize   [int]\nnumber of bytes per element in the matrix\n@param[in]\nAP          pointer to matrix on the GPU\n@param[in]\nlda         [int]\nspecifies the leading dimension of A, lda >= rows\n@param[out]\nBP          pointer to matrix on the host\n@param[in]\nldb         [int]\nspecifies the leading dimension of B, ldb >= rows"]
    pub fn hipblasGetMatrix(
        rows: ::core::ffi::c_int,
        cols: ::core::ffi::c_int,
        elemSize: ::core::ffi::c_int,
        AP: *const ::core::ffi::c_void,
        lda: ::core::ffi::c_int,
        BP: *mut ::core::ffi::c_void,
        ldb: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " \\brief asynchronously copy vector from host to device\n\\details\nhipblasSetVectorAsync copies a vector from pinned host memory to device memory asynchronously.\nMemory on the host must be allocated with hipHostMalloc or the transfer will be synchronous.\n@param[in]\nn           [int]\nnumber of elements in the vector\n@param[in]\nelemSize   [int]\nnumber of bytes per element in the matrix\n@param[in]\nx           pointer to vector on the host\n@param[in]\nincx        [int]\nspecifies the increment for the elements of the vector\n@param[out]\ny           pointer to vector on the device\n@param[in]\nincy        [int]\nspecifies the increment for the elements of the vector\n@param[in]\nstream      specifies the stream into which this transfer request is queued"]
    pub fn hipblasSetVectorAsync(
        n: ::core::ffi::c_int,
        elemSize: ::core::ffi::c_int,
        x: *const ::core::ffi::c_void,
        incx: ::core::ffi::c_int,
        y: *mut ::core::ffi::c_void,
        incy: ::core::ffi::c_int,
        stream: hipStream_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " \\brief asynchronously copy vector from device to host\n\\details\nhipblasGetVectorAsync copies a vector from pinned host memory to device memory asynchronously.\nMemory on the host must be allocated with hipHostMalloc or the transfer will be synchronous.\n@param[in]\nn           [int]\nnumber of elements in the vector\n@param[in]\nelemSize   [int]\nnumber of bytes per element in the matrix\n@param[in]\nx           pointer to vector on the device\n@param[in]\nincx        [int]\nspecifies the increment for the elements of the vector\n@param[out]\ny           pointer to vector on the host\n@param[in]\nincy        [int]\nspecifies the increment for the elements of the vector\n@param[in]\nstream      specifies the stream into which this transfer request is queued"]
    pub fn hipblasGetVectorAsync(
        n: ::core::ffi::c_int,
        elemSize: ::core::ffi::c_int,
        x: *const ::core::ffi::c_void,
        incx: ::core::ffi::c_int,
        y: *mut ::core::ffi::c_void,
        incy: ::core::ffi::c_int,
        stream: hipStream_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " \\brief asynchronously copy matrix from host to device\n\\details\nhipblasSetMatrixAsync copies a matrix from pinned host memory to device memory asynchronously.\nMemory on the host must be allocated with hipHostMalloc or the transfer will be synchronous.\n@param[in]\nrows        [int]\nnumber of rows in matrices\n@param[in]\ncols        [int]\nnumber of columns in matrices\n@param[in]\nelemSize   [int]\nnumber of bytes per element in the matrix\n@param[in]\nAP           pointer to matrix on the host\n@param[in]\nlda         [int]\nspecifies the leading dimension of A, lda >= rows\n@param[out]\nBP           pointer to matrix on the GPU\n@param[in]\nldb         [int]\nspecifies the leading dimension of B, ldb >= rows\n@param[in]\nstream      specifies the stream into which this transfer request is queued"]
    pub fn hipblasSetMatrixAsync(
        rows: ::core::ffi::c_int,
        cols: ::core::ffi::c_int,
        elemSize: ::core::ffi::c_int,
        AP: *const ::core::ffi::c_void,
        lda: ::core::ffi::c_int,
        BP: *mut ::core::ffi::c_void,
        ldb: ::core::ffi::c_int,
        stream: hipStream_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " \\brief asynchronously copy matrix from device to host\n\\details\nhipblasGetMatrixAsync copies a matrix from device memory to pinned host memory asynchronously.\nMemory on the host must be allocated with hipHostMalloc or the transfer will be synchronous.\n@param[in]\nrows        [int]\nnumber of rows in matrices\n@param[in]\ncols        [int]\nnumber of columns in matrices\n@param[in]\nelemSize   [int]\nnumber of bytes per element in the matrix\n@param[in]\nAP          pointer to matrix on the GPU\n@param[in]\nlda         [int]\nspecifies the leading dimension of A, lda >= rows\n@param[out]\nBP           pointer to matrix on the host\n@param[in]\nldb         [int]\nspecifies the leading dimension of B, ldb >= rows\n@param[in]\nstream      specifies the stream into which this transfer request is queued"]
    pub fn hipblasGetMatrixAsync(
        rows: ::core::ffi::c_int,
        cols: ::core::ffi::c_int,
        elemSize: ::core::ffi::c_int,
        AP: *const ::core::ffi::c_void,
        lda: ::core::ffi::c_int,
        BP: *mut ::core::ffi::c_void,
        ldb: ::core::ffi::c_int,
        stream: hipStream_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " \\brief Set hipblasSetAtomicsMode"]
    pub fn hipblasSetAtomicsMode(
        handle: hipblasHandle_t,
        atomics_mode: hipblasAtomicsMode_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " \\brief Get hipblasSetAtomicsMode"]
    pub fn hipblasGetAtomicsMode(
        handle: hipblasHandle_t,
        atomics_mode: *mut hipblasAtomicsMode_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 1 API\n\n\\details\namax finds the first index of the element of maximum magnitude of a vector x.\n\n- Supported precisions in rocBLAS : s,d,c,z.\n- Supported precisions in cuBLAS  : s,d,c,z.\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nn         [int]\nthe number of elements in x.\n@param[in]\nx         device pointer storing vector x.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of y.\n@param[inout]\nresult\ndevice pointer or host pointer to store the amax index.\nreturn is 0.0 if n, incx<=0."]
    pub fn hipblasIsamax(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const f32,
        incx: ::core::ffi::c_int,
        result: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIdamax(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const f64,
        incx: ::core::ffi::c_int,
        result: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIcamax(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipblasComplex,
        incx: ::core::ffi::c_int,
        result: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIzamax(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        result: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIcamax_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipComplex,
        incx: ::core::ffi::c_int,
        result: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIzamax_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        result: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 1 API\n\n\\details\namaxBatched finds the first index of the element of maximum magnitude of each vector x_i in a batch, for i = 1, ..., batchCount.\n\n- Supported precisions in rocBLAS : s,d,c,z.\n- Supported precisions in cuBLAS  : No support.\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nn         [int]\nnumber of elements in each vector x_i\n@param[in]\nx         device array of device pointers storing each vector x_i.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of each x_i. incx must be > 0.\n@param[in]\nbatchCount [int]\nnumber of instances in the batch, must be > 0.\n@param[out]\nresult\ndevice or host array of pointers of batchCount size for results.\nreturn is 0 if n, incx<=0."]
    pub fn hipblasIsamaxBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *const f32,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
        result: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIdamaxBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *const f64,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
        result: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIcamaxBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *const hipblasComplex,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
        result: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIzamaxBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
        result: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIcamaxBatched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *const hipComplex,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
        result: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIzamaxBatched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
        result: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 1 API\n\n\\details\namaxStridedBatched finds the first index of the element of maximum magnitude of each vector x_i in a batch, for i = 1, ..., batchCount.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nn         [int]\nnumber of elements in each vector x_i\n@param[in]\nx         device pointer to the first vector x_1.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of each x_i. incx must be > 0.\n@param[in]\nstridex   [hipblasStride]\nspecifies the pointer increment between one x_i and the next x_(i + 1).\n@param[in]\nbatchCount [int]\nnumber of instances in the batch\n@param[out]\nresult\ndevice or host pointer for storing contiguous batchCount results.\nreturn is 0 if n <= 0, incx<=0.\n"]
    pub fn hipblasIsamaxStridedBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const f32,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
        result: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIdamaxStridedBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const f64,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
        result: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIcamaxStridedBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipblasComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
        result: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIzamaxStridedBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
        result: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIcamaxStridedBatched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
        result: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIzamaxStridedBatched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
        result: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 1 API\n\n\\details\namin finds the first index of the element of minimum magnitude of a vector x.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : s,d,c,z\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nn         [int]\nthe number of elements in x.\n@param[in]\nx         device pointer storing vector x.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of y.\n@param[inout]\nresult\ndevice pointer or host pointer to store the amin index.\nreturn is 0.0 if n, incx<=0."]
    pub fn hipblasIsamin(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const f32,
        incx: ::core::ffi::c_int,
        result: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIdamin(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const f64,
        incx: ::core::ffi::c_int,
        result: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIcamin(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipblasComplex,
        incx: ::core::ffi::c_int,
        result: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIzamin(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        result: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIcamin_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipComplex,
        incx: ::core::ffi::c_int,
        result: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIzamin_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        result: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 1 API\n\n\\details\naminBatched finds the first index of the element of minimum magnitude of each vector x_i in a batch, for i = 1, ..., batchCount.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nn         [int]\nnumber of elements in each vector x_i\n@param[in]\nx         device array of device pointers storing each vector x_i.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of each x_i. incx must be > 0.\n@param[in]\nbatchCount [int]\nnumber of instances in the batch, must be > 0.\n@param[out]\nresult\ndevice or host pointers to array of batchCount size for results.\nreturn is 0 if n, incx<=0."]
    pub fn hipblasIsaminBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *const f32,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
        result: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIdaminBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *const f64,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
        result: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIcaminBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *const hipblasComplex,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
        result: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIzaminBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
        result: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIcaminBatched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *const hipComplex,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
        result: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIzaminBatched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
        result: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 1 API\n\n\\details\naminStridedBatched finds the first index of the element of minimum magnitude of each vector x_i in a batch, for i = 1, ..., batchCount.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nn         [int]\nnumber of elements in each vector x_i\n@param[in]\nx         device pointer to the first vector x_1.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of each x_i. incx must be > 0.\n@param[in]\nstridex   [hipblasStride]\nspecifies the pointer increment between one x_i and the next x_(i + 1)\n@param[in]\nbatchCount [int]\nnumber of instances in the batch\n@param[out]\nresult\ndevice or host pointer to array for storing contiguous batchCount results.\nreturn is 0 if n <= 0, incx<=0.\n"]
    pub fn hipblasIsaminStridedBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const f32,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
        result: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIdaminStridedBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const f64,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
        result: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIcaminStridedBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipblasComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
        result: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIzaminStridedBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
        result: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIcaminStridedBatched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
        result: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasIzaminStridedBatched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
        result: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 1 API\n\n\\details\nasum computes the sum of the magnitudes of elements of a real vector x,\nor the sum of magnitudes of the real and imaginary parts of elements if x is a complex vector.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : s,d,c,z\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nn         [int]\nthe number of elements in x and y.\n@param[in]\nx         device pointer storing vector x.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of x. incx must be > 0.\n@param[inout]\nresult\ndevice pointer or host pointer to store the asum product.\nreturn is 0.0 if n <= 0.\n"]
    pub fn hipblasSasum(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const f32,
        incx: ::core::ffi::c_int,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDasum(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const f64,
        incx: ::core::ffi::c_int,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasScasum(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipblasComplex,
        incx: ::core::ffi::c_int,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDzasum(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasScasum_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipComplex,
        incx: ::core::ffi::c_int,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDzasum_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 1 API\n\n\\details\nasumBatched computes the sum of the magnitudes of the elements in a batch of real vectors x_i,\nor the sum of magnitudes of the real and imaginary parts of elements if x_i is a complex\nvector, for i = 1, ..., batchCount.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nn         [int]\nnumber of elements in each vector x_i\n@param[in]\nx         device array of device pointers storing each vector x_i.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of each x_i. incx must be > 0.\n@param[in]\nbatchCount [int]\nnumber of instances in the batch.\n@param[out]\nresult\ndevice array or host array of batchCount size for results.\nreturn is 0.0 if n, incx<=0."]
    pub fn hipblasSasumBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *const f32,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDasumBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *const f64,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasScasumBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *const hipblasComplex,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDzasumBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasScasumBatched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *const hipComplex,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDzasumBatched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 1 API\n\n\\details\nasumStridedBatched computes the sum of the magnitudes of elements of a real vectors x_i,\nor the sum of magnitudes of the real and imaginary parts of elements if x_i is a complex\nvector, for i = 1, ..., batchCount.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nn         [int]\nnumber of elements in each vector x_i\n@param[in]\nx         device pointer to the first vector x_1.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of each x_i. incx must be > 0.\n@param[in]\nstridex   [hipblasStride]\nstride from the start of one vector (x_i) and the next one (x_i+1).\nThere are no restrictions placed on stride_x, however the user should\ntake care to ensure that stride_x is of appropriate size, for a typical\ncase this means stride_x >= n * incx.\n@param[in]\nbatchCount [int]\nnumber of instances in the batch\n@param[out]\nresult\ndevice pointer or host pointer to array for storing contiguous batchCount results.\nreturn is 0.0 if n, incx<=0."]
    pub fn hipblasSasumStridedBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const f32,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDasumStridedBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const f64,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasScasumStridedBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipblasComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDzasumStridedBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasScasumStridedBatched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDzasumStridedBatched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 1 API\n\n\\details\naxpy   computes constant alpha multiplied by vector x, plus vector y\n\ny := alpha * x + y\n\n- Supported precisions in rocBLAS : h,s,d,c,z\n- Supported precisions in cuBLAS  : s,d,c,z\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nn         [int]\nthe number of elements in x and y.\n@param[in]\nalpha     device pointer or host pointer to specify the scalar alpha.\n@param[in]\nx         device pointer storing vector x.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of x.\n@param[out]\ny         device pointer storing vector y.\n@param[inout]\nincy      [int]\nspecifies the increment for the elements of y.\n"]
    pub fn hipblasHaxpy(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasHalf,
        x: *const hipblasHalf,
        incx: ::core::ffi::c_int,
        y: *mut hipblasHalf,
        incy: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSaxpy(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        x: *const f32,
        incx: ::core::ffi::c_int,
        y: *mut f32,
        incy: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDaxpy(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        x: *const f64,
        incx: ::core::ffi::c_int,
        y: *mut f64,
        incy: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCaxpy(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        x: *const hipblasComplex,
        incx: ::core::ffi::c_int,
        y: *mut hipblasComplex,
        incy: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZaxpy(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        y: *mut hipblasDoubleComplex,
        incy: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCaxpy_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const hipComplex,
        x: *const hipComplex,
        incx: ::core::ffi::c_int,
        y: *mut hipComplex,
        incy: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZaxpy_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        x: *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        y: *mut hipDoubleComplex,
        incy: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 1 API\n\n\\details\naxpyBatched   compute y := alpha * x + y over a set of batched vectors.\n\n- Supported precisions in rocBLAS : h,s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nn         [int]\nthe number of elements in x and y.\n@param[in]\nalpha     specifies the scalar alpha.\n@param[in]\nx         pointer storing vector x on the GPU.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of x.\n@param[out]\ny         pointer storing vector y on the GPU.\n@param[inout]\nincy      [int]\nspecifies the increment for the elements of y.\n\n@param[in]\nbatchCount [int]\nnumber of instances in the batch"]
    pub fn hipblasHaxpyBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasHalf,
        x: *const *const hipblasHalf,
        incx: ::core::ffi::c_int,
        y: *const *mut hipblasHalf,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSaxpyBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        x: *const *const f32,
        incx: ::core::ffi::c_int,
        y: *const *mut f32,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDaxpyBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        x: *const *const f64,
        incx: ::core::ffi::c_int,
        y: *const *mut f64,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCaxpyBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        x: *const *const hipblasComplex,
        incx: ::core::ffi::c_int,
        y: *const *mut hipblasComplex,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZaxpyBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        y: *const *mut hipblasDoubleComplex,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCaxpyBatched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const hipComplex,
        x: *const *const hipComplex,
        incx: ::core::ffi::c_int,
        y: *const *mut hipComplex,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZaxpyBatched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        x: *const *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        y: *const *mut hipDoubleComplex,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 1 API\n\n\\details\naxpyStridedBatched   compute y := alpha * x + y over a set of strided batched vectors.\n\n- Supported precisions in rocBLAS : h,s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nn         [int]\n@param[in]\nalpha     specifies the scalar alpha.\n@param[in]\nx         pointer storing vector x on the GPU.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of x.\n@param[in]\nstridex   [hipblasStride]\nspecifies the increment between vectors of x.\n@param[out]\ny         pointer storing vector y on the GPU.\n@param[inout]\nincy      [int]\nspecifies the increment for the elements of y.\n@param[in]\nstridey   [hipblasStride]\nspecifies the increment between vectors of y.\n\n@param[in]\nbatchCount [int]\nnumber of instances in the batch\n"]
    pub fn hipblasHaxpyStridedBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasHalf,
        x: *const hipblasHalf,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *mut hipblasHalf,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSaxpyStridedBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        x: *const f32,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *mut f32,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDaxpyStridedBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        x: *const f64,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *mut f64,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCaxpyStridedBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        x: *const hipblasComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *mut hipblasComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZaxpyStridedBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *mut hipblasDoubleComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCaxpyStridedBatched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const hipComplex,
        x: *const hipComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *mut hipComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZaxpyStridedBatched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        x: *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *mut hipDoubleComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 1 API\n\n\\details\ncopy  copies each element x[i] into y[i], for  i = 1 , ... , n\n\ny := x,\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : s,d,c,z\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nn         [int]\nthe number of elements in x to be copied to y.\n@param[in]\nx         device pointer storing vector x.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of x.\n@param[out]\ny         device pointer storing vector y.\n@param[in]\nincy      [int]\nspecifies the increment for the elements of y.\n"]
    pub fn hipblasScopy(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const f32,
        incx: ::core::ffi::c_int,
        y: *mut f32,
        incy: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDcopy(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const f64,
        incx: ::core::ffi::c_int,
        y: *mut f64,
        incy: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCcopy(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipblasComplex,
        incx: ::core::ffi::c_int,
        y: *mut hipblasComplex,
        incy: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZcopy(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        y: *mut hipblasDoubleComplex,
        incy: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCcopy_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipComplex,
        incx: ::core::ffi::c_int,
        y: *mut hipComplex,
        incy: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZcopy_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        y: *mut hipDoubleComplex,
        incy: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 1 API\n\n\\details\ncopyBatched copies each element x_i[j] into y_i[j], for  j = 1 , ... , n; i = 1 , ... , batchCount\n\ny_i := x_i,\n\nwhere (x_i, y_i) is the i-th instance of the batch.\nx_i and y_i are vectors.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nn         [int]\nthe number of elements in each x_i to be copied to y_i.\n@param[in]\nx         device array of device pointers storing each vector x_i.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of each vector x_i.\n@param[out]\ny         device array of device pointers storing each vector y_i.\n@param[in]\nincy      [int]\nspecifies the increment for the elements of each vector y_i.\n@param[in]\nbatchCount [int]\nnumber of instances in the batch\n"]
    pub fn hipblasScopyBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *const f32,
        incx: ::core::ffi::c_int,
        y: *const *mut f32,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDcopyBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *const f64,
        incx: ::core::ffi::c_int,
        y: *const *mut f64,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCcopyBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *const hipblasComplex,
        incx: ::core::ffi::c_int,
        y: *const *mut hipblasComplex,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZcopyBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        y: *const *mut hipblasDoubleComplex,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCcopyBatched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *const hipComplex,
        incx: ::core::ffi::c_int,
        y: *const *mut hipComplex,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZcopyBatched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        y: *const *mut hipDoubleComplex,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 1 API\n\n\\details\ncopyStridedBatched copies each element x_i[j] into y_i[j], for  j = 1 , ... , n; i = 1 , ... , batchCount\n\ny_i := x_i,\n\nwhere (x_i, y_i) is the i-th instance of the batch.\nx_i and y_i are vectors.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nn         [int]\nthe number of elements in each x_i to be copied to y_i.\n@param[in]\nx         device pointer to the first vector (x_1) in the batch.\n@param[in]\nincx      [int]\nspecifies the increments for the elements of vectors x_i.\n@param[in]\nstridex     [hipblasStride]\nstride from the start of one vector (x_i) and the next one (x_i+1).\nThere are no restrictions placed on stride_x, however the user should\ntake care to ensure that stride_x is of appropriate size, for a typical\ncase this means stride_x >= n * incx.\n@param[out]\ny         device pointer to the first vector (y_1) in the batch.\n@param[in]\nincy      [int]\nspecifies the increment for the elements of vectors y_i.\n@param[in]\nstridey     [hipblasStride]\nstride from the start of one vector (y_i) and the next one (y_i+1).\nThere are no restrictions placed on stride_y, however the user should\ntake care to ensure that stride_y is of appropriate size, for a typical\ncase this means stride_y >= n * incy. stridey should be non zero.\n@param[in]\nbatchCount [int]\nnumber of instances in the batch\n"]
    pub fn hipblasScopyStridedBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const f32,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *mut f32,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDcopyStridedBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const f64,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *mut f64,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCcopyStridedBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipblasComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *mut hipblasComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZcopyStridedBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *mut hipblasDoubleComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCcopyStridedBatched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *mut hipComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZcopyStridedBatched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *mut hipDoubleComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 1 API\n\n\\details\ndot(u)  performs the dot product of vectors x and y\n\nresult = x * y;\n\ndotc  performs the dot product of the conjugate of complex vector x and complex vector y\n\nresult = conjugate (x) * y;\n\n- Supported precisions in rocBLAS : h,bf,s,d,c,z\n- Supported precisions in cuBLAS  : s,d,c,z\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nn         [int]\nthe number of elements in x and y.\n@param[in]\nx         device pointer storing vector x.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of y.\n@param[in]\ny         device pointer storing vector y.\n@param[in]\nincy      [int]\nspecifies the increment for the elements of y.\n@param[inout]\nresult\ndevice pointer or host pointer to store the dot product.\nreturn is 0.0 if n <= 0.\n"]
    pub fn hipblasHdot(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipblasHalf,
        incx: ::core::ffi::c_int,
        y: *const hipblasHalf,
        incy: ::core::ffi::c_int,
        result: *mut hipblasHalf,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasBfdot(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipblasBfloat16,
        incx: ::core::ffi::c_int,
        y: *const hipblasBfloat16,
        incy: ::core::ffi::c_int,
        result: *mut hipblasBfloat16,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSdot(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const f32,
        incx: ::core::ffi::c_int,
        y: *const f32,
        incy: ::core::ffi::c_int,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDdot(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const f64,
        incx: ::core::ffi::c_int,
        y: *const f64,
        incy: ::core::ffi::c_int,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCdotc(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipblasComplex,
        incx: ::core::ffi::c_int,
        y: *const hipblasComplex,
        incy: ::core::ffi::c_int,
        result: *mut hipblasComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCdotu(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipblasComplex,
        incx: ::core::ffi::c_int,
        y: *const hipblasComplex,
        incy: ::core::ffi::c_int,
        result: *mut hipblasComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdotc(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        y: *const hipblasDoubleComplex,
        incy: ::core::ffi::c_int,
        result: *mut hipblasDoubleComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdotu(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        y: *const hipblasDoubleComplex,
        incy: ::core::ffi::c_int,
        result: *mut hipblasDoubleComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCdotc_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipComplex,
        incx: ::core::ffi::c_int,
        y: *const hipComplex,
        incy: ::core::ffi::c_int,
        result: *mut hipComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCdotu_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipComplex,
        incx: ::core::ffi::c_int,
        y: *const hipComplex,
        incy: ::core::ffi::c_int,
        result: *mut hipComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdotc_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        y: *const hipDoubleComplex,
        incy: ::core::ffi::c_int,
        result: *mut hipDoubleComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdotu_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        y: *const hipDoubleComplex,
        incy: ::core::ffi::c_int,
        result: *mut hipDoubleComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 1 API\n\n\\details\ndotBatched(u) performs a batch of dot products of vectors x and y\n\nresult_i = x_i * y_i;\n\ndotcBatched  performs a batch of dot products of the conjugate of complex vector x and complex vector y\n\nresult_i = conjugate (x_i) * y_i;\n\nwhere (x_i, y_i) is the i-th instance of the batch.\nx_i and y_i are vectors, for i = 1, ..., batchCount\n\n- Supported precisions in rocBLAS : h,bf,s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nn         [int]\nthe number of elements in each x_i and y_i.\n@param[in]\nx         device array of device pointers storing each vector x_i.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of each x_i.\n@param[in]\ny         device array of device pointers storing each vector y_i.\n@param[in]\nincy      [int]\nspecifies the increment for the elements of each y_i.\n@param[in]\nbatchCount [int]\nnumber of instances in the batch\n@param[inout]\nresult\ndevice array or host array of batchCount size to store the dot products of each batch.\nreturn 0.0 for each element if n <= 0.\n"]
    pub fn hipblasHdotBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *const hipblasHalf,
        incx: ::core::ffi::c_int,
        y: *const *const hipblasHalf,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
        result: *mut hipblasHalf,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasBfdotBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *const hipblasBfloat16,
        incx: ::core::ffi::c_int,
        y: *const *const hipblasBfloat16,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
        result: *mut hipblasBfloat16,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSdotBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *const f32,
        incx: ::core::ffi::c_int,
        y: *const *const f32,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDdotBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *const f64,
        incx: ::core::ffi::c_int,
        y: *const *const f64,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCdotcBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *const hipblasComplex,
        incx: ::core::ffi::c_int,
        y: *const *const hipblasComplex,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
        result: *mut hipblasComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCdotuBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *const hipblasComplex,
        incx: ::core::ffi::c_int,
        y: *const *const hipblasComplex,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
        result: *mut hipblasComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdotcBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        y: *const *const hipblasDoubleComplex,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
        result: *mut hipblasDoubleComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdotuBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        y: *const *const hipblasDoubleComplex,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
        result: *mut hipblasDoubleComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCdotcBatched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *const hipComplex,
        incx: ::core::ffi::c_int,
        y: *const *const hipComplex,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
        result: *mut hipComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCdotuBatched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *const hipComplex,
        incx: ::core::ffi::c_int,
        y: *const *const hipComplex,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
        result: *mut hipComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdotcBatched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        y: *const *const hipDoubleComplex,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
        result: *mut hipDoubleComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdotuBatched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        y: *const *const hipDoubleComplex,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
        result: *mut hipDoubleComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 1 API\n\n\\details\ndotStridedBatched(u)  performs a batch of dot products of vectors x and y\n\nresult_i = x_i * y_i;\n\ndotcStridedBatched  performs a batch of dot products of the conjugate of complex vector x and complex vector y\n\nresult_i = conjugate (x_i) * y_i;\n\nwhere (x_i, y_i) is the i-th instance of the batch.\nx_i and y_i are vectors, for i = 1, ..., batchCount\n\n- Supported precisions in rocBLAS : h,bf,s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nn         [int]\nthe number of elements in each x_i and y_i.\n@param[in]\nx         device pointer to the first vector (x_1) in the batch.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of each x_i.\n@param[in]\nstridex     [hipblasStride]\nstride from the start of one vector (x_i) and the next one (x_i+1)\n@param[in]\ny         device pointer to the first vector (y_1) in the batch.\n@param[in]\nincy      [int]\nspecifies the increment for the elements of each y_i.\n@param[in]\nstridey     [hipblasStride]\nstride from the start of one vector (y_i) and the next one (y_i+1)\n@param[in]\nbatchCount [int]\nnumber of instances in the batch\n@param[inout]\nresult\ndevice array or host array of batchCount size to store the dot products of each batch.\nreturn 0.0 for each element if n <= 0.\n"]
    pub fn hipblasHdotStridedBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipblasHalf,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *const hipblasHalf,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
        result: *mut hipblasHalf,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasBfdotStridedBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipblasBfloat16,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *const hipblasBfloat16,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
        result: *mut hipblasBfloat16,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSdotStridedBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const f32,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *const f32,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDdotStridedBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const f64,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *const f64,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCdotcStridedBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipblasComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *const hipblasComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
        result: *mut hipblasComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCdotuStridedBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipblasComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *const hipblasComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
        result: *mut hipblasComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdotcStridedBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *const hipblasDoubleComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
        result: *mut hipblasDoubleComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdotuStridedBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *const hipblasDoubleComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
        result: *mut hipblasDoubleComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCdotcStridedBatched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *const hipComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
        result: *mut hipComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCdotuStridedBatched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *const hipComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
        result: *mut hipComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdotcStridedBatched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *const hipDoubleComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
        result: *mut hipDoubleComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdotuStridedBatched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *const hipDoubleComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
        result: *mut hipDoubleComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 1 API\n\n\\details\nnrm2 computes the euclidean norm of a real or complex vector\n\nresult := sqrt( x'*x ) for real vectors\nresult := sqrt( x**H*x ) for complex vectors\n\n- Supported precisions in rocBLAS : s,d,c,z,sc,dz\n- Supported precisions in cuBLAS  : s,d,sc,dz\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nn         [int]\nthe number of elements in x.\n@param[in]\nx         device pointer storing vector x.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of y.\n@param[inout]\nresult\ndevice pointer or host pointer to store the nrm2 product.\nreturn is 0.0 if n, incx<=0."]
    pub fn hipblasSnrm2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const f32,
        incx: ::core::ffi::c_int,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDnrm2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const f64,
        incx: ::core::ffi::c_int,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasScnrm2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipblasComplex,
        incx: ::core::ffi::c_int,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDznrm2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasScnrm2_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipComplex,
        incx: ::core::ffi::c_int,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDznrm2_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 1 API\n\n\\details\nnrm2Batched computes the euclidean norm over a batch of real or complex vectors\n\nresult := sqrt( x_i'*x_i ) for real vectors x, for i = 1, ..., batchCount\nresult := sqrt( x_i**H*x_i ) for complex vectors x, for i = 1, ..., batchCount\n\n- Supported precisions in rocBLAS : s,d,c,z,sc,dz\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nn         [int]\nnumber of elements in each x_i.\n@param[in]\nx         device array of device pointers storing each vector x_i.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of each x_i. incx must be > 0.\n@param[in]\nbatchCount [int]\nnumber of instances in the batch\n@param[out]\nresult\ndevice pointer or host pointer to array of batchCount size for nrm2 results.\nreturn is 0.0 for each element if n <= 0, incx<=0.\n"]
    pub fn hipblasSnrm2Batched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *const f32,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDnrm2Batched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *const f64,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasScnrm2Batched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *const hipblasComplex,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDznrm2Batched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasScnrm2Batched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *const hipComplex,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDznrm2Batched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 1 API\n\n\\details\nnrm2StridedBatched computes the euclidean norm over a batch of real or complex vectors\n\n:= sqrt( x_i'*x_i ) for real vectors x, for i = 1, ..., batchCount\n:= sqrt( x_i**H*x_i ) for complex vectors, for i = 1, ..., batchCount\n\n- Supported precisions in rocBLAS : s,d,c,z,sc,dz\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nn         [int]\nnumber of elements in each x_i.\n@param[in]\nx         device pointer to the first vector x_1.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of each x_i. incx must be > 0.\n@param[in]\nstridex   [hipblasStride]\nstride from the start of one vector (x_i) and the next one (x_i+1).\nThere are no restrictions placed on stride_x, however the user should\ntake care to ensure that stride_x is of appropriate size, for a typical\ncase this means stride_x >= n * incx.\n@param[in]\nbatchCount [int]\nnumber of instances in the batch\n@param[out]\nresult\ndevice pointer or host pointer to array for storing contiguous batchCount results.\nreturn is 0.0 for each element if n <= 0, incx<=0.\n"]
    pub fn hipblasSnrm2StridedBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const f32,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDnrm2StridedBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const f64,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasScnrm2StridedBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipblasComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDznrm2StridedBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasScnrm2StridedBatched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
        result: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDznrm2StridedBatched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
        result: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 1 API\n\n\\details\nrot applies the Givens rotation matrix defined by c=cos(alpha) and s=sin(alpha) to vectors x and y.\nScalars c and s may be stored in either host or device memory, location is specified by calling hipblasSetPointerMode.\n\n- Supported precisions in rocBLAS : s,d,c,z,sc,dz\n- Supported precisions in cuBLAS  : s,d,c,z,cs,zd\n\n@param[in]\nhandle  [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nn       [int]\nnumber of elements in the x and y vectors.\n@param[inout]\nx       device pointer storing vector x.\n@param[in]\nincx    [int]\nspecifies the increment between elements of x.\n@param[inout]\ny       device pointer storing vector y.\n@param[in]\nincy    [int]\nspecifies the increment between elements of y.\n@param[in]\nc       device pointer or host pointer storing scalar cosine component of the rotation matrix.\n@param[in]\ns       device pointer or host pointer storing scalar sine component of the rotation matrix.\n"]
    pub fn hipblasSrot(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *mut f32,
        incx: ::core::ffi::c_int,
        y: *mut f32,
        incy: ::core::ffi::c_int,
        c: *const f32,
        s: *const f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDrot(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *mut f64,
        incx: ::core::ffi::c_int,
        y: *mut f64,
        incy: ::core::ffi::c_int,
        c: *const f64,
        s: *const f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCrot(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *mut hipblasComplex,
        incx: ::core::ffi::c_int,
        y: *mut hipblasComplex,
        incy: ::core::ffi::c_int,
        c: *const f32,
        s: *const hipblasComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsrot(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *mut hipblasComplex,
        incx: ::core::ffi::c_int,
        y: *mut hipblasComplex,
        incy: ::core::ffi::c_int,
        c: *const f32,
        s: *const f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZrot(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *mut hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        y: *mut hipblasDoubleComplex,
        incy: ::core::ffi::c_int,
        c: *const f64,
        s: *const hipblasDoubleComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdrot(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *mut hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        y: *mut hipblasDoubleComplex,
        incy: ::core::ffi::c_int,
        c: *const f64,
        s: *const f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCrot_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *mut hipComplex,
        incx: ::core::ffi::c_int,
        y: *mut hipComplex,
        incy: ::core::ffi::c_int,
        c: *const f32,
        s: *const hipComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsrot_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *mut hipComplex,
        incx: ::core::ffi::c_int,
        y: *mut hipComplex,
        incy: ::core::ffi::c_int,
        c: *const f32,
        s: *const f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZrot_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *mut hipDoubleComplex,
        incx: ::core::ffi::c_int,
        y: *mut hipDoubleComplex,
        incy: ::core::ffi::c_int,
        c: *const f64,
        s: *const hipDoubleComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdrot_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *mut hipDoubleComplex,
        incx: ::core::ffi::c_int,
        y: *mut hipDoubleComplex,
        incy: ::core::ffi::c_int,
        c: *const f64,
        s: *const f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 1 API\n\n\\details\nrotBatched applies the Givens rotation matrix defined by c=cos(alpha) and s=sin(alpha) to batched vectors x_i and y_i, for i = 1, ..., batchCount.\nScalars c and s may be stored in either host or device memory, location is specified by calling hipblasSetPointerMode.\n\n- Supported precisions in rocBLAS : s,d,sc,dz\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle  [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nn       [int]\nnumber of elements in each x_i and y_i vectors.\n@param[inout]\nx       device array of device pointers storing each vector x_i.\n@param[in]\nincx    [int]\nspecifies the increment between elements of each x_i.\n@param[inout]\ny       device array of device pointers storing each vector y_i.\n@param[in]\nincy    [int]\nspecifies the increment between elements of each y_i.\n@param[in]\nc       device pointer or host pointer to scalar cosine component of the rotation matrix.\n@param[in]\ns       device pointer or host pointer to scalar sine component of the rotation matrix.\n@param[in]\nbatchCount [int]\nthe number of x and y arrays, i.e. the number of batches.\n"]
    pub fn hipblasSrotBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *mut f32,
        incx: ::core::ffi::c_int,
        y: *const *mut f32,
        incy: ::core::ffi::c_int,
        c: *const f32,
        s: *const f32,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDrotBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *mut f64,
        incx: ::core::ffi::c_int,
        y: *const *mut f64,
        incy: ::core::ffi::c_int,
        c: *const f64,
        s: *const f64,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCrotBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *mut hipblasComplex,
        incx: ::core::ffi::c_int,
        y: *const *mut hipblasComplex,
        incy: ::core::ffi::c_int,
        c: *const f32,
        s: *const hipblasComplex,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsrotBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *mut hipblasComplex,
        incx: ::core::ffi::c_int,
        y: *const *mut hipblasComplex,
        incy: ::core::ffi::c_int,
        c: *const f32,
        s: *const f32,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZrotBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *mut hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        y: *const *mut hipblasDoubleComplex,
        incy: ::core::ffi::c_int,
        c: *const f64,
        s: *const hipblasDoubleComplex,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdrotBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *mut hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        y: *const *mut hipblasDoubleComplex,
        incy: ::core::ffi::c_int,
        c: *const f64,
        s: *const f64,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCrotBatched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *mut hipComplex,
        incx: ::core::ffi::c_int,
        y: *const *mut hipComplex,
        incy: ::core::ffi::c_int,
        c: *const f32,
        s: *const hipComplex,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsrotBatched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *mut hipComplex,
        incx: ::core::ffi::c_int,
        y: *const *mut hipComplex,
        incy: ::core::ffi::c_int,
        c: *const f32,
        s: *const f32,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZrotBatched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *mut hipDoubleComplex,
        incx: ::core::ffi::c_int,
        y: *const *mut hipDoubleComplex,
        incy: ::core::ffi::c_int,
        c: *const f64,
        s: *const hipDoubleComplex,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdrotBatched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *mut hipDoubleComplex,
        incx: ::core::ffi::c_int,
        y: *const *mut hipDoubleComplex,
        incy: ::core::ffi::c_int,
        c: *const f64,
        s: *const f64,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 1 API\n\n\\details\nrotStridedBatched applies the Givens rotation matrix defined by c=cos(alpha) and s=sin(alpha) to strided batched vectors x_i and y_i, for i = 1, ..., batchCount.\nScalars c and s may be stored in either host or device memory, location is specified by calling hipblasSetPointerMode.\n\n- Supported precisions in rocBLAS : s,d,sc,dz\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle  [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nn       [int]\nnumber of elements in each x_i and y_i vectors.\n@param[inout]\nx       device pointer to the first vector x_1.\n@param[in]\nincx    [int]\nspecifies the increment between elements of each x_i.\n@param[in]\nstridex [hipblasStride]\nspecifies the increment from the beginning of x_i to the beginning of x_(i+1)\n@param[inout]\ny       device pointer to the first vector y_1.\n@param[in]\nincy    [int]\nspecifies the increment between elements of each y_i.\n@param[in]\nstridey  [hipblasStride]\nspecifies the increment from the beginning of y_i to the beginning of y_(i+1)\n@param[in]\nc       device pointer or host pointer to scalar cosine component of the rotation matrix.\n@param[in]\ns       device pointer or host pointer to scalar sine component of the rotation matrix.\n@param[in]\nbatchCount [int]\nthe number of x and y arrays, i.e. the number of batches.\n"]
    pub fn hipblasSrotStridedBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *mut f32,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *mut f32,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        c: *const f32,
        s: *const f32,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDrotStridedBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *mut f64,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *mut f64,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        c: *const f64,
        s: *const f64,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCrotStridedBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *mut hipblasComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *mut hipblasComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        c: *const f32,
        s: *const hipblasComplex,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsrotStridedBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *mut hipblasComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *mut hipblasComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        c: *const f32,
        s: *const f32,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZrotStridedBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *mut hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *mut hipblasDoubleComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        c: *const f64,
        s: *const hipblasDoubleComplex,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdrotStridedBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *mut hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *mut hipblasDoubleComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        c: *const f64,
        s: *const f64,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCrotStridedBatched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *mut hipComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *mut hipComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        c: *const f32,
        s: *const hipComplex,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsrotStridedBatched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *mut hipComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *mut hipComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        c: *const f32,
        s: *const f32,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZrotStridedBatched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *mut hipDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *mut hipDoubleComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        c: *const f64,
        s: *const hipDoubleComplex,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdrotStridedBatched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *mut hipDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *mut hipDoubleComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        c: *const f64,
        s: *const f64,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 1 API\n\n\\details\nrotg creates the Givens rotation matrix for the vector (a b).\nScalars c and s and arrays a and b may be stored in either host or device memory, location is specified by calling hipblasSetPointerMode.\nIf the pointer mode is set to HIPBLAS_POINTER_MODE_HOST, this function blocks the CPU until the GPU has finished and the results are available in host memory.\nIf the pointer mode is set to HIPBLAS_POINTER_MODE_DEVICE, this function returns immediately and synchronization is required to read the results.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : s,d,c,z\n\n@param[in]\nhandle  [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[inout]\na       device pointer or host pointer to input vector element, overwritten with r.\n@param[inout]\nb       device pointer or host pointer to input vector element, overwritten with z.\n@param[inout]\nc       device pointer or host pointer to cosine element of Givens rotation.\n@param[inout]\ns       device pointer or host pointer sine element of Givens rotation.\n"]
    pub fn hipblasSrotg(
        handle: hipblasHandle_t,
        a: *mut f32,
        b: *mut f32,
        c: *mut f32,
        s: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDrotg(
        handle: hipblasHandle_t,
        a: *mut f64,
        b: *mut f64,
        c: *mut f64,
        s: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCrotg(
        handle: hipblasHandle_t,
        a: *mut hipblasComplex,
        b: *mut hipblasComplex,
        c: *mut f32,
        s: *mut hipblasComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZrotg(
        handle: hipblasHandle_t,
        a: *mut hipblasDoubleComplex,
        b: *mut hipblasDoubleComplex,
        c: *mut f64,
        s: *mut hipblasDoubleComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCrotg_v2(
        handle: hipblasHandle_t,
        a: *mut hipComplex,
        b: *mut hipComplex,
        c: *mut f32,
        s: *mut hipComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZrotg_v2(
        handle: hipblasHandle_t,
        a: *mut hipDoubleComplex,
        b: *mut hipDoubleComplex,
        c: *mut f64,
        s: *mut hipDoubleComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 1 API\n\n\\details\nrotgBatched creates the Givens rotation matrix for the batched vectors (a_i b_i), for i = 1, ..., batchCount.\na, b, c, and s may be stored in either host or device memory, location is specified by calling hipblasSetPointerMode.\nIf the pointer mode is set to HIPBLAS_POINTER_MODE_HOST, this function blocks the CPU until the GPU has finished and the results are available in host memory.\nIf the pointer mode is set to HIPBLAS_POINTER_MODE_DEVICE, this function returns immediately and synchronization is required to read the results.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle  [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[inout]\na       device array of device pointers storing each single input vector element a_i, overwritten with r_i.\n@param[inout]\nb       device array of device pointers storing each single input vector element b_i, overwritten with z_i.\n@param[inout]\nc       device array of device pointers storing each cosine element of Givens rotation for the batch.\n@param[inout]\ns       device array of device pointers storing each sine element of Givens rotation for the batch.\n@param[in]\nbatchCount [int]\nnumber of batches (length of arrays a, b, c, and s).\n"]
    pub fn hipblasSrotgBatched(
        handle: hipblasHandle_t,
        a: *const *mut f32,
        b: *const *mut f32,
        c: *const *mut f32,
        s: *const *mut f32,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDrotgBatched(
        handle: hipblasHandle_t,
        a: *const *mut f64,
        b: *const *mut f64,
        c: *const *mut f64,
        s: *const *mut f64,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCrotgBatched(
        handle: hipblasHandle_t,
        a: *const *mut hipblasComplex,
        b: *const *mut hipblasComplex,
        c: *const *mut f32,
        s: *const *mut hipblasComplex,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZrotgBatched(
        handle: hipblasHandle_t,
        a: *const *mut hipblasDoubleComplex,
        b: *const *mut hipblasDoubleComplex,
        c: *const *mut f64,
        s: *const *mut hipblasDoubleComplex,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCrotgBatched_v2(
        handle: hipblasHandle_t,
        a: *const *mut hipComplex,
        b: *const *mut hipComplex,
        c: *const *mut f32,
        s: *const *mut hipComplex,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZrotgBatched_v2(
        handle: hipblasHandle_t,
        a: *const *mut hipDoubleComplex,
        b: *const *mut hipDoubleComplex,
        c: *const *mut f64,
        s: *const *mut hipDoubleComplex,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 1 API\n\n\\details\nrotgStridedBatched creates the Givens rotation matrix for the strided batched vectors (a_i b_i), for i = 1, ..., batchCount.\na, b, c, and s may be stored in either host or device memory, location is specified by calling hipblasSetPointerMode.\nIf the pointer mode is set to HIPBLAS_POINTER_MODE_HOST, this function blocks the CPU until the GPU has finished and the results are available in host memory.\nIf the pointer mode is set to HIPBLAS_POINTER_MODE_HOST, this function returns immediately and synchronization is required to read the results.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle  [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[inout]\na       device strided_batched pointer or host strided_batched pointer to first single input vector element a_1, overwritten with r.\n@param[in]\nstridea [hipblasStride]\ndistance between elements of a in batch (distance between a_i and a_(i + 1))\n@param[inout]\nb       device strided_batched pointer or host strided_batched pointer to first single input vector element b_1, overwritten with z.\n@param[in]\nstrideb [hipblasStride]\ndistance between elements of b in batch (distance between b_i and b_(i + 1))\n@param[inout]\nc       device strided_batched pointer or host strided_batched pointer to first cosine element of Givens rotations c_1.\n@param[in]\nstridec [hipblasStride]\ndistance between elements of c in batch (distance between c_i and c_(i + 1))\n@param[inout]\ns       device strided_batched pointer or host strided_batched pointer to sine element of Givens rotations s_1.\n@param[in]\nstrides [hipblasStride]\ndistance between elements of s in batch (distance between s_i and s_(i + 1))\n@param[in]\nbatchCount [int]\nnumber of batches (length of arrays a, b, c, and s).\n"]
    pub fn hipblasSrotgStridedBatched(
        handle: hipblasHandle_t,
        a: *mut f32,
        stridea: hipblasStride,
        b: *mut f32,
        strideb: hipblasStride,
        c: *mut f32,
        stridec: hipblasStride,
        s: *mut f32,
        strides: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDrotgStridedBatched(
        handle: hipblasHandle_t,
        a: *mut f64,
        stridea: hipblasStride,
        b: *mut f64,
        strideb: hipblasStride,
        c: *mut f64,
        stridec: hipblasStride,
        s: *mut f64,
        strides: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCrotgStridedBatched(
        handle: hipblasHandle_t,
        a: *mut hipblasComplex,
        stridea: hipblasStride,
        b: *mut hipblasComplex,
        strideb: hipblasStride,
        c: *mut f32,
        stridec: hipblasStride,
        s: *mut hipblasComplex,
        strides: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZrotgStridedBatched(
        handle: hipblasHandle_t,
        a: *mut hipblasDoubleComplex,
        stridea: hipblasStride,
        b: *mut hipblasDoubleComplex,
        strideb: hipblasStride,
        c: *mut f64,
        stridec: hipblasStride,
        s: *mut hipblasDoubleComplex,
        strides: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCrotgStridedBatched_v2(
        handle: hipblasHandle_t,
        a: *mut hipComplex,
        stridea: hipblasStride,
        b: *mut hipComplex,
        strideb: hipblasStride,
        c: *mut f32,
        stridec: hipblasStride,
        s: *mut hipComplex,
        strides: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZrotgStridedBatched_v2(
        handle: hipblasHandle_t,
        a: *mut hipDoubleComplex,
        stridea: hipblasStride,
        b: *mut hipDoubleComplex,
        strideb: hipblasStride,
        c: *mut f64,
        stridec: hipblasStride,
        s: *mut hipDoubleComplex,
        strides: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 1 API\n\n\\details\nrotm applies the modified Givens rotation matrix defined by param to vectors x and y.\n\n- Supported precisions in rocBLAS : s,d\n- Supported precisions in cuBLAS  : s,d\n\n@param[in]\nhandle  [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nn       [int]\nnumber of elements in the x and y vectors.\n@param[inout]\nx       device pointer storing vector x.\n@param[in]\nincx    [int]\nspecifies the increment between elements of x.\n@param[inout]\ny       device pointer storing vector y.\n@param[in]\nincy    [int]\nspecifies the increment between elements of y.\n@param[in]\nparam   device vector or host vector of 5 elements defining the rotation.\nparam[0] = flag\nparam[1] = H11\nparam[2] = H21\nparam[3] = H12\nparam[4] = H22\nThe flag parameter defines the form of H:\nflag = -1 => H = ( H11 H12 H21 H22 )\nflag =  0 => H = ( 1.0 H12 H21 1.0 )\nflag =  1 => H = ( H11 1.0 -1.0 H22 )\nflag = -2 => H = ( 1.0 0.0 0.0 1.0 )\nparam may be stored in either host or device memory, location is specified by calling hipblasSetPointerMode.\n"]
    pub fn hipblasSrotm(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *mut f32,
        incx: ::core::ffi::c_int,
        y: *mut f32,
        incy: ::core::ffi::c_int,
        param: *const f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDrotm(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *mut f64,
        incx: ::core::ffi::c_int,
        y: *mut f64,
        incy: ::core::ffi::c_int,
        param: *const f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 1 API\n\n\\details\nrotmBatched applies the modified Givens rotation matrix defined by param_i to batched vectors x_i and y_i, for i = 1, ..., batchCount.\n\n- Supported precisions in rocBLAS : s,d\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle  [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nn       [int]\nnumber of elements in the x and y vectors.\n@param[inout]\nx       device array of device pointers storing each vector x_i.\n@param[in]\nincx    [int]\nspecifies the increment between elements of each x_i.\n@param[inout]\ny       device array of device pointers storing each vector y_1.\n@param[in]\nincy    [int]\nspecifies the increment between elements of each y_i.\n@param[in]\nparam   device array of device vectors of 5 elements defining the rotation.\nparam[0] = flag\nparam[1] = H11\nparam[2] = H21\nparam[3] = H12\nparam[4] = H22\nThe flag parameter defines the form of H:\nflag = -1 => H = ( H11 H12 H21 H22 )\nflag =  0 => H = ( 1.0 H12 H21 1.0 )\nflag =  1 => H = ( H11 1.0 -1.0 H22 )\nflag = -2 => H = ( 1.0 0.0 0.0 1.0 )\nparam may ONLY be stored on the device for the batched version of this function.\n@param[in]\nbatchCount [int]\nthe number of x and y arrays, i.e. the number of batches.\n"]
    pub fn hipblasSrotmBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *mut f32,
        incx: ::core::ffi::c_int,
        y: *const *mut f32,
        incy: ::core::ffi::c_int,
        param: *const *const f32,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDrotmBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *mut f64,
        incx: ::core::ffi::c_int,
        y: *const *mut f64,
        incy: ::core::ffi::c_int,
        param: *const *const f64,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 1 API\n\n\\details\nrotmStridedBatched applies the modified Givens rotation matrix defined by param_i to strided batched vectors x_i and y_i, for i = 1, ..., batchCount\n\n- Supported precisions in rocBLAS : s,d\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle  [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nn       [int]\nnumber of elements in the x and y vectors.\n@param[inout]\nx       device pointer pointing to first strided batched vector x_1.\n@param[in]\nincx    [int]\nspecifies the increment between elements of each x_i.\n@param[in]\nstridex [hipblasStride]\nspecifies the increment between the beginning of x_i and x_(i + 1)\n@param[inout]\ny       device pointer pointing to first strided batched vector y_1.\n@param[in]\nincy    [int]\nspecifies the increment between elements of each y_i.\n@param[in]\nstridey  [hipblasStride]\nspecifies the increment between the beginning of y_i and y_(i + 1)\n@param[in]\nparam   device pointer pointing to first array of 5 elements defining the rotation (param_1).\nparam[0] = flag\nparam[1] = H11\nparam[2] = H21\nparam[3] = H12\nparam[4] = H22\nThe flag parameter defines the form of H:\nflag = -1 => H = ( H11 H12 H21 H22 )\nflag =  0 => H = ( 1.0 H12 H21 1.0 )\nflag =  1 => H = ( H11 1.0 -1.0 H22 )\nflag = -2 => H = ( 1.0 0.0 0.0 1.0 )\nparam may ONLY be stored on the device for the strided_batched version of this function.\n@param[in]\nstrideParam [hipblasStride]\nspecifies the increment between the beginning of param_i and param_(i + 1)\n@param[in]\nbatchCount [int]\nthe number of x and y arrays, i.e. the number of batches.\n"]
    pub fn hipblasSrotmStridedBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *mut f32,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *mut f32,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        param: *const f32,
        strideParam: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDrotmStridedBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *mut f64,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *mut f64,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        param: *const f64,
        strideParam: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 1 API\n\n\\details\nrotmg creates the modified Givens rotation matrix for the vector (d1 * x1, d2 * y1).\nParameters may be stored in either host or device memory, location is specified by calling hipblasSetPointerMode.\nIf the pointer mode is set to HIPBLAS_POINTER_MODE_HOST, this function blocks the CPU until the GPU has finished and the results are available in host memory.\nIf the pointer mode is set to HIPBLAS_POINTER_MODE_DEVICE, this function returns immediately and synchronization is required to read the results.\n\n- Supported precisions in rocBLAS : s,d\n- Supported precisions in cuBLAS  : s,d\n\n@param[in]\nhandle  [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[inout]\nd1      device pointer or host pointer to input scalar that is overwritten.\n@param[inout]\nd2      device pointer or host pointer to input scalar that is overwritten.\n@param[inout]\nx1      device pointer or host pointer to input scalar that is overwritten.\n@param[in]\ny1      device pointer or host pointer to input scalar.\n@param[out]\nparam   device vector or host vector of 5 elements defining the rotation.\nparam[0] = flag\nparam[1] = H11\nparam[2] = H21\nparam[3] = H12\nparam[4] = H22\nThe flag parameter defines the form of H:\nflag = -1 => H = ( H11 H12 H21 H22 )\nflag =  0 => H = ( 1.0 H12 H21 1.0 )\nflag =  1 => H = ( H11 1.0 -1.0 H22 )\nflag = -2 => H = ( 1.0 0.0 0.0 1.0 )\nparam may be stored in either host or device memory, location is specified by calling hipblasSetPointerMode.\n"]
    pub fn hipblasSrotmg(
        handle: hipblasHandle_t,
        d1: *mut f32,
        d2: *mut f32,
        x1: *mut f32,
        y1: *const f32,
        param: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDrotmg(
        handle: hipblasHandle_t,
        d1: *mut f64,
        d2: *mut f64,
        x1: *mut f64,
        y1: *const f64,
        param: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 1 API\n\n\\details\nrotmgBatched creates the modified Givens rotation matrix for the batched vectors (d1_i * x1_i, d2_i * y1_i), for i = 1, ..., batchCount.\nParameters may be stored in either host or device memory, location is specified by calling hipblasSetPointerMode.\nIf the pointer mode is set to HIPBLAS_POINTER_MODE_HOST, this function blocks the CPU until the GPU has finished and the results are available in host memory.\nIf the pointer mode is set to HIPBLAS_POINTER_MODE_DEVICE, this function returns immediately and synchronization is required to read the results.\n\n- Supported precisions in rocBLAS : s,d\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle  [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[inout]\nd1      device batched array or host batched array of input scalars that is overwritten.\n@param[inout]\nd2      device batched array or host batched array of input scalars that is overwritten.\n@param[inout]\nx1      device batched array or host batched array of input scalars that is overwritten.\n@param[in]\ny1      device batched array or host batched array of input scalars.\n@param[out]\nparam   device batched array or host batched array of vectors of 5 elements defining the rotation.\nparam[0] = flag\nparam[1] = H11\nparam[2] = H21\nparam[3] = H12\nparam[4] = H22\nThe flag parameter defines the form of H:\nflag = -1 => H = ( H11 H12 H21 H22 )\nflag =  0 => H = ( 1.0 H12 H21 1.0 )\nflag =  1 => H = ( H11 1.0 -1.0 H22 )\nflag = -2 => H = ( 1.0 0.0 0.0 1.0 )\nparam may be stored in either host or device memory, location is specified by calling hipblasSetPointerMode.\n@param[in]\nbatchCount [int]\nthe number of instances in the batch.\n"]
    pub fn hipblasSrotmgBatched(
        handle: hipblasHandle_t,
        d1: *const *mut f32,
        d2: *const *mut f32,
        x1: *const *mut f32,
        y1: *const *const f32,
        param: *const *mut f32,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDrotmgBatched(
        handle: hipblasHandle_t,
        d1: *const *mut f64,
        d2: *const *mut f64,
        x1: *const *mut f64,
        y1: *const *const f64,
        param: *const *mut f64,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 1 API\n\n\\details\nrotmgStridedBatched creates the modified Givens rotation matrix for the strided batched vectors (d1_i * x1_i, d2_i * y1_i), for i = 1, ..., batchCount.\nParameters may be stored in either host or device memory, location is specified by calling hipblasSetPointerMode.\nIf the pointer mode is set to HIPBLAS_POINTER_MODE_HOST, this function blocks the CPU until the GPU has finished and the results are available in host memory.\nIf the pointer mode is set to HIPBLAS_POINTER_MODE_DEVICE, this function returns immediately and synchronization is required to read the results.\n\n- Supported precisions in rocBLAS : s,d\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle  [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[inout]\nd1      device strided_batched array or host strided_batched array of input scalars that is overwritten.\n@param[in]\nstrided1 [hipblasStride]\nspecifies the increment between the beginning of d1_i and d1_(i+1)\n@param[inout]\nd2      device strided_batched array or host strided_batched array of input scalars that is overwritten.\n@param[in]\nstrided2 [hipblasStride]\nspecifies the increment between the beginning of d2_i and d2_(i+1)\n@param[inout]\nx1      device strided_batched array or host strided_batched array of input scalars that is overwritten.\n@param[in]\nstridex1 [hipblasStride]\nspecifies the increment between the beginning of x1_i and x1_(i+1)\n@param[in]\ny1      device strided_batched array or host strided_batched array of input scalars.\n@param[in]\nstridey1 [hipblasStride]\nspecifies the increment between the beginning of y1_i and y1_(i+1)\n@param[out]\nparam   device stridedBatched array or host stridedBatched array of vectors of 5 elements defining the rotation.\nparam[0] = flag\nparam[1] = H11\nparam[2] = H21\nparam[3] = H12\nparam[4] = H22\nThe flag parameter defines the form of H:\nflag = -1 => H = ( H11 H12 H21 H22 )\nflag =  0 => H = ( 1.0 H12 H21 1.0 )\nflag =  1 => H = ( H11 1.0 -1.0 H22 )\nflag = -2 => H = ( 1.0 0.0 0.0 1.0 )\nparam may be stored in either host or device memory, location is specified by calling hipblasSetPointerMode.\n@param[in]\nstrideParam [hipblasStride]\nspecifies the increment between the beginning of param_i and param_(i + 1)\n@param[in]\nbatchCount [int]\nthe number of instances in the batch.\n"]
    pub fn hipblasSrotmgStridedBatched(
        handle: hipblasHandle_t,
        d1: *mut f32,
        strided1: hipblasStride,
        d2: *mut f32,
        strided2: hipblasStride,
        x1: *mut f32,
        stridex1: hipblasStride,
        y1: *const f32,
        stridey1: hipblasStride,
        param: *mut f32,
        strideParam: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDrotmgStridedBatched(
        handle: hipblasHandle_t,
        d1: *mut f64,
        strided1: hipblasStride,
        d2: *mut f64,
        strided2: hipblasStride,
        x1: *mut f64,
        stridex1: hipblasStride,
        y1: *const f64,
        stridey1: hipblasStride,
        param: *mut f64,
        strideParam: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 1 API\n\n\\details\nscal  scales each element of vector x with scalar alpha.\n\nx := alpha * x\n\n- Supported precisions in rocBLAS : s,d,c,z,cs,zd\n- Supported precisions in cuBLAS  : s,d,c,z,cs,zd\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nn         [int]\nthe number of elements in x.\n@param[in]\nalpha     device pointer or host pointer for the scalar alpha.\n@param[inout]\nx         device pointer storing vector x.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of x.\n\n"]
    pub fn hipblasSscal(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        x: *mut f32,
        incx: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDscal(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        x: *mut f64,
        incx: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCscal(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        x: *mut hipblasComplex,
        incx: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsscal(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        x: *mut hipblasComplex,
        incx: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZscal(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *mut hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdscal(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        x: *mut hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCscal_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const hipComplex,
        x: *mut hipComplex,
        incx: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsscal_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        x: *mut hipComplex,
        incx: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZscal_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        x: *mut hipDoubleComplex,
        incx: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdscal_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        x: *mut hipDoubleComplex,
        incx: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 1 API\n\\details\nscalBatched  scales each element of vector x_i with scalar alpha, for i = 1, ... , batchCount.\n\nx_i := alpha * x_i\n\nwhere (x_i) is the i-th instance of the batch.\n\n- Supported precisions in rocBLAS : s,d,c,z,cs,zd\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle      [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nn           [int]\nthe number of elements in each x_i.\n@param[in]\nalpha       host pointer or device pointer for the scalar alpha.\n@param[inout]\nx           device array of device pointers storing each vector x_i.\n@param[in]\nincx        [int]\nspecifies the increment for the elements of each x_i.\n@param[in]\nbatchCount [int]\nspecifies the number of batches in x."]
    pub fn hipblasSscalBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        x: *const *mut f32,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDscalBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        x: *const *mut f64,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCscalBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        x: *const *mut hipblasComplex,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZscalBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const *mut hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsscalBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        x: *const *mut hipblasComplex,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdscalBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        x: *const *mut hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCscalBatched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const hipComplex,
        x: *const *mut hipComplex,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZscalBatched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        x: *const *mut hipDoubleComplex,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsscalBatched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        x: *const *mut hipComplex,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdscalBatched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        x: *const *mut hipDoubleComplex,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 1 API\n\\details\nscalStridedBatched  scales each element of vector x_i with scalar alpha, for i = 1, ... , batchCount.\n\nx_i := alpha * x_i ,\n\nwhere (x_i) is the i-th instance of the batch.\n\n- Supported precisions in rocBLAS : s,d,c,z,cs,zd\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle      [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nn           [int]\nthe number of elements in each x_i.\n@param[in]\nalpha       host pointer or device pointer for the scalar alpha.\n@param[inout]\nx           device pointer to the first vector (x_1) in the batch.\n@param[in]\nincx        [int]\nspecifies the increment for the elements of x.\n@param[in]\nstridex     [hipblasStride]\nstride from the start of one vector (x_i) and the next one (x_i+1).\nThere are no restrictions placed on stride_x, however the user should\ntake care to ensure that stride_x is of appropriate size, for a typical\ncase this means stride_x >= n * incx.\n@param[in]\nbatchCount [int]\nspecifies the number of batches in x."]
    pub fn hipblasSscalStridedBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        x: *mut f32,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDscalStridedBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        x: *mut f64,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCscalStridedBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        x: *mut hipblasComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZscalStridedBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *mut hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsscalStridedBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        x: *mut hipblasComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdscalStridedBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        x: *mut hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCscalStridedBatched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const hipComplex,
        x: *mut hipComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZscalStridedBatched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        x: *mut hipDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsscalStridedBatched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        x: *mut hipComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdscalStridedBatched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        x: *mut hipDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 1 API\n\n\\details\nswap  interchanges vectors x and y.\n\ny := x; x := y\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : s,d,c,z\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nn         [int]\nthe number of elements in x and y.\n@param[inout]\nx         device pointer storing vector x.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of x.\n@param[inout]\ny         device pointer storing vector y.\n@param[in]\nincy      [int]\nspecifies the increment for the elements of y.\n"]
    pub fn hipblasSswap(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *mut f32,
        incx: ::core::ffi::c_int,
        y: *mut f32,
        incy: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDswap(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *mut f64,
        incx: ::core::ffi::c_int,
        y: *mut f64,
        incy: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCswap(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *mut hipblasComplex,
        incx: ::core::ffi::c_int,
        y: *mut hipblasComplex,
        incy: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZswap(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *mut hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        y: *mut hipblasDoubleComplex,
        incy: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCswap_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *mut hipComplex,
        incx: ::core::ffi::c_int,
        y: *mut hipComplex,
        incy: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZswap_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *mut hipDoubleComplex,
        incx: ::core::ffi::c_int,
        y: *mut hipDoubleComplex,
        incy: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 1 API\n\n\\details\nswapBatched interchanges vectors x_i and y_i, for i = 1 , ... , batchCount\n\ny_i := x_i; x_i := y_i\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nn         [int]\nthe number of elements in each x_i and y_i.\n@param[inout]\nx         device array of device pointers storing each vector x_i.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of each x_i.\n@param[inout]\ny         device array of device pointers storing each vector y_i.\n@param[in]\nincy      [int]\nspecifies the increment for the elements of each y_i.\n@param[in]\nbatchCount [int]\nnumber of instances in the batch.\n"]
    pub fn hipblasSswapBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *mut f32,
        incx: ::core::ffi::c_int,
        y: *const *mut f32,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDswapBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *mut f64,
        incx: ::core::ffi::c_int,
        y: *const *mut f64,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCswapBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *mut hipblasComplex,
        incx: ::core::ffi::c_int,
        y: *const *mut hipblasComplex,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZswapBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *mut hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        y: *const *mut hipblasDoubleComplex,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCswapBatched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *mut hipComplex,
        incx: ::core::ffi::c_int,
        y: *const *mut hipComplex,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZswapBatched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const *mut hipDoubleComplex,
        incx: ::core::ffi::c_int,
        y: *const *mut hipDoubleComplex,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 1 API\n\n\\details\nswapStridedBatched interchanges vectors x_i and y_i, for i = 1 , ... , batchCount\n\ny_i := x_i; x_i := y_i\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nn         [int]\nthe number of elements in each x_i and y_i.\n@param[inout]\nx         device pointer to the first vector x_1.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of x.\n@param[in]\nstridex   [hipblasStride]\nstride from the start of one vector (x_i) and the next one (x_i+1).\nThere are no restrictions placed on stride_x, however the user should\ntake care to ensure that stride_x is of appropriate size, for a typical\ncase this means stride_x >= n * incx.\n@param[inout]\ny         device pointer to the first vector y_1.\n@param[in]\nincy      [int]\nspecifies the increment for the elements of y.\n@param[in]\nstridey   [hipblasStride]\nstride from the start of one vector (y_i) and the next one (y_i+1).\nThere are no restrictions placed on stride_x, however the user should\ntake care to ensure that stride_y is of appropriate size, for a typical\ncase this means stride_y >= n * incy. stridey should be non zero.\n@param[in]\nbatchCount [int]\nnumber of instances in the batch.\n"]
    pub fn hipblasSswapStridedBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *mut f32,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *mut f32,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDswapStridedBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *mut f64,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *mut f64,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCswapStridedBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *mut hipblasComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *mut hipblasComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZswapStridedBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *mut hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *mut hipblasDoubleComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCswapStridedBatched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *mut hipComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *mut hipComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZswapStridedBatched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *mut hipDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *mut hipDoubleComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\ngbmv performs one of the matrix-vector operations\n\ny := alpha*A*x    + beta*y,   or\ny := alpha*A**T*x + beta*y,   or\ny := alpha*A**H*x + beta*y,\n\nwhere alpha and beta are scalars, x and y are vectors and A is an\nm by n banded matrix with kl sub-diagonals and ku super-diagonals.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : s,d,c,z\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\ntrans     [hipblasOperation_t]\nindicates whether matrix A is tranposed (conjugated) or not\n@param[in]\nm         [int]\nnumber of rows of matrix A\n@param[in]\nn         [int]\nnumber of columns of matrix A\n@param[in]\nkl        [int]\nnumber of sub-diagonals of A\n@param[in]\nku        [int]\nnumber of super-diagonals of A\n@param[in]\nalpha     device pointer or host pointer to scalar alpha.\n@param[in]\nAP    device pointer storing banded matrix A.\nLeading (kl + ku + 1) by n part of the matrix contains the coefficients\nof the banded matrix. The leading diagonal resides in row (ku + 1) with\nthe first super-diagonal above on the RHS of row ku. The first sub-diagonal\nresides below on the LHS of row ku + 2. This propagates up and down across\nsub/super-diagonals.\nEx: (m = n = 7; ku = 2, kl = 2)\n1 2 3 0 0 0 0             0 0 3 3 3 3 3\n4 1 2 3 0 0 0             0 2 2 2 2 2 2\n5 4 1 2 3 0 0    ---->    1 1 1 1 1 1 1\n0 5 4 1 2 3 0             4 4 4 4 4 4 0\n0 0 5 4 1 2 0             5 5 5 5 5 0 0\n0 0 0 5 4 1 2             0 0 0 0 0 0 0\n0 0 0 0 5 4 1             0 0 0 0 0 0 0\nNote that the empty elements which don't correspond to data will not\nbe referenced.\n@param[in]\nlda       [int]\nspecifies the leading dimension of A. Must be >= (kl + ku + 1)\n@param[in]\nx         device pointer storing vector x.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of x.\n@param[in]\nbeta      device pointer or host pointer to scalar beta.\n@param[inout]\ny         device pointer storing vector y.\n@param[in]\nincy      [int]\nspecifies the increment for the elements of y.\n"]
    pub fn hipblasSgbmv(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        kl: ::core::ffi::c_int,
        ku: ::core::ffi::c_int,
        alpha: *const f32,
        AP: *const f32,
        lda: ::core::ffi::c_int,
        x: *const f32,
        incx: ::core::ffi::c_int,
        beta: *const f32,
        y: *mut f32,
        incy: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgbmv(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        kl: ::core::ffi::c_int,
        ku: ::core::ffi::c_int,
        alpha: *const f64,
        AP: *const f64,
        lda: ::core::ffi::c_int,
        x: *const f64,
        incx: ::core::ffi::c_int,
        beta: *const f64,
        y: *mut f64,
        incy: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgbmv(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        kl: ::core::ffi::c_int,
        ku: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: ::core::ffi::c_int,
        x: *const hipblasComplex,
        incx: ::core::ffi::c_int,
        beta: *const hipblasComplex,
        y: *mut hipblasComplex,
        incy: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgbmv(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        kl: ::core::ffi::c_int,
        ku: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        x: *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        beta: *const hipblasDoubleComplex,
        y: *mut hipblasDoubleComplex,
        incy: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgbmv_v2(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        kl: ::core::ffi::c_int,
        ku: ::core::ffi::c_int,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: ::core::ffi::c_int,
        x: *const hipComplex,
        incx: ::core::ffi::c_int,
        beta: *const hipComplex,
        y: *mut hipComplex,
        incy: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgbmv_v2(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        kl: ::core::ffi::c_int,
        ku: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        x: *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        beta: *const hipDoubleComplex,
        y: *mut hipDoubleComplex,
        incy: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\ngbmvBatched performs one of the matrix-vector operations\n\ny_i := alpha*A_i*x_i    + beta*y_i,   or\ny_i := alpha*A_i**T*x_i + beta*y_i,   or\ny_i := alpha*A_i**H*x_i + beta*y_i,\n\nwhere (A_i, x_i, y_i) is the i-th instance of the batch.\nalpha and beta are scalars, x_i and y_i are vectors and A_i is an\nm by n banded matrix with kl sub-diagonals and ku super-diagonals,\nfor i = 1, ..., batchCount.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\ntrans     [hipblasOperation_t]\nindicates whether matrix A is tranposed (conjugated) or not\n@param[in]\nm         [int]\nnumber of rows of each matrix A_i\n@param[in]\nn         [int]\nnumber of columns of each matrix A_i\n@param[in]\nkl        [int]\nnumber of sub-diagonals of each A_i\n@param[in]\nku        [int]\nnumber of super-diagonals of each A_i\n@param[in]\nalpha     device pointer or host pointer to scalar alpha.\n@param[in]\nAP    device array of device pointers storing each banded matrix A_i.\nLeading (kl + ku + 1) by n part of the matrix contains the coefficients\nof the banded matrix. The leading diagonal resides in row (ku + 1) with\nthe first super-diagonal above on the RHS of row ku. The first sub-diagonal\nresides below on the LHS of row ku + 2. This propagates up and down across\nsub/super-diagonals.\nEx: (m = n = 7; ku = 2, kl = 2)\n1 2 3 0 0 0 0             0 0 3 3 3 3 3\n4 1 2 3 0 0 0             0 2 2 2 2 2 2\n5 4 1 2 3 0 0    ---->    1 1 1 1 1 1 1\n0 5 4 1 2 3 0             4 4 4 4 4 4 0\n0 0 5 4 1 2 0             5 5 5 5 5 0 0\n0 0 0 5 4 1 2             0 0 0 0 0 0 0\n0 0 0 0 5 4 1             0 0 0 0 0 0 0\nNote that the empty elements which don't correspond to data will not\nbe referenced.\n@param[in]\nlda       [int]\nspecifies the leading dimension of each A_i. Must be >= (kl + ku + 1)\n@param[in]\nx         device array of device pointers storing each vector x_i.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of each x_i.\n@param[in]\nbeta      device pointer or host pointer to scalar beta.\n@param[inout]\ny         device array of device pointers storing each vector y_i.\n@param[in]\nincy      [int]\nspecifies the increment for the elements of each y_i.\n@param[in]\nbatchCount [int]\nspecifies the number of instances in the batch.\n"]
    pub fn hipblasSgbmvBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        kl: ::core::ffi::c_int,
        ku: ::core::ffi::c_int,
        alpha: *const f32,
        AP: *const *const f32,
        lda: ::core::ffi::c_int,
        x: *const *const f32,
        incx: ::core::ffi::c_int,
        beta: *const f32,
        y: *const *mut f32,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgbmvBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        kl: ::core::ffi::c_int,
        ku: ::core::ffi::c_int,
        alpha: *const f64,
        AP: *const *const f64,
        lda: ::core::ffi::c_int,
        x: *const *const f64,
        incx: ::core::ffi::c_int,
        beta: *const f64,
        y: *const *mut f64,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgbmvBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        kl: ::core::ffi::c_int,
        ku: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        AP: *const *const hipblasComplex,
        lda: ::core::ffi::c_int,
        x: *const *const hipblasComplex,
        incx: ::core::ffi::c_int,
        beta: *const hipblasComplex,
        y: *const *mut hipblasComplex,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgbmvBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        kl: ::core::ffi::c_int,
        ku: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        x: *const *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        beta: *const hipblasDoubleComplex,
        y: *const *mut hipblasDoubleComplex,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgbmvBatched_v2(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        kl: ::core::ffi::c_int,
        ku: ::core::ffi::c_int,
        alpha: *const hipComplex,
        AP: *const *const hipComplex,
        lda: ::core::ffi::c_int,
        x: *const *const hipComplex,
        incx: ::core::ffi::c_int,
        beta: *const hipComplex,
        y: *const *mut hipComplex,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgbmvBatched_v2(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        kl: ::core::ffi::c_int,
        ku: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        x: *const *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        beta: *const hipDoubleComplex,
        y: *const *mut hipDoubleComplex,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\ngbmvStridedBatched performs one of the matrix-vector operations\n\ny_i := alpha*A_i*x_i    + beta*y_i,   or\ny_i := alpha*A_i**T*x_i + beta*y_i,   or\ny_i := alpha*A_i**H*x_i + beta*y_i,\n\nwhere (A_i, x_i, y_i) is the i-th instance of the batch.\nalpha and beta are scalars, x_i and y_i are vectors and A_i is an\nm by n banded matrix with kl sub-diagonals and ku super-diagonals,\nfor i = 1, ..., batchCount.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\ntrans     [hipblasOperation_t]\nindicates whether matrix A is tranposed (conjugated) or not\n@param[in]\nm         [int]\nnumber of rows of matrix A\n@param[in]\nn         [int]\nnumber of columns of matrix A\n@param[in]\nkl        [int]\nnumber of sub-diagonals of A\n@param[in]\nku        [int]\nnumber of super-diagonals of A\n@param[in]\nalpha     device pointer or host pointer to scalar alpha.\n@param[in]\nAP    device pointer to first banded matrix (A_1).\nLeading (kl + ku + 1) by n part of the matrix contains the coefficients\nof the banded matrix. The leading diagonal resides in row (ku + 1) with\nthe first super-diagonal above on the RHS of row ku. The first sub-diagonal\nresides below on the LHS of row ku + 2. This propagates up and down across\nsub/super-diagonals.\nEx: (m = n = 7; ku = 2, kl = 2)\n1 2 3 0 0 0 0             0 0 3 3 3 3 3\n4 1 2 3 0 0 0             0 2 2 2 2 2 2\n5 4 1 2 3 0 0    ---->    1 1 1 1 1 1 1\n0 5 4 1 2 3 0             4 4 4 4 4 4 0\n0 0 5 4 1 2 0             5 5 5 5 5 0 0\n0 0 0 5 4 1 2             0 0 0 0 0 0 0\n0 0 0 0 5 4 1             0 0 0 0 0 0 0\nNote that the empty elements which don't correspond to data will not\nbe referenced.\n@param[in]\nlda       [int]\nspecifies the leading dimension of A. Must be >= (kl + ku + 1)\n@param[in]\nstrideA  [hipblasStride]\nstride from the start of one matrix (A_i) and the next one (A_i+1)\n@param[in]\nx         device pointer to first vector (x_1).\n@param[in]\nincx      [int]\nspecifies the increment for the elements of x.\n@param[in]\nstridex  [hipblasStride]\nstride from the start of one vector (x_i) and the next one (x_i+1)\n@param[in]\nbeta      device pointer or host pointer to scalar beta.\n@param[inout]\ny         device pointer to first vector (y_1).\n@param[in]\nincy      [int]\nspecifies the increment for the elements of y.\n@param[in]\nstridey  [hipblasStride]\nstride from the start of one vector (y_i) and the next one (x_i+1)\n@param[in]\nbatchCount [int]\nspecifies the number of instances in the batch.\n"]
    pub fn hipblasSgbmvStridedBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        kl: ::core::ffi::c_int,
        ku: ::core::ffi::c_int,
        alpha: *const f32,
        AP: *const f32,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *const f32,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        beta: *const f32,
        y: *mut f32,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgbmvStridedBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        kl: ::core::ffi::c_int,
        ku: ::core::ffi::c_int,
        alpha: *const f64,
        AP: *const f64,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *const f64,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        beta: *const f64,
        y: *mut f64,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgbmvStridedBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        kl: ::core::ffi::c_int,
        ku: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *const hipblasComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        beta: *const hipblasComplex,
        y: *mut hipblasComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgbmvStridedBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        kl: ::core::ffi::c_int,
        ku: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        beta: *const hipblasDoubleComplex,
        y: *mut hipblasDoubleComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgbmvStridedBatched_v2(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        kl: ::core::ffi::c_int,
        ku: ::core::ffi::c_int,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *const hipComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        beta: *const hipComplex,
        y: *mut hipComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgbmvStridedBatched_v2(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        kl: ::core::ffi::c_int,
        ku: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        beta: *const hipDoubleComplex,
        y: *mut hipDoubleComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\ngemv performs one of the matrix-vector operations\n\ny := alpha*A*x    + beta*y,   or\ny := alpha*A**T*x + beta*y,   or\ny := alpha*A**H*x + beta*y,\n\nwhere alpha and beta are scalars, x and y are vectors and A is an\nm by n matrix.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : s,d,c,z\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\ntrans     [hipblasOperation_t]\nindicates whether matrix A is tranposed (conjugated) or not\n@param[in]\nm         [int]\nnumber of rows of matrix A\n@param[in]\nn         [int]\nnumber of columns of matrix A\n@param[in]\nalpha     device pointer or host pointer to scalar alpha.\n@param[in]\nAP        device pointer storing matrix A.\n@param[in]\nlda       [int]\nspecifies the leading dimension of A.\n@param[in]\nx         device pointer storing vector x.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of x.\n@param[in]\nbeta      device pointer or host pointer to scalar beta.\n@param[inout]\ny         device pointer storing vector y.\n@param[in]\nincy      [int]\nspecifies the increment for the elements of y.\n"]
    pub fn hipblasSgemv(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        AP: *const f32,
        lda: ::core::ffi::c_int,
        x: *const f32,
        incx: ::core::ffi::c_int,
        beta: *const f32,
        y: *mut f32,
        incy: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgemv(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        AP: *const f64,
        lda: ::core::ffi::c_int,
        x: *const f64,
        incx: ::core::ffi::c_int,
        beta: *const f64,
        y: *mut f64,
        incy: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgemv(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: ::core::ffi::c_int,
        x: *const hipblasComplex,
        incx: ::core::ffi::c_int,
        beta: *const hipblasComplex,
        y: *mut hipblasComplex,
        incy: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgemv(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        x: *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        beta: *const hipblasDoubleComplex,
        y: *mut hipblasDoubleComplex,
        incy: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgemv_v2(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: ::core::ffi::c_int,
        x: *const hipComplex,
        incx: ::core::ffi::c_int,
        beta: *const hipComplex,
        y: *mut hipComplex,
        incy: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgemv_v2(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        x: *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        beta: *const hipDoubleComplex,
        y: *mut hipDoubleComplex,
        incy: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\ngemvBatched performs a batch of matrix-vector operations\n\ny_i := alpha*A_i*x_i    + beta*y_i,   or\ny_i := alpha*A_i**T*x_i + beta*y_i,   or\ny_i := alpha*A_i**H*x_i + beta*y_i,\n\nwhere (A_i, x_i, y_i) is the i-th instance of the batch.\nalpha and beta are scalars, x_i and y_i are vectors and A_i is an\nm by n matrix, for i = 1, ..., batchCount.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle      [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\ntrans       [hipblasOperation_t]\nindicates whether matrices A_i are tranposed (conjugated) or not\n@param[in]\nm           [int]\nnumber of rows of each matrix A_i\n@param[in]\nn           [int]\nnumber of columns of each matrix A_i\n@param[in]\nalpha       device pointer or host pointer to scalar alpha.\n@param[in]\nAP         device array of device pointers storing each matrix A_i.\n@param[in]\nlda         [int]\nspecifies the leading dimension of each matrix A_i.\n@param[in]\nx           device array of device pointers storing each vector x_i.\n@param[in]\nincx        [int]\nspecifies the increment for the elements of each vector x_i.\n@param[in]\nbeta        device pointer or host pointer to scalar beta.\n@param[inout]\ny           device array of device pointers storing each vector y_i.\n@param[in]\nincy        [int]\nspecifies the increment for the elements of each vector y_i.\n@param[in]\nbatchCount [int]\nnumber of instances in the batch\n"]
    pub fn hipblasSgemvBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        AP: *const *const f32,
        lda: ::core::ffi::c_int,
        x: *const *const f32,
        incx: ::core::ffi::c_int,
        beta: *const f32,
        y: *const *mut f32,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgemvBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        AP: *const *const f64,
        lda: ::core::ffi::c_int,
        x: *const *const f64,
        incx: ::core::ffi::c_int,
        beta: *const f64,
        y: *const *mut f64,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgemvBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        AP: *const *const hipblasComplex,
        lda: ::core::ffi::c_int,
        x: *const *const hipblasComplex,
        incx: ::core::ffi::c_int,
        beta: *const hipblasComplex,
        y: *const *mut hipblasComplex,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgemvBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        x: *const *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        beta: *const hipblasDoubleComplex,
        y: *const *mut hipblasDoubleComplex,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgemvBatched_v2(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipComplex,
        AP: *const *const hipComplex,
        lda: ::core::ffi::c_int,
        x: *const *const hipComplex,
        incx: ::core::ffi::c_int,
        beta: *const hipComplex,
        y: *const *mut hipComplex,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgemvBatched_v2(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        x: *const *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        beta: *const hipDoubleComplex,
        y: *const *mut hipDoubleComplex,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\ngemvStridedBatched performs a batch of matrix-vector operations\n\ny_i := alpha*A_i*x_i    + beta*y_i,   or\ny_i := alpha*A_i**T*x_i + beta*y_i,   or\ny_i := alpha*A_i**H*x_i + beta*y_i,\n\nwhere (A_i, x_i, y_i) is the i-th instance of the batch.\nalpha and beta are scalars, x_i and y_i are vectors and A_i is an\nm by n matrix, for i = 1, ..., batchCount.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle      [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\ntransA      [hipblasOperation_t]\nindicates whether matrices A_i are tranposed (conjugated) or not\n@param[in]\nm           [int]\nnumber of rows of matrices A_i\n@param[in]\nn           [int]\nnumber of columns of matrices A_i\n@param[in]\nalpha       device pointer or host pointer to scalar alpha.\n@param[in]\nAP          device pointer to the first matrix (A_1) in the batch.\n@param[in]\nlda         [int]\nspecifies the leading dimension of matrices A_i.\n@param[in]\nstrideA     [hipblasStride]\nstride from the start of one matrix (A_i) and the next one (A_i+1)\n@param[in]\nx           device pointer to the first vector (x_1) in the batch.\n@param[in]\nincx        [int]\nspecifies the increment for the elements of vectors x_i.\n@param[in]\nstridex     [hipblasStride]\nstride from the start of one vector (x_i) and the next one (x_i+1).\nThere are no restrictions placed on stridex, however the user should\ntake care to ensure that stridex is of appropriate size. When trans equals HIPBLAS_OP_N\nthis typically means stridex >= n * incx, otherwise stridex >= m * incx.\n@param[in]\nbeta        device pointer or host pointer to scalar beta.\n@param[inout]\ny           device pointer to the first vector (y_1) in the batch.\n@param[in]\nincy        [int]\nspecifies the increment for the elements of vectors y_i.\n@param[in]\nstridey     [hipblasStride]\nstride from the start of one vector (y_i) and the next one (y_i+1).\nThere are no restrictions placed on stridey, however the user should\ntake care to ensure that stridey is of appropriate size. When trans equals HIPBLAS_OP_N\nthis typically means stridey >= m * incy, otherwise stridey >= n * incy. stridey should be non zero.\n@param[in]\nbatchCount [int]\nnumber of instances in the batch\n"]
    pub fn hipblasSgemvStridedBatched(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        AP: *const f32,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *const f32,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        beta: *const f32,
        y: *mut f32,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgemvStridedBatched(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        AP: *const f64,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *const f64,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        beta: *const f64,
        y: *mut f64,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgemvStridedBatched(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *const hipblasComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        beta: *const hipblasComplex,
        y: *mut hipblasComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgemvStridedBatched(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        beta: *const hipblasDoubleComplex,
        y: *mut hipblasDoubleComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgemvStridedBatched_v2(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *const hipComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        beta: *const hipComplex,
        y: *mut hipComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgemvStridedBatched_v2(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        beta: *const hipDoubleComplex,
        y: *mut hipDoubleComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\nger,geru,gerc performs the matrix-vector operations\n\nA := A + alpha*x*y**T , OR\nA := A + alpha*x*y**H for gerc\n\nwhere alpha is a scalar, x and y are vectors, and A is an\nm by n matrix.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : s,d,c,z\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nm         [int]\nthe number of rows of the matrix A.\n@param[in]\nn         [int]\nthe number of columns of the matrix A.\n@param[in]\nalpha\ndevice pointer or host pointer to scalar alpha.\n@param[in]\nx         device pointer storing vector x.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of x.\n@param[in]\ny         device pointer storing vector y.\n@param[in]\nincy      [int]\nspecifies the increment for the elements of y.\n@param[inout]\nAP         device pointer storing matrix A.\n@param[in]\nlda       [int]\nspecifies the leading dimension of A.\n"]
    pub fn hipblasSger(
        handle: hipblasHandle_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        x: *const f32,
        incx: ::core::ffi::c_int,
        y: *const f32,
        incy: ::core::ffi::c_int,
        AP: *mut f32,
        lda: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDger(
        handle: hipblasHandle_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        x: *const f64,
        incx: ::core::ffi::c_int,
        y: *const f64,
        incy: ::core::ffi::c_int,
        AP: *mut f64,
        lda: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgeru(
        handle: hipblasHandle_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        x: *const hipblasComplex,
        incx: ::core::ffi::c_int,
        y: *const hipblasComplex,
        incy: ::core::ffi::c_int,
        AP: *mut hipblasComplex,
        lda: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgerc(
        handle: hipblasHandle_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        x: *const hipblasComplex,
        incx: ::core::ffi::c_int,
        y: *const hipblasComplex,
        incy: ::core::ffi::c_int,
        AP: *mut hipblasComplex,
        lda: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgeru(
        handle: hipblasHandle_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        y: *const hipblasDoubleComplex,
        incy: ::core::ffi::c_int,
        AP: *mut hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgerc(
        handle: hipblasHandle_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        y: *const hipblasDoubleComplex,
        incy: ::core::ffi::c_int,
        AP: *mut hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgeru_v2(
        handle: hipblasHandle_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipComplex,
        x: *const hipComplex,
        incx: ::core::ffi::c_int,
        y: *const hipComplex,
        incy: ::core::ffi::c_int,
        AP: *mut hipComplex,
        lda: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgerc_v2(
        handle: hipblasHandle_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipComplex,
        x: *const hipComplex,
        incx: ::core::ffi::c_int,
        y: *const hipComplex,
        incy: ::core::ffi::c_int,
        AP: *mut hipComplex,
        lda: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgeru_v2(
        handle: hipblasHandle_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        x: *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        y: *const hipDoubleComplex,
        incy: ::core::ffi::c_int,
        AP: *mut hipDoubleComplex,
        lda: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgerc_v2(
        handle: hipblasHandle_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        x: *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        y: *const hipDoubleComplex,
        incy: ::core::ffi::c_int,
        AP: *mut hipDoubleComplex,
        lda: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\ngerBatched,geruBatched,gercBatched performs a batch of the matrix-vector operations\n\nA := A + alpha*x*y**T , OR\nA := A + alpha*x*y**H for gerc\n\nwhere (A_i, x_i, y_i) is the i-th instance of the batch.\nalpha is a scalar, x_i and y_i are vectors and A_i is an\nm by n matrix, for i = 1, ..., batchCount.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nm         [int]\nthe number of rows of each matrix A_i.\n@param[in]\nn         [int]\nthe number of columns of eaceh matrix A_i.\n@param[in]\nalpha\ndevice pointer or host pointer to scalar alpha.\n@param[in]\nx         device array of device pointers storing each vector x_i.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of each vector x_i.\n@param[in]\ny         device array of device pointers storing each vector y_i.\n@param[in]\nincy      [int]\nspecifies the increment for the elements of each vector y_i.\n@param[inout]\nAP        device array of device pointers storing each matrix A_i.\n@param[in]\nlda       [int]\nspecifies the leading dimension of each A_i.\n@param[in]\nbatchCount [int]\nnumber of instances in the batch\n"]
    pub fn hipblasSgerBatched(
        handle: hipblasHandle_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        x: *const *const f32,
        incx: ::core::ffi::c_int,
        y: *const *const f32,
        incy: ::core::ffi::c_int,
        AP: *const *mut f32,
        lda: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgerBatched(
        handle: hipblasHandle_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        x: *const *const f64,
        incx: ::core::ffi::c_int,
        y: *const *const f64,
        incy: ::core::ffi::c_int,
        AP: *const *mut f64,
        lda: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgeruBatched(
        handle: hipblasHandle_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        x: *const *const hipblasComplex,
        incx: ::core::ffi::c_int,
        y: *const *const hipblasComplex,
        incy: ::core::ffi::c_int,
        AP: *const *mut hipblasComplex,
        lda: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgercBatched(
        handle: hipblasHandle_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        x: *const *const hipblasComplex,
        incx: ::core::ffi::c_int,
        y: *const *const hipblasComplex,
        incy: ::core::ffi::c_int,
        AP: *const *mut hipblasComplex,
        lda: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgeruBatched(
        handle: hipblasHandle_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        y: *const *const hipblasDoubleComplex,
        incy: ::core::ffi::c_int,
        AP: *const *mut hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgercBatched(
        handle: hipblasHandle_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        y: *const *const hipblasDoubleComplex,
        incy: ::core::ffi::c_int,
        AP: *const *mut hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgeruBatched_v2(
        handle: hipblasHandle_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipComplex,
        x: *const *const hipComplex,
        incx: ::core::ffi::c_int,
        y: *const *const hipComplex,
        incy: ::core::ffi::c_int,
        AP: *const *mut hipComplex,
        lda: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgercBatched_v2(
        handle: hipblasHandle_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipComplex,
        x: *const *const hipComplex,
        incx: ::core::ffi::c_int,
        y: *const *const hipComplex,
        incy: ::core::ffi::c_int,
        AP: *const *mut hipComplex,
        lda: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgeruBatched_v2(
        handle: hipblasHandle_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        x: *const *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        y: *const *const hipDoubleComplex,
        incy: ::core::ffi::c_int,
        AP: *const *mut hipDoubleComplex,
        lda: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgercBatched_v2(
        handle: hipblasHandle_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        x: *const *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        y: *const *const hipDoubleComplex,
        incy: ::core::ffi::c_int,
        AP: *const *mut hipDoubleComplex,
        lda: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\ngerStridedBatched,geruStridedBatched,gercStridedBatched performs the matrix-vector operations\n\nA_i := A_i + alpha*x_i*y_i**T, OR\nA_i := A_i + alpha*x_i*y_i**H  for gerc\n\nwhere (A_i, x_i, y_i) is the i-th instance of the batch.\nalpha is a scalar, x_i and y_i are vectors and A_i is an\nm by n matrix, for i = 1, ..., batchCount.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nm         [int]\nthe number of rows of each matrix A_i.\n@param[in]\nn         [int]\nthe number of columns of each matrix A_i.\n@param[in]\nalpha\ndevice pointer or host pointer to scalar alpha.\n@param[in]\nx         device pointer to the first vector (x_1) in the batch.\n@param[in]\nincx      [int]\nspecifies the increments for the elements of each vector x_i.\n@param[in]\nstridex   [hipblasStride]\nstride from the start of one vector (x_i) and the next one (x_i+1).\nThere are no restrictions placed on stridex, however the user should\ntake care to ensure that stridex is of appropriate size, for a typical\ncase this means stridex >= m * incx.\n@param[inout]\ny         device pointer to the first vector (y_1) in the batch.\n@param[in]\nincy      [int]\nspecifies the increment for the elements of each vector y_i.\n@param[in]\nstridey   [hipblasStride]\nstride from the start of one vector (y_i) and the next one (y_i+1).\nThere are no restrictions placed on stridey, however the user should\ntake care to ensure that stridey is of appropriate size, for a typical\ncase this means stridey >= n * incy.\n@param[inout]\nAP        device pointer to the first matrix (A_1) in the batch.\n@param[in]\nlda       [int]\nspecifies the leading dimension of each A_i.\n@param[in]\nstrideA     [hipblasStride]\nstride from the start of one matrix (A_i) and the next one (A_i+1)\n@param[in]\nbatchCount [int]\nnumber of instances in the batch\n"]
    pub fn hipblasSgerStridedBatched(
        handle: hipblasHandle_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        x: *const f32,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *const f32,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        AP: *mut f32,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgerStridedBatched(
        handle: hipblasHandle_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        x: *const f64,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *const f64,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        AP: *mut f64,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgeruStridedBatched(
        handle: hipblasHandle_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        x: *const hipblasComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *const hipblasComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        AP: *mut hipblasComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgercStridedBatched(
        handle: hipblasHandle_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        x: *const hipblasComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *const hipblasComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        AP: *mut hipblasComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgeruStridedBatched(
        handle: hipblasHandle_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *const hipblasDoubleComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        AP: *mut hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgercStridedBatched(
        handle: hipblasHandle_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *const hipblasDoubleComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        AP: *mut hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgeruStridedBatched_v2(
        handle: hipblasHandle_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipComplex,
        x: *const hipComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *const hipComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        AP: *mut hipComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgercStridedBatched_v2(
        handle: hipblasHandle_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipComplex,
        x: *const hipComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *const hipComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        AP: *mut hipComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgeruStridedBatched_v2(
        handle: hipblasHandle_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        x: *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *const hipDoubleComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        AP: *mut hipDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgercStridedBatched_v2(
        handle: hipblasHandle_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        x: *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *const hipDoubleComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        AP: *mut hipDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\nhbmv performs the matrix-vector operations\n\ny := alpha*A*x + beta*y\n\nwhere alpha and beta are scalars, x and y are n element vectors and A is an\nn by n Hermitian band matrix, with k super-diagonals.\n\n- Supported precisions in rocBLAS : c,z\n- Supported precisions in cuBLAS  : c,z\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nuplo      [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER: The upper triangular part of A is being supplied.\nHIPBLAS_FILL_MODE_LOWER: The lower triangular part of A is being supplied.\n@param[in]\nn         [int]\nthe order of the matrix A.\n@param[in]\nk         [int]\nthe number of super-diagonals of the matrix A. Must be >= 0.\n@param[in]\nalpha     device pointer or host pointer to scalar alpha.\n@param[in]\nAP        device pointer storing matrix A. Of dimension (lda, n).\nif uplo == HIPBLAS_FILL_MODE_UPPER:\nThe leading (k + 1) by n part of A must contain the upper\ntriangular band part of the Hermitian matrix, with the leading\ndiagonal in row (k + 1), the first super-diagonal on the RHS\nof row k, etc.\nThe top left k by x triangle of A will not be referenced.\nEx (upper, lda = n = 4, k = 1):\nA                             Represented matrix\n(0,0) (5,9) (6,8) (7,7)       (1, 0) (5, 9) (0, 0) (0, 0)\n(1,0) (2,0) (3,0) (4,0)       (5,-9) (2, 0) (6, 8) (0, 0)\n(0,0) (0,0) (0,0) (0,0)       (0, 0) (6,-8) (3, 0) (7, 7)\n(0,0) (0,0) (0,0) (0,0)       (0, 0) (0, 0) (7,-7) (4, 0)\n\nif uplo == HIPBLAS_FILL_MODE_LOWER:\nThe leading (k + 1) by n part of A must contain the lower\ntriangular band part of the Hermitian matrix, with the leading\ndiagonal in row (1), the first sub-diagonal on the LHS of\nrow 2, etc.\nThe bottom right k by k triangle of A will not be referenced.\nEx (lower, lda = 2, n = 4, k = 1):\nA                               Represented matrix\n(1,0) (2,0) (3,0) (4,0)         (1, 0) (5,-9) (0, 0) (0, 0)\n(5,9) (6,8) (7,7) (0,0)         (5, 9) (2, 0) (6,-8) (0, 0)\n(0, 0) (6, 8) (3, 0) (7,-7)\n(0, 0) (0, 0) (7, 7) (4, 0)\n\nAs a Hermitian matrix, the imaginary part of the main diagonal\nof A will not be referenced and is assumed to be == 0.\n@param[in]\nlda       [int]\nspecifies the leading dimension of A. must be >= k + 1\n@param[in]\nx         device pointer storing vector x.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of x.\n@param[in]\nbeta      device pointer or host pointer to scalar beta.\n@param[inout]\ny         device pointer storing vector y.\n@param[in]\nincy      [int]\nspecifies the increment for the elements of y.\n"]
    pub fn hipblasChbmv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: ::core::ffi::c_int,
        x: *const hipblasComplex,
        incx: ::core::ffi::c_int,
        beta: *const hipblasComplex,
        y: *mut hipblasComplex,
        incy: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhbmv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        x: *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        beta: *const hipblasDoubleComplex,
        y: *mut hipblasDoubleComplex,
        incy: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChbmv_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: ::core::ffi::c_int,
        x: *const hipComplex,
        incx: ::core::ffi::c_int,
        beta: *const hipComplex,
        y: *mut hipComplex,
        incy: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhbmv_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        x: *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        beta: *const hipDoubleComplex,
        y: *mut hipDoubleComplex,
        incy: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\nhbmvBatched performs one of the matrix-vector operations\n\ny_i := alpha*A_i*x_i + beta*y_i\n\nwhere alpha and beta are scalars, x_i and y_i are n element vectors and A_i is an\nn by n Hermitian band matrix with k super-diagonals, for each batch in i = [1, batchCount].\n\n- Supported precisions in rocBLAS : c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nuplo      [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER: The upper triangular part of each A_i is being supplied.\nHIPBLAS_FILL_MODE_LOWER: The lower triangular part of each A_i is being supplied.\n@param[in]\nn         [int]\nthe order of each matrix A_i.\n@param[in]\nk         [int]\nthe number of super-diagonals of each matrix A_i. Must be >= 0.\n@param[in]\nalpha     device pointer or host pointer to scalar alpha.\n@param[in]\nAP        device array of device pointers storing each matrix_i A of dimension (lda, n).\nif uplo == HIPBLAS_FILL_MODE_UPPER:\nThe leading (k + 1) by n part of each A_i must contain the upper\ntriangular band part of the Hermitian matrix, with the leading\ndiagonal in row (k + 1), the first super-diagonal on the RHS\nof row k, etc.\nThe top left k by x triangle of each A_i will not be referenced.\nEx (upper, lda = n = 4, k = 1):\nA                             Represented matrix\n(0,0) (5,9) (6,8) (7,7)       (1, 0) (5, 9) (0, 0) (0, 0)\n(1,0) (2,0) (3,0) (4,0)       (5,-9) (2, 0) (6, 8) (0, 0)\n(0,0) (0,0) (0,0) (0,0)       (0, 0) (6,-8) (3, 0) (7, 7)\n(0,0) (0,0) (0,0) (0,0)       (0, 0) (0, 0) (7,-7) (4, 0)\n\nif uplo == HIPBLAS_FILL_MODE_LOWER:\nThe leading (k + 1) by n part of each A_i must contain the lower\ntriangular band part of the Hermitian matrix, with the leading\ndiagonal in row (1), the first sub-diagonal on the LHS of\nrow 2, etc.\nThe bottom right k by k triangle of each A_i will not be referenced.\nEx (lower, lda = 2, n = 4, k = 1):\nA                               Represented matrix\n(1,0) (2,0) (3,0) (4,0)         (1, 0) (5,-9) (0, 0) (0, 0)\n(5,9) (6,8) (7,7) (0,0)         (5, 9) (2, 0) (6,-8) (0, 0)\n(0, 0) (6, 8) (3, 0) (7,-7)\n(0, 0) (0, 0) (7, 7) (4, 0)\n\nAs a Hermitian matrix, the imaginary part of the main diagonal\nof each A_i will not be referenced and is assumed to be == 0.\n@param[in]\nlda       [int]\nspecifies the leading dimension of each A_i. must be >= max(1, n)\n@param[in]\nx         device array of device pointers storing each vector x_i.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of each x_i.\n@param[in]\nbeta      device pointer or host pointer to scalar beta.\n@param[inout]\ny         device array of device pointers storing each vector y_i.\n@param[in]\nincy      [int]\nspecifies the increment for the elements of y.\n@param[in]\nbatchCount [int]\nnumber of instances in the batch.\n"]
    pub fn hipblasChbmvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        AP: *const *const hipblasComplex,
        lda: ::core::ffi::c_int,
        x: *const *const hipblasComplex,
        incx: ::core::ffi::c_int,
        beta: *const hipblasComplex,
        y: *const *mut hipblasComplex,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhbmvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        x: *const *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        beta: *const hipblasDoubleComplex,
        y: *const *mut hipblasDoubleComplex,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChbmvBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipComplex,
        AP: *const *const hipComplex,
        lda: ::core::ffi::c_int,
        x: *const *const hipComplex,
        incx: ::core::ffi::c_int,
        beta: *const hipComplex,
        y: *const *mut hipComplex,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhbmvBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        x: *const *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        beta: *const hipDoubleComplex,
        y: *const *mut hipDoubleComplex,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\nhbmvStridedBatched performs one of the matrix-vector operations\n\ny_i := alpha*A_i*x_i + beta*y_i\n\nwhere alpha and beta are scalars, x_i and y_i are n element vectors and A_i is an\nn by n Hermitian band matrix with k super-diagonals, for each batch in i = [1, batchCount].\n\n- Supported precisions in rocBLAS : c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nuplo      [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER: The upper triangular part of each A_i is being supplied.\nHIPBLAS_FILL_MODE_LOWER: The lower triangular part of each A_i is being supplied.\n@param[in]\nn         [int]\nthe order of each matrix A_i.\n@param[in]\nk         [int]\nthe number of super-diagonals of each matrix A_i. Must be >= 0.\n@param[in]\nalpha     device pointer or host pointer to scalar alpha.\n@param[in]\nAP        device array pointing to the first matrix A_1. Each A_i is of dimension (lda, n).\nif uplo == HIPBLAS_FILL_MODE_UPPER:\nThe leading (k + 1) by n part of each A_i must contain the upper\ntriangular band part of the Hermitian matrix, with the leading\ndiagonal in row (k + 1), the first super-diagonal on the RHS\nof row k, etc.\nThe top left k by x triangle of each A_i will not be referenced.\nEx (upper, lda = n = 4, k = 1):\nA                             Represented matrix\n(0,0) (5,9) (6,8) (7,7)       (1, 0) (5, 9) (0, 0) (0, 0)\n(1,0) (2,0) (3,0) (4,0)       (5,-9) (2, 0) (6, 8) (0, 0)\n(0,0) (0,0) (0,0) (0,0)       (0, 0) (6,-8) (3, 0) (7, 7)\n(0,0) (0,0) (0,0) (0,0)       (0, 0) (0, 0) (7,-7) (4, 0)\n\nif uplo == HIPBLAS_FILL_MODE_LOWER:\nThe leading (k + 1) by n part of each A_i must contain the lower\ntriangular band part of the Hermitian matrix, with the leading\ndiagonal in row (1), the first sub-diagonal on the LHS of\nrow 2, etc.\nThe bottom right k by k triangle of each A_i will not be referenced.\nEx (lower, lda = 2, n = 4, k = 1):\nA                               Represented matrix\n(1,0) (2,0) (3,0) (4,0)         (1, 0) (5,-9) (0, 0) (0, 0)\n(5,9) (6,8) (7,7) (0,0)         (5, 9) (2, 0) (6,-8) (0, 0)\n(0, 0) (6, 8) (3, 0) (7,-7)\n(0, 0) (0, 0) (7, 7) (4, 0)\n\nAs a Hermitian matrix, the imaginary part of the main diagonal\nof each A_i will not be referenced and is assumed to be == 0.\n@param[in]\nlda       [int]\nspecifies the leading dimension of each A_i. must be >= max(1, n)\n@param[in]\nstrideA  [hipblasStride]\nstride from the start of one matrix (A_i) and the next one (A_i+1)\n@param[in]\nx         device array pointing to the first vector y_1.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of each x_i.\n@param[in]\nstridex  [hipblasStride]\nstride from the start of one vector (x_i) and the next one (x_i+1)\n@param[in]\nbeta      device pointer or host pointer to scalar beta.\n@param[inout]\ny         device array pointing to the first vector y_1.\n@param[in]\nincy      [int]\nspecifies the increment for the elements of y.\n@param[in]\nstridey  [hipblasStride]\nstride from the start of one vector (y_i) and the next one (y_i+1)\n@param[in]\nbatchCount [int]\nnumber of instances in the batch.\n"]
    pub fn hipblasChbmvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *const hipblasComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        beta: *const hipblasComplex,
        y: *mut hipblasComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhbmvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        beta: *const hipblasDoubleComplex,
        y: *mut hipblasDoubleComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChbmvStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *const hipComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        beta: *const hipComplex,
        y: *mut hipComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhbmvStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        beta: *const hipDoubleComplex,
        y: *mut hipDoubleComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\nhemv performs one of the matrix-vector operations\n\ny := alpha*A*x + beta*y\n\nwhere alpha and beta are scalars, x and y are n element vectors and A is an\nn by n Hermitian matrix.\n\n- Supported precisions in rocBLAS : c,z\n- Supported precisions in cuBLAS  : c,z\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nuplo      [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER: the upper triangular part of the Hermitian matrix A is supplied.\nHIPBLAS_FILL_MODE_LOWER: the lower triangular part of the Hermitian matrix A is supplied.\n@param[in]\nn         [int]\nthe order of the matrix A.\n@param[in]\nalpha     device pointer or host pointer to scalar alpha.\n@param[in]\nAP        device pointer storing matrix A. Of dimension (lda, n).\nif uplo == HIPBLAS_FILL_MODE_UPPER:\nThe upper triangular part of A must contain\nthe upper triangular part of a Hermitian matrix. The lower\ntriangular part of A will not be referenced.\nif uplo == HIPBLAS_FILL_MODE_LOWER:\nThe lower triangular part of A must contain\nthe lower triangular part of a Hermitian matrix. The upper\ntriangular part of A will not be referenced.\nAs a Hermitian matrix, the imaginary part of the main diagonal\nof A will not be referenced and is assumed to be == 0.\n@param[in]\nlda       [int]\nspecifies the leading dimension of A. must be >= max(1, n)\n@param[in]\nx         device pointer storing vector x.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of x.\n@param[in]\nbeta      device pointer or host pointer to scalar beta.\n@param[inout]\ny         device pointer storing vector y.\n@param[in]\nincy      [int]\nspecifies the increment for the elements of y.\n"]
    pub fn hipblasChemv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: ::core::ffi::c_int,
        x: *const hipblasComplex,
        incx: ::core::ffi::c_int,
        beta: *const hipblasComplex,
        y: *mut hipblasComplex,
        incy: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhemv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        x: *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        beta: *const hipblasDoubleComplex,
        y: *mut hipblasDoubleComplex,
        incy: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChemv_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: ::core::ffi::c_int,
        x: *const hipComplex,
        incx: ::core::ffi::c_int,
        beta: *const hipComplex,
        y: *mut hipComplex,
        incy: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhemv_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        x: *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        beta: *const hipDoubleComplex,
        y: *mut hipDoubleComplex,
        incy: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\nhemvBatched performs one of the matrix-vector operations\n\ny_i := alpha*A_i*x_i + beta*y_i\n\nwhere alpha and beta are scalars, x_i and y_i are n element vectors and A_i is an\nn by n Hermitian matrix, for each batch in i = [1, batchCount].\n\n- Supported precisions in rocBLAS : c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nuplo      [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER: the upper triangular part of the Hermitian matrix A is supplied.\nHIPBLAS_FILL_MODE_LOWER: the lower triangular part of the Hermitian matrix A is supplied.\n@param[in]\nn         [int]\nthe order of each matrix A_i.\n@param[in]\nalpha     device pointer or host pointer to scalar alpha.\n@param[in]\nAP        device array of device pointers storing each matrix A_i of dimension (lda, n).\nif uplo == HIPBLAS_FILL_MODE_UPPER:\nThe upper triangular part of each A_i must contain\nthe upper triangular part of a Hermitian matrix. The lower\ntriangular part of each A_i will not be referenced.\nif uplo == HIPBLAS_FILL_MODE_LOWER:\nThe lower triangular part of each A_i must contain\nthe lower triangular part of a Hermitian matrix. The upper\ntriangular part of each A_i will not be referenced.\nAs a Hermitian matrix, the imaginary part of the main diagonal\nof each A_i will not be referenced and is assumed to be == 0.\n@param[in]\nlda       [int]\nspecifies the leading dimension of each A_i. must be >= max(1, n)\n@param[in]\nx         device array of device pointers storing each vector x_i.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of each x_i.\n@param[in]\nbeta      device pointer or host pointer to scalar beta.\n@param[inout]\ny         device array of device pointers storing each vector y_i.\n@param[in]\nincy      [int]\nspecifies the increment for the elements of y.\n@param[in]\nbatchCount [int]\nnumber of instances in the batch.\n"]
    pub fn hipblasChemvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        AP: *const *const hipblasComplex,
        lda: ::core::ffi::c_int,
        x: *const *const hipblasComplex,
        incx: ::core::ffi::c_int,
        beta: *const hipblasComplex,
        y: *const *mut hipblasComplex,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhemvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        x: *const *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        beta: *const hipblasDoubleComplex,
        y: *const *mut hipblasDoubleComplex,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChemvBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipComplex,
        AP: *const *const hipComplex,
        lda: ::core::ffi::c_int,
        x: *const *const hipComplex,
        incx: ::core::ffi::c_int,
        beta: *const hipComplex,
        y: *const *mut hipComplex,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhemvBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        x: *const *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        beta: *const hipDoubleComplex,
        y: *const *mut hipDoubleComplex,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\nhemvStridedBatched performs one of the matrix-vector operations\n\ny_i := alpha*A_i*x_i + beta*y_i\n\nwhere alpha and beta are scalars, x_i and y_i are n element vectors and A_i is an\nn by n Hermitian matrix, for each batch in i = [1, batchCount].\n\n- Supported precisions in rocBLAS : c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nuplo      [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER: the upper triangular part of the Hermitian matrix A is supplied.\nHIPBLAS_FILL_MODE_LOWER: the lower triangular part of the Hermitian matrix A is supplied.\n@param[in]\nn         [int]\nthe order of each matrix A_i.\n@param[in]\nalpha     device pointer or host pointer to scalar alpha.\n@param[in]\nAP        device array of device pointers storing each matrix A_i of dimension (lda, n).\nif uplo == HIPBLAS_FILL_MODE_UPPER:\nThe upper triangular part of each A_i must contain\nthe upper triangular part of a Hermitian matrix. The lower\ntriangular part of each A_i will not be referenced.\nif uplo == HIPBLAS_FILL_MODE_LOWER:\nThe lower triangular part of each A_i must contain\nthe lower triangular part of a Hermitian matrix. The upper\ntriangular part of each A_i will not be referenced.\nAs a Hermitian matrix, the imaginary part of the main diagonal\nof each A_i will not be referenced and is assumed to be == 0.\n@param[in]\nlda       [int]\nspecifies the leading dimension of each A_i. must be >= max(1, n)\n@param[in]\nstrideA    [hipblasStride]\nstride from the start of one (A_i) to the next (A_i+1)\n\n@param[in]\nx         device array of device pointers storing each vector x_i.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of each x_i.\n@param[in]\nstridex  [hipblasStride]\nstride from the start of one vector (x_i) and the next one (x_i+1).\n@param[in]\nbeta      device pointer or host pointer to scalar beta.\n@param[inout]\ny         device array of device pointers storing each vector y_i.\n@param[in]\nincy      [int]\nspecifies the increment for the elements of y.\n@param[in]\nstridey  [hipblasStride]\nstride from the start of one vector (y_i) and the next one (y_i+1).\n@param[in]\nbatchCount [int]\nnumber of instances in the batch.\n"]
    pub fn hipblasChemvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *const hipblasComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        beta: *const hipblasComplex,
        y: *mut hipblasComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhemvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        beta: *const hipblasDoubleComplex,
        y: *mut hipblasDoubleComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChemvStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *const hipComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        beta: *const hipComplex,
        y: *mut hipComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhemvStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        beta: *const hipDoubleComplex,
        y: *mut hipDoubleComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\nher performs the matrix-vector operations\n\nA := A + alpha*x*x**H\n\nwhere alpha is a real scalar, x is a vector, and A is an\nn by n Hermitian matrix.\n\n- Supported precisions in rocBLAS : c,z\n- Supported precisions in cuBLAS  : c,z\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nuplo      [hipblasFillMode_t]\nspecifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'\nHIPBLAS_FILL_MODE_UPPER: The upper triangular part of A is supplied in A.\nHIPBLAS_FILL_MODE_LOWER: The lower triangular part of A is supplied in A.\n@param[in]\nn         [int]\nthe number of rows and columns of matrix A, must be at least 0.\n@param[in]\nalpha\ndevice pointer or host pointer to scalar alpha.\n@param[in]\nx         device pointer storing vector x.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of x.\n@param[inout]\nAP        device pointer storing the specified triangular portion of\nthe Hermitian matrix A. Of size (lda * n).\nif uplo == HIPBLAS_FILL_MODE_UPPER:\nThe upper triangular portion of the Hermitian matrix A is supplied. The lower\ntriangluar portion will not be touched.\nif uplo == HIPBLAS_FILL_MODE_LOWER:\nThe lower triangular portion of the Hermitian matrix A is supplied. The upper\ntriangular portion will not be touched.\nNote that the imaginary part of the diagonal elements are not accessed and are assumed\nto be 0.\n@param[in]\nlda       [int]\nspecifies the leading dimension of A. Must be at least max(1, n)."]
    pub fn hipblasCher(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        x: *const hipblasComplex,
        incx: ::core::ffi::c_int,
        AP: *mut hipblasComplex,
        lda: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZher(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        x: *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        AP: *mut hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCher_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        x: *const hipComplex,
        incx: ::core::ffi::c_int,
        AP: *mut hipComplex,
        lda: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZher_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        x: *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        AP: *mut hipDoubleComplex,
        lda: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\nherBatched performs the matrix-vector operations\n\nA_i := A_i + alpha*x_i*x_i**H\n\nwhere alpha is a real scalar, x_i is a vector, and A_i is an\nn by n symmetric matrix, for i = 1, ..., batchCount.\n\n- Supported precisions in rocBLAS : c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nuplo      [hipblasFillMode_t]\nspecifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'\nHIPBLAS_FILL_MODE_UPPER: The upper triangular part of each A_i is supplied in A.\nHIPBLAS_FILL_MODE_LOWER: The lower triangular part of each A_i is supplied in A.\n@param[in]\nn         [int]\nthe number of rows and columns of each matrix A_i, must be at least 0.\n@param[in]\nalpha\ndevice pointer or host pointer to scalar alpha.\n@param[in]\nx         device array of device pointers storing each vector x_i.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of each x_i.\n@param[inout]\nAP       device array of device pointers storing the specified triangular portion of\neach Hermitian matrix A_i of at least size ((n * (n + 1)) / 2). Array is of at least size batchCount.\nif uplo == HIPBLAS_FILL_MODE_UPPER:\nThe upper triangular portion of each Hermitian matrix A_i is supplied. The lower triangular portion\nof each A_i will not be touched.\nif uplo == HIPBLAS_FILL_MODE_LOWER:\nThe lower triangular portion of each Hermitian matrix A_i is supplied. The upper triangular portion\nof each A_i will not be touched.\nNote that the imaginary part of the diagonal elements are not accessed and are assumed\nto be 0.\n@param[in]\nlda       [int]\nspecifies the leading dimension of each A_i. Must be at least max(1, n).\n@param[in]\nbatchCount [int]\nnumber of instances in the batch."]
    pub fn hipblasCherBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        x: *const *const hipblasComplex,
        incx: ::core::ffi::c_int,
        AP: *const *mut hipblasComplex,
        lda: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZherBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        x: *const *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        AP: *const *mut hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCherBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        x: *const *const hipComplex,
        incx: ::core::ffi::c_int,
        AP: *const *mut hipComplex,
        lda: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZherBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        x: *const *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        AP: *const *mut hipDoubleComplex,
        lda: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\nherStridedBatched performs the matrix-vector operations\n\nA_i := A_i + alpha*x_i*x_i**H\n\nwhere alpha is a real scalar, x_i is a vector, and A_i is an\nn by n Hermitian matrix, for i = 1, ..., batchCount.\n\n- Supported precisions in rocBLAS : c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nuplo      [hipblasFillMode_t]\nspecifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'\nHIPBLAS_FILL_MODE_UPPER: The upper triangular part of each A_i is supplied in A.\nHIPBLAS_FILL_MODE_LOWER: The lower triangular part of each A_i is supplied in A.\n@param[in]\nn         [int]\nthe number of rows and columns of each matrix A_i, must be at least 0.\n@param[in]\nalpha\ndevice pointer or host pointer to scalar alpha.\n@param[in]\nx         device pointer pointing to the first vector (x_1).\n@param[in]\nincx      [int]\nspecifies the increment for the elements of each x_i.\n@param[in]\nstridex  [hipblasStride]\nstride from the start of one vector (x_i) and the next one (x_i+1).\n@param[inout]\nAP        device array of device pointers storing the specified triangular portion of\neach Hermitian matrix A_i. Points to the first matrix (A_1).\nif uplo == HIPBLAS_FILL_MODE_UPPER:\nThe upper triangular portion of each Hermitian matrix A_i is supplied. The lower triangular\nportion of each A_i will not be touched.\nif uplo == HIPBLAS_FILL_MODE_LOWER:\nThe lower triangular portion of each Hermitian matrix A_i is supplied. The upper triangular\nportion of each A_i will not be touched.\nNote that the imaginary part of the diagonal elements are not accessed and are assumed\nto be 0.\n@param[in]\nlda       [int]\nspecifies the leading dimension of each A_i.\n@param[in]\nstrideA    [hipblasStride]\nstride from the start of one (A_i) and the next (A_i+1)\n@param[in]\nbatchCount [int]\nnumber of instances in the batch."]
    pub fn hipblasCherStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        x: *const hipblasComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        AP: *mut hipblasComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZherStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        x: *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        AP: *mut hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCherStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        x: *const hipComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        AP: *mut hipComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZherStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        x: *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        AP: *mut hipDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\nher2 performs the matrix-vector operations\n\nA := A + alpha*x*y**H + conj(alpha)*y*x**H\n\nwhere alpha is a complex scalar, x and y are vectors, and A is an\nn by n Hermitian matrix.\n\n- Supported precisions in rocBLAS : c,z\n- Supported precisions in cuBLAS  : c,z\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nuplo      [hipblasFillMode_t]\nspecifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'\nHIPBLAS_FILL_MODE_UPPER: The upper triangular part of A is supplied.\nHIPBLAS_FILL_MODE_LOWER: The lower triangular part of A is supplied.\n@param[in]\nn         [int]\nthe number of rows and columns of matrix A, must be at least 0.\n@param[in]\nalpha\ndevice pointer or host pointer to scalar alpha.\n@param[in]\nx         device pointer storing vector x.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of x.\n@param[in]\ny         device pointer storing vector y.\n@param[in]\nincy      [int]\nspecifies the increment for the elements of y.\n@param[inout]\nAP         device pointer storing the specified triangular portion of\nthe Hermitian matrix A. Of size (lda, n).\nif uplo == HIPBLAS_FILL_MODE_UPPER:\nThe upper triangular portion of the Hermitian matrix A is supplied. The lower triangular\nportion of A will not be touched.\nif uplo == HIPBLAS_FILL_MODE_LOWER:\nThe lower triangular portion of the Hermitian matrix A is supplied. The upper triangular\nportion of A will not be touched.\nNote that the imaginary part of the diagonal elements are not accessed and are assumed\nto be 0.\n@param[in]\nlda       [int]\nspecifies the leading dimension of A. Must be at least max(lda, 1)."]
    pub fn hipblasCher2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        x: *const hipblasComplex,
        incx: ::core::ffi::c_int,
        y: *const hipblasComplex,
        incy: ::core::ffi::c_int,
        AP: *mut hipblasComplex,
        lda: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZher2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        y: *const hipblasDoubleComplex,
        incy: ::core::ffi::c_int,
        AP: *mut hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCher2_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipComplex,
        x: *const hipComplex,
        incx: ::core::ffi::c_int,
        y: *const hipComplex,
        incy: ::core::ffi::c_int,
        AP: *mut hipComplex,
        lda: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZher2_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        x: *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        y: *const hipDoubleComplex,
        incy: ::core::ffi::c_int,
        AP: *mut hipDoubleComplex,
        lda: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\nher2Batched performs the matrix-vector operations\n\nA_i := A_i + alpha*x_i*y_i**H + conj(alpha)*y_i*x_i**H\n\nwhere alpha is a complex scalar, x_i and y_i are vectors, and A_i is an\nn by n Hermitian matrix for each batch in i = [1, batchCount].\n\n- Supported precisions in rocBLAS : c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nuplo      [hipblasFillMode_t]\nspecifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'\nHIPBLAS_FILL_MODE_UPPER: The upper triangular part of each A_i is supplied.\nHIPBLAS_FILL_MODE_LOWER: The lower triangular part of each A_i is supplied.\n@param[in]\nn         [int]\nthe number of rows and columns of each matrix A_i, must be at least 0.\n@param[in]\nalpha\ndevice pointer or host pointer to scalar alpha.\n@param[in]\nx         device array of device pointers storing each vector x_i.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of x.\n@param[in]\ny         device array of device pointers storing each vector y_i.\n@param[in]\nincy      [int]\nspecifies the increment for the elements of each y_i.\n@param[inout]\nAP         device array of device pointers storing the specified triangular portion of\neach Hermitian matrix A_i of size (lda, n).\nif uplo == HIPBLAS_FILL_MODE_UPPER:\nThe upper triangular portion of each Hermitian matrix A_i is supplied. The lower triangular\nportion of each A_i will not be touched.\nif uplo == HIPBLAS_FILL_MODE_LOWER:\nThe lower triangular portion of each Hermitian matrix A_i is supplied. The upper triangular\nportion of each A_i will not be touched.\nNote that the imaginary part of the diagonal elements are not accessed and are assumed\nto be 0.\n@param[in]\nlda       [int]\nspecifies the leading dimension of each A_i. Must be at least max(lda, 1).\n@param[in]\nbatchCount [int]\nnumber of instances in the batch."]
    pub fn hipblasCher2Batched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        x: *const *const hipblasComplex,
        incx: ::core::ffi::c_int,
        y: *const *const hipblasComplex,
        incy: ::core::ffi::c_int,
        AP: *const *mut hipblasComplex,
        lda: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZher2Batched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        y: *const *const hipblasDoubleComplex,
        incy: ::core::ffi::c_int,
        AP: *const *mut hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCher2Batched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipComplex,
        x: *const *const hipComplex,
        incx: ::core::ffi::c_int,
        y: *const *const hipComplex,
        incy: ::core::ffi::c_int,
        AP: *const *mut hipComplex,
        lda: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZher2Batched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        x: *const *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        y: *const *const hipDoubleComplex,
        incy: ::core::ffi::c_int,
        AP: *const *mut hipDoubleComplex,
        lda: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\nher2StridedBatched performs the matrix-vector operations\n\nA_i := A_i + alpha*x_i*y_i**H + conj(alpha)*y_i*x_i**H\n\nwhere alpha is a complex scalar, x_i and y_i are vectors, and A_i is an\nn by n Hermitian matrix for each batch in i = [1, batchCount].\n\n- Supported precisions in rocBLAS : c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nuplo      [hipblasFillMode_t]\nspecifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'\nHIPBLAS_FILL_MODE_UPPER: The upper triangular part of each A_i is supplied.\nHIPBLAS_FILL_MODE_LOWER: The lower triangular part of each A_i is supplied.\n@param[in]\nn         [int]\nthe number of rows and columns of each matrix A_i, must be at least 0.\n@param[in]\nalpha\ndevice pointer or host pointer to scalar alpha.\n@param[in]\nx         device pointer pointing to the first vector x_1.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of each x_i.\n@param[in]\nstridex  [hipblasStride]\nspecifies the stride between the beginning of one vector (x_i) and the next (x_i+1).\n@param[in]\ny         device pointer pointing to the first vector y_i.\n@param[in]\nincy      [int]\nspecifies the increment for the elements of each y_i.\n@param[in]\nstridey  [hipblasStride]\nspecifies the stride between the beginning of one vector (y_i) and the next (y_i+1).\n@param[inout]\nAP        device pointer pointing to the first matrix (A_1). Stores the specified triangular portion of\neach Hermitian matrix A_i.\nif uplo == HIPBLAS_FILL_MODE_UPPER:\nThe upper triangular portion of each Hermitian matrix A_i is supplied. The lower triangular\nportion of each A_i will not be touched.\nif uplo == HIPBLAS_FILL_MODE_LOWER:\nThe lower triangular portion of each Hermitian matrix A_i is supplied. The upper triangular\nportion of each A_i will not be touched.\nNote that the imaginary part of the diagonal elements are not accessed and are assumed\nto be 0.\n@param[in]\nlda       [int]\nspecifies the leading dimension of each A_i. Must be at least max(lda, 1).\n@param[in]\nstrideA  [hipblasStride]\nspecifies the stride between the beginning of one matrix (A_i) and the next (A_i+1).\n@param[in]\nbatchCount [int]\nnumber of instances in the batch."]
    pub fn hipblasCher2StridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        x: *const hipblasComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *const hipblasComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        AP: *mut hipblasComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZher2StridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *const hipblasDoubleComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        AP: *mut hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCher2StridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipComplex,
        x: *const hipComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *const hipComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        AP: *mut hipComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZher2StridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        x: *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *const hipDoubleComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        AP: *mut hipDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\nhpmv performs the matrix-vector operation\n\ny := alpha*A*x + beta*y\n\nwhere alpha and beta are scalars, x and y are n element vectors and A is an\nn by n Hermitian matrix, supplied in packed form (see description below).\n\n- Supported precisions in rocBLAS : c,z\n- Supported precisions in cuBLAS  : c,z\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nuplo      [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER: the upper triangular part of the Hermitian matrix A is supplied in AP.\nHIPBLAS_FILL_MODE_LOWER: the lower triangular part of the Hermitian matrix A is supplied in AP.\n@param[in]\nn         [int]\nthe order of the matrix A, must be >= 0.\n@param[in]\nalpha     device pointer or host pointer to scalar alpha.\n@param[in]\nAP        device pointer storing the packed version of the specified triangular portion of\nthe Hermitian matrix A. Of at least size ((n * (n + 1)) / 2).\nif uplo == HIPBLAS_FILL_MODE_UPPER:\nThe upper triangular portion of the Hermitian matrix A is supplied.\nThe matrix is compacted so that AP contains the triangular portion column-by-column\nso that:\nAP(0) = A(0,0)\nAP(1) = A(0,1)\nAP(2) = A(1,1), etc.\nEx: (HIPBLAS_FILL_MODE_UPPER; n = 3)\n(1, 0) (2, 1) (3, 2)\n(2,-1) (4, 0) (5,-1)    -----> [(1,0), (2,1), (4,0), (3,2), (5,-1), (6,0)]\n(3,-2) (5, 1) (6, 0)\nif uplo == HIPBLAS_FILL_MODE_LOWER:\nThe lower triangular portion of the Hermitian matrix A is supplied.\nThe matrix is compacted so that AP contains the triangular portion column-by-column\nso that:\nAP(0) = A(0,0)\nAP(1) = A(1,0)\nAP(2) = A(2,1), etc.\nEx: (HIPBLAS_FILL_MODE_LOWER; n = 3)\n(1, 0) (2, 1) (3, 2)\n(2,-1) (4, 0) (5,-1)    -----> [(1,0), (2,-1), (3,-2), (4,0), (5,1), (6,0)]\n(3,-2) (5, 1) (6, 0)\nNote that the imaginary part of the diagonal elements are not accessed and are assumed\nto be 0.\n@param[in]\nx         device pointer storing vector x.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of x.\n@param[in]\nbeta      device pointer or host pointer to scalar beta.\n@param[inout]\ny         device pointer storing vector y.\n@param[in]\nincy      [int]\nspecifies the increment for the elements of y.\n"]
    pub fn hipblasChpmv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        x: *const hipblasComplex,
        incx: ::core::ffi::c_int,
        beta: *const hipblasComplex,
        y: *mut hipblasComplex,
        incy: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhpmv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        x: *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        beta: *const hipblasDoubleComplex,
        y: *mut hipblasDoubleComplex,
        incy: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChpmv_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        x: *const hipComplex,
        incx: ::core::ffi::c_int,
        beta: *const hipComplex,
        y: *mut hipComplex,
        incy: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhpmv_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        x: *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        beta: *const hipDoubleComplex,
        y: *mut hipDoubleComplex,
        incy: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\nhpmvBatched performs the matrix-vector operation\n\ny_i := alpha*A_i*x_i + beta*y_i\n\nwhere alpha and beta are scalars, x_i and y_i are n element vectors and A_i is an\nn by n Hermitian matrix, supplied in packed form (see description below),\nfor each batch in i = [1, batchCount].\n\n- Supported precisions in rocBLAS : c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nuplo      [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER: the upper triangular part of each Hermitian matrix A_i is supplied in AP.\nHIPBLAS_FILL_MODE_LOWER: the lower triangular part of each Hermitian matrix A_i is supplied in AP.\n@param[in]\nn         [int]\nthe order of each matrix A_i.\n@param[in]\nalpha     device pointer or host pointer to scalar alpha.\n@param[in]\nAP      device pointer of device pointers storing the packed version of the specified triangular\nportion of each Hermitian matrix A_i. Each A_i is of at least size ((n * (n + 1)) / 2).\nif uplo == HIPBLAS_FILL_MODE_UPPER:\nThe upper triangular portion of each Hermitian matrix A_i is supplied.\nThe matrix is compacted so that each AP_i contains the triangular portion column-by-column\nso that:\nAP(0) = A(0,0)\nAP(1) = A(0,1)\nAP(2) = A(1,1), etc.\nEx: (HIPBLAS_FILL_MODE_UPPER; n = 3)\n(1, 0) (2, 1) (3, 2)\n(2,-1) (4, 0) (5,-1)    -----> [(1,0), (2,1), (4,0), (3,2), (5,-1), (6,0)]\n(3,-2) (5, 1) (6, 0)\nif uplo == HIPBLAS_FILL_MODE_LOWER:\nThe lower triangular portion of each Hermitian matrix A_i is supplied.\nThe matrix is compacted so that each AP_i contains the triangular portion column-by-column\nso that:\nAP(0) = A(0,0)\nAP(1) = A(1,0)\nAP(2) = A(2,1), etc.\nEx: (HIPBLAS_FILL_MODE_LOWER; n = 3)\n(1, 0) (2, 1) (3, 2)\n(2,-1) (4, 0) (5,-1)    -----> [(1,0), (2,-1), (3,-2), (4,0), (5,1), (6,0)]\n(3,-2) (5, 1) (6, 0)\nNote that the imaginary part of the diagonal elements are not accessed and are assumed\nto be 0.\n@param[in]\nx         device array of device pointers storing each vector x_i.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of each x_i.\n@param[in]\nbeta      device pointer or host pointer to scalar beta.\n@param[inout]\ny         device array of device pointers storing each vector y_i.\n@param[in]\nincy      [int]\nspecifies the increment for the elements of y.\n@param[in]\nbatchCount [int]\nnumber of instances in the batch.\n"]
    pub fn hipblasChpmvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        AP: *const *const hipblasComplex,
        x: *const *const hipblasComplex,
        incx: ::core::ffi::c_int,
        beta: *const hipblasComplex,
        y: *const *mut hipblasComplex,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhpmvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const *const hipblasDoubleComplex,
        x: *const *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        beta: *const hipblasDoubleComplex,
        y: *const *mut hipblasDoubleComplex,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChpmvBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipComplex,
        AP: *const *const hipComplex,
        x: *const *const hipComplex,
        incx: ::core::ffi::c_int,
        beta: *const hipComplex,
        y: *const *mut hipComplex,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhpmvBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const *const hipDoubleComplex,
        x: *const *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        beta: *const hipDoubleComplex,
        y: *const *mut hipDoubleComplex,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\nhpmvStridedBatched performs the matrix-vector operation\n\ny_i := alpha*A_i*x_i + beta*y_i\n\nwhere alpha and beta are scalars, x_i and y_i are n element vectors and A_i is an\nn by n Hermitian matrix, supplied in packed form (see description below),\nfor each batch in i = [1, batchCount].\n\n- Supported precisions in rocBLAS : c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nuplo      [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER: the upper triangular part of each Hermitian matrix A_i is supplied in AP.\nHIPBLAS_FILL_MODE_LOWER: the lower triangular part of each Hermitian matrix A_i is supplied in AP.\n@param[in]\nn         [int]\nthe order of each matrix A_i.\n@param[in]\nalpha     device pointer or host pointer to scalar alpha.\n@param[in]\nAP        device pointer pointing to the beginning of the first matrix (AP_1). Stores the packed\nversion of the specified triangular portion of each Hermitian matrix AP_i of size ((n * (n + 1)) / 2).\nif uplo == HIPBLAS_FILL_MODE_UPPER:\nThe upper triangular portion of each Hermitian matrix A_i is supplied.\nThe matrix is compacted so that each AP_i contains the triangular portion column-by-column\nso that:\nAP(0) = A(0,0)\nAP(1) = A(0,1)\nAP(2) = A(1,1), etc.\nEx: (HIPBLAS_FILL_MODE_UPPER; n = 3)\n(1, 0) (2, 1) (3, 2)\n(2,-1) (4, 0) (5,-1)    -----> [(1,0), (2,1), (4,0), (3,2), (5,-1), (6,0)]\n(3,-2) (5, 1) (6, 0)\nif uplo == HIPBLAS_FILL_MODE_LOWER:\nThe lower triangular portion of each Hermitian matrix A_i is supplied.\nThe matrix is compacted so that each AP_i contains the triangular portion column-by-column\nso that:\nAP(0) = A(0,0)\nAP(1) = A(1,0)\nAP(2) = A(2,1), etc.\nEx: (HIPBLAS_FILL_MODE_LOWER; n = 3)\n(1, 0) (2, 1) (3, 2)\n(2,-1) (4, 0) (5,-1)    -----> [(1,0), (2,-1), (3,-2), (4,0), (5,1), (6,0)]\n(3,-2) (5, 1) (6, 0)\nNote that the imaginary part of the diagonal elements are not accessed and are assumed\nto be 0.\n@param[in]\nstrideA  [hipblasStride]\nstride from the start of one matrix (AP_i) and the next one (AP_i+1).\n@param[in]\nx         device array pointing to the beginning of the first vector (x_1).\n@param[in]\nincx      [int]\nspecifies the increment for the elements of each x_i.\n@param[in]\nstridex  [hipblasStride]\nstride from the start of one vector (x_i) and the next one (x_i+1).\n@param[in]\nbeta      device pointer or host pointer to scalar beta.\n@param[inout]\ny         device array pointing to the beginning of the first vector (y_1).\n@param[in]\nincy      [int]\nspecifies the increment for the elements of y.\n@param[in]\nstridey  [hipblasStride]\nstride from the start of one vector (y_i) and the next one (y_i+1).\n@param[in]\nbatchCount [int]\nnumber of instances in the batch.\n"]
    pub fn hipblasChpmvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        strideA: hipblasStride,
        x: *const hipblasComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        beta: *const hipblasComplex,
        y: *mut hipblasComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhpmvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        strideA: hipblasStride,
        x: *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        beta: *const hipblasDoubleComplex,
        y: *mut hipblasDoubleComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChpmvStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        strideA: hipblasStride,
        x: *const hipComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        beta: *const hipComplex,
        y: *mut hipComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhpmvStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        strideA: hipblasStride,
        x: *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        beta: *const hipDoubleComplex,
        y: *mut hipDoubleComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\nhpr performs the matrix-vector operations\n\nA := A + alpha*x*x**H\n\nwhere alpha is a real scalar, x is a vector, and A is an\nn by n Hermitian matrix, supplied in packed form.\n\n- Supported precisions in rocBLAS : c,z\n- Supported precisions in cuBLAS  : c,z\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nuplo      [hipblasFillMode_t]\nspecifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'\nHIPBLAS_FILL_MODE_UPPER: The upper triangular part of A is supplied in AP.\nHIPBLAS_FILL_MODE_LOWER: The lower triangular part of A is supplied in AP.\n@param[in]\nn         [int]\nthe number of rows and columns of matrix A, must be at least 0.\n@param[in]\nalpha\ndevice pointer or host pointer to scalar alpha.\n@param[in]\nx         device pointer storing vector x.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of x.\n@param[inout]\nAP        device pointer storing the packed version of the specified triangular portion of\nthe Hermitian matrix A. Of at least size ((n * (n + 1)) / 2).\nif uplo == HIPBLAS_FILL_MODE_UPPER:\nThe upper triangular portion of the Hermitian matrix A is supplied.\nThe matrix is compacted so that AP contains the triangular portion column-by-column\nso that:\nAP(0) = A(0,0)\nAP(1) = A(0,1)\nAP(2) = A(1,1), etc.\nEx: (HIPBLAS_FILL_MODE_UPPER; n = 3)\n(1, 0) (2, 1) (4,9)\n(2,-1) (3, 0) (5,3)  -----> [(1,0), (2,1), (3,0), (4,9), (5,3), (6,0)]\n(4,-9) (5,-3) (6,0)\nif uplo == HIPBLAS_FILL_MODE_LOWER:\nThe lower triangular portion of the Hermitian matrix A is supplied.\nThe matrix is compacted so that AP contains the triangular portion column-by-column\nso that:\nAP(0) = A(0,0)\nAP(1) = A(1,0)\nAP(2) = A(2,1), etc.\nEx: (HIPBLAS_FILL_MODE_LOWER; n = 3)\n(1, 0) (2, 1) (4,9)\n(2,-1) (3, 0) (5,3)  -----> [(1,0), (2,-1), (4,-9), (3,0), (5,-3), (6,0)]\n(4,-9) (5,-3) (6,0)\nNote that the imaginary part of the diagonal elements are not accessed and are assumed\nto be 0."]
    pub fn hipblasChpr(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        x: *const hipblasComplex,
        incx: ::core::ffi::c_int,
        AP: *mut hipblasComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhpr(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        x: *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        AP: *mut hipblasDoubleComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChpr_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        x: *const hipComplex,
        incx: ::core::ffi::c_int,
        AP: *mut hipComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhpr_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        x: *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        AP: *mut hipDoubleComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\nhprBatched performs the matrix-vector operations\n\nA_i := A_i + alpha*x_i*x_i**H\n\nwhere alpha is a real scalar, x_i is a vector, and A_i is an\nn by n symmetric matrix, supplied in packed form, for i = 1, ..., batchCount.\n\n- Supported precisions in rocBLAS : c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nuplo      [hipblasFillMode_t]\nspecifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'\nHIPBLAS_FILL_MODE_UPPER: The upper triangular part of each A_i is supplied in AP.\nHIPBLAS_FILL_MODE_LOWER: The lower triangular part of each A_i is supplied in AP.\n@param[in]\nn         [int]\nthe number of rows and columns of each matrix A_i, must be at least 0.\n@param[in]\nalpha\ndevice pointer or host pointer to scalar alpha.\n@param[in]\nx         device array of device pointers storing each vector x_i.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of each x_i.\n@param[inout]\nAP        device array of device pointers storing the packed version of the specified triangular portion of\neach Hermitian matrix A_i of at least size ((n * (n + 1)) / 2). Array is of at least size batchCount.\nif uplo == HIPBLAS_FILL_MODE_UPPER:\nThe upper triangular portion of each Hermitian matrix A_i is supplied.\nThe matrix is compacted so that AP contains the triangular portion column-by-column\nso that:\nAP(0) = A(0,0)\nAP(1) = A(0,1)\nAP(2) = A(1,1), etc.\nEx: (HIPBLAS_FILL_MODE_UPPER; n = 3)\n(1, 0) (2, 1) (4,9)\n(2,-1) (3, 0) (5,3)  -----> [(1,0), (2,1), (3,0), (4,9), (5,3), (6,0)]\n(4,-9) (5,-3) (6,0)\nif uplo == HIPBLAS_FILL_MODE_LOWER:\nThe lower triangular portion of each Hermitian matrix A_i is supplied.\nThe matrix is compacted so that AP contains the triangular portion column-by-column\nso that:\nAP(0) = A(0,0)\nAP(1) = A(1,0)\nAP(2) = A(2,1), etc.\nEx: (HIPBLAS_FILL_MODE_LOWER; n = 3)\n(1, 0) (2, 1) (4,9)\n(2,-1) (3, 0) (5,3)  -----> [(1,0), (2,-1), (4,-9), (3,0), (5,-3), (6,0)]\n(4,-9) (5,-3) (6,0)\nNote that the imaginary part of the diagonal elements are not accessed and are assumed\nto be 0.\n@param[in]\nbatchCount [int]\nnumber of instances in the batch."]
    pub fn hipblasChprBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        x: *const *const hipblasComplex,
        incx: ::core::ffi::c_int,
        AP: *const *mut hipblasComplex,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhprBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        x: *const *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        AP: *const *mut hipblasDoubleComplex,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChprBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        x: *const *const hipComplex,
        incx: ::core::ffi::c_int,
        AP: *const *mut hipComplex,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhprBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        x: *const *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        AP: *const *mut hipDoubleComplex,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\nhprStridedBatched performs the matrix-vector operations\n\nA_i := A_i + alpha*x_i*x_i**H\n\nwhere alpha is a real scalar, x_i is a vector, and A_i is an\nn by n symmetric matrix, supplied in packed form, for i = 1, ..., batchCount.\n\n- Supported precisions in rocBLAS : c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nuplo      [hipblasFillMode_t]\nspecifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'\nHIPBLAS_FILL_MODE_UPPER: The upper triangular part of each A_i is supplied in AP.\nHIPBLAS_FILL_MODE_LOWER: The lower triangular part of each A_i is supplied in AP.\n@param[in]\nn         [int]\nthe number of rows and columns of each matrix A_i, must be at least 0.\n@param[in]\nalpha\ndevice pointer or host pointer to scalar alpha.\n@param[in]\nx         device pointer pointing to the first vector (x_1).\n@param[in]\nincx      [int]\nspecifies the increment for the elements of each x_i.\n@param[in]\nstridex  [hipblasStride]\nstride from the start of one vector (x_i) and the next one (x_i+1).\n@param[inout]\nAP        device array of device pointers storing the packed version of the specified triangular portion of\neach Hermitian matrix A_i. Points to the first matrix (A_1).\nif uplo == HIPBLAS_FILL_MODE_UPPER:\nThe upper triangular portion of each Hermitian matrix A_i is supplied.\nThe matrix is compacted so that AP contains the triangular portion column-by-column\nso that:\nAP(0) = A(0,0)\nAP(1) = A(0,1)\nAP(2) = A(1,1), etc.\nEx: (HIPBLAS_FILL_MODE_UPPER; n = 3)\n(1, 0) (2, 1) (4,9)\n(2,-1) (3, 0) (5,3)  -----> [(1,0), (2,1), (3,0), (4,9), (5,3), (6,0)]\n(4,-9) (5,-3) (6,0)\nif uplo == HIPBLAS_FILL_MODE_LOWER:\nThe lower triangular portion of each Hermitian matrix A_i is supplied.\nThe matrix is compacted so that AP contains the triangular portion column-by-column\nso that:\nAP(0) = A(0,0)\nAP(1) = A(1,0)\nAP(2) = A(2,1), etc.\nEx: (HIPBLAS_FILL_MODE_LOWER; n = 3)\n(1, 0) (2, 1) (4,9)\n(2,-1) (3, 0) (5,3)  -----> [(1,0), (2,-1), (4,-9), (3,0), (5,-3), (6,0)]\n(4,-9) (5,-3) (6,0)\nNote that the imaginary part of the diagonal elements are not accessed and are assumed\nto be 0.\n@param[in]\nstrideA   [hipblasStride]\nstride from the start of one (A_i) and the next (A_i+1)\n@param[in]\nbatchCount [int]\nnumber of instances in the batch."]
    pub fn hipblasChprStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        x: *const hipblasComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        AP: *mut hipblasComplex,
        strideA: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhprStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        x: *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        AP: *mut hipblasDoubleComplex,
        strideA: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChprStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        x: *const hipComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        AP: *mut hipComplex,
        strideA: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhprStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        x: *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        AP: *mut hipDoubleComplex,
        strideA: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\nhpr2 performs the matrix-vector operations\n\nA := A + alpha*x*y**H + conj(alpha)*y*x**H\n\nwhere alpha is a complex scalar, x and y are vectors, and A is an\nn by n Hermitian matrix, supplied in packed form.\n\n- Supported precisions in rocBLAS : c,z\n- Supported precisions in cuBLAS  : c,z\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nuplo      [hipblasFillMode_t]\nspecifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'\nHIPBLAS_FILL_MODE_UPPER: The upper triangular part of A is supplied in AP.\nHIPBLAS_FILL_MODE_LOWER: The lower triangular part of A is supplied in AP.\n@param[in]\nn         [int]\nthe number of rows and columns of matrix A, must be at least 0.\n@param[in]\nalpha\ndevice pointer or host pointer to scalar alpha.\n@param[in]\nx         device pointer storing vector x.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of x.\n@param[in]\ny         device pointer storing vector y.\n@param[in]\nincy      [int]\nspecifies the increment for the elements of y.\n@param[inout]\nAP        device pointer storing the packed version of the specified triangular portion of\nthe Hermitian matrix A. Of at least size ((n * (n + 1)) / 2).\nif uplo == HIPBLAS_FILL_MODE_UPPER:\nThe upper triangular portion of the Hermitian matrix A is supplied.\nThe matrix is compacted so that AP contains the triangular portion column-by-column\nso that:\nAP(0) = A(0,0)\nAP(1) = A(0,1)\nAP(2) = A(1,1), etc.\nEx: (HIPBLAS_FILL_MODE_UPPER; n = 3)\n(1, 0) (2, 1) (4,9)\n(2,-1) (3, 0) (5,3)  -----> [(1,0), (2,1), (3,0), (4,9), (5,3), (6,0)]\n(4,-9) (5,-3) (6,0)\nif uplo == HIPBLAS_FILL_MODE_LOWER:\nThe lower triangular portion of the Hermitian matrix A is supplied.\nThe matrix is compacted so that AP contains the triangular portion column-by-column\nso that:\nAP(0) = A(0,0)\nAP(1) = A(1,0)\nAP(2) = A(2,1), etc.\nEx: (HIPBLAS_FILL_MODE_LOWER; n = 3)\n(1, 0) (2, 1) (4,9)\n(2,-1) (3, 0) (5,3)  -----> [(1,0), (2,-1), (4,-9), (3,0), (5,-3), (6,0)]\n(4,-9) (5,-3) (6,0)\nNote that the imaginary part of the diagonal elements are not accessed and are assumed\nto be 0."]
    pub fn hipblasChpr2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        x: *const hipblasComplex,
        incx: ::core::ffi::c_int,
        y: *const hipblasComplex,
        incy: ::core::ffi::c_int,
        AP: *mut hipblasComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhpr2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        y: *const hipblasDoubleComplex,
        incy: ::core::ffi::c_int,
        AP: *mut hipblasDoubleComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChpr2_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipComplex,
        x: *const hipComplex,
        incx: ::core::ffi::c_int,
        y: *const hipComplex,
        incy: ::core::ffi::c_int,
        AP: *mut hipComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhpr2_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        x: *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        y: *const hipDoubleComplex,
        incy: ::core::ffi::c_int,
        AP: *mut hipDoubleComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\nhpr2Batched performs the matrix-vector operations\n\nA_i := A_i + alpha*x_i*y_i**H + conj(alpha)*y_i*x_i**H\n\nwhere alpha is a complex scalar, x_i and y_i are vectors, and A_i is an\nn by n symmetric matrix, supplied in packed form, for i = 1, ..., batchCount.\n\n- Supported precisions in rocBLAS : c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nuplo      [hipblasFillMode_t]\nspecifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'\nHIPBLAS_FILL_MODE_UPPER: The upper triangular part of each A_i is supplied in AP.\nHIPBLAS_FILL_MODE_LOWER: The lower triangular part of each A_i is supplied in AP.\n@param[in]\nn         [int]\nthe number of rows and columns of each matrix A_i, must be at least 0.\n@param[in]\nalpha\ndevice pointer or host pointer to scalar alpha.\n@param[in]\nx         device array of device pointers storing each vector x_i.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of each x_i.\n@param[in]\ny         device array of device pointers storing each vector y_i.\n@param[in]\nincy      [int]\nspecifies the increment for the elements of each y_i.\n@param[inout]\nAP        device array of device pointers storing the packed version of the specified triangular portion of\neach Hermitian matrix A_i of at least size ((n * (n + 1)) / 2). Array is of at least size batchCount.\nif uplo == HIPBLAS_FILL_MODE_UPPER:\nThe upper triangular portion of each Hermitian matrix A_i is supplied.\nThe matrix is compacted so that AP contains the triangular portion column-by-column\nso that:\nAP(0) = A(0,0)\nAP(1) = A(0,1)\nAP(2) = A(1,1), etc.\nEx: (HIPBLAS_FILL_MODE_UPPER; n = 3)\n(1, 0) (2, 1) (4,9)\n(2,-1) (3, 0) (5,3)  -----> [(1,0), (2,1), (3,0), (4,9), (5,3), (6,0)]\n(4,-9) (5,-3) (6,0)\nif uplo == HIPBLAS_FILL_MODE_LOWER:\nThe lower triangular portion of each Hermitian matrix A_i is supplied.\nThe matrix is compacted so that AP contains the triangular portion column-by-column\nso that:\nAP(0) = A(0,0)\nAP(1) = A(1,0)\nAP(2) = A(2,1), etc.\nEx: (HIPBLAS_FILL_MODE_LOWER; n = 3)\n(1, 0) (2, 1) (4,9)\n(2,-1) (3, 0) (5,3)  -----> [(1,0), (2,-1), (4,-9), (3,0), (5,-3), (6,0)]\n(4,-9) (5,-3) (6,0)\nNote that the imaginary part of the diagonal elements are not accessed and are assumed\nto be 0.\n@param[in]\nbatchCount [int]\nnumber of instances in the batch."]
    pub fn hipblasChpr2Batched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        x: *const *const hipblasComplex,
        incx: ::core::ffi::c_int,
        y: *const *const hipblasComplex,
        incy: ::core::ffi::c_int,
        AP: *const *mut hipblasComplex,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhpr2Batched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        y: *const *const hipblasDoubleComplex,
        incy: ::core::ffi::c_int,
        AP: *const *mut hipblasDoubleComplex,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChpr2Batched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipComplex,
        x: *const *const hipComplex,
        incx: ::core::ffi::c_int,
        y: *const *const hipComplex,
        incy: ::core::ffi::c_int,
        AP: *const *mut hipComplex,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhpr2Batched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        x: *const *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        y: *const *const hipDoubleComplex,
        incy: ::core::ffi::c_int,
        AP: *const *mut hipDoubleComplex,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\nhpr2StridedBatched performs the matrix-vector operations\n\nA_i := A_i + alpha*x_i*y_i**H + conj(alpha)*y_i*x_i**H\n\nwhere alpha is a complex scalar, x_i and y_i are vectors, and A_i is an\nn by n symmetric matrix, supplied in packed form, for i = 1, ..., batchCount.\n\n- Supported precisions in rocBLAS : c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nuplo      [hipblasFillMode_t]\nspecifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'\nHIPBLAS_FILL_MODE_UPPER: The upper triangular part of each A_i is supplied in AP.\nHIPBLAS_FILL_MODE_LOWER: The lower triangular part of each A_i is supplied in AP.\n@param[in]\nn         [int]\nthe number of rows and columns of each matrix A_i, must be at least 0.\n@param[in]\nalpha\ndevice pointer or host pointer to scalar alpha.\n@param[in]\nx         device pointer pointing to the first vector (x_1).\n@param[in]\nincx      [int]\nspecifies the increment for the elements of each x_i.\n@param[in]\nstridex  [hipblasStride]\nstride from the start of one vector (x_i) and the next one (x_i+1).\n@param[in]\ny         device pointer pointing to the first vector (y_1).\n@param[in]\nincy      [int]\nspecifies the increment for the elements of each y_i.\n@param[in]\nstridey  [hipblasStride]\nstride from the start of one vector (y_i) and the next one (y_i+1).\n@param[inout]\nAP        device array of device pointers storing the packed version of the specified triangular portion of\neach Hermitian matrix A_i. Points to the first matrix (A_1).\nif uplo == HIPBLAS_FILL_MODE_UPPER:\nThe upper triangular portion of each Hermitian matrix A_i is supplied.\nThe matrix is compacted so that AP contains the triangular portion column-by-column\nso that:\nAP(0) = A(0,0)\nAP(1) = A(0,1)\nAP(2) = A(1,1), etc.\nEx: (HIPBLAS_FILL_MODE_UPPER; n = 3)\n(1, 0) (2, 1) (4,9)\n(2,-1) (3, 0) (5,3)  -----> [(1,0), (2,1), (3,0), (4,9), (5,3), (6,0)]\n(4,-9) (5,-3) (6,0)\nif uplo == HIPBLAS_FILL_MODE_LOWER:\nThe lower triangular portion of each Hermitian matrix A_i is supplied.\nThe matrix is compacted so that AP contains the triangular portion column-by-column\nso that:\nAP(0) = A(0,0)\nAP(1) = A(1,0)\nAP(2) = A(2,1), etc.\nEx: (HIPBLAS_FILL_MODE_LOWER; n = 3)\n(1, 0) (2, 1) (4,9)\n(2,-1) (3, 0) (5,3)  -----> [(1,0), (2,-1), (4,-9), (3,0), (5,-3), (6,0)]\n(4,-9) (5,-3) (6,0)\nNote that the imaginary part of the diagonal elements are not accessed and are assumed\nto be 0.\n@param[in]\nstrideA    [hipblasStride]\nstride from the start of one (A_i) and the next (A_i+1)\n@param[in]\nbatchCount [int]\nnumber of instances in the batch."]
    pub fn hipblasChpr2StridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        x: *const hipblasComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *const hipblasComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        AP: *mut hipblasComplex,
        strideA: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhpr2StridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *const hipblasDoubleComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        AP: *mut hipblasDoubleComplex,
        strideA: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChpr2StridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipComplex,
        x: *const hipComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *const hipComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        AP: *mut hipComplex,
        strideA: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhpr2StridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        x: *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *const hipDoubleComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        AP: *mut hipDoubleComplex,
        strideA: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\nsbmv performs the matrix-vector operation:\n\ny := alpha*A*x + beta*y,\n\nwhere alpha and beta are scalars, x and y are n element vectors and\nA should contain an upper or lower triangular n by n symmetric banded matrix.\n\n- Supported precisions in rocBLAS : s,d\n- Supported precisions in cuBLAS  : s,d\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nuplo      [hipblasFillMode_t]\nspecifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'\nif HIPBLAS_FILL_MODE_UPPER, the lower part of A is not referenced\nif HIPBLAS_FILL_MODE_LOWER, the upper part of A is not referenced\n@param[in]\nn         [int]\n@param[in]\nk         [int]\nspecifies the number of sub- and super-diagonals\n@param[in]\nalpha\nspecifies the scalar alpha\n@param[in]\nAP         pointer storing matrix A on the GPU\n@param[in]\nlda       [int]\nspecifies the leading dimension of matrix A\n@param[in]\nx         pointer storing vector x on the GPU\n@param[in]\nincx      [int]\nspecifies the increment for the elements of x\n@param[in]\nbeta      specifies the scalar beta\n@param[out]\ny         pointer storing vector y on the GPU\n@param[in]\nincy      [int]\nspecifies the increment for the elements of y\n"]
    pub fn hipblasSsbmv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const f32,
        AP: *const f32,
        lda: ::core::ffi::c_int,
        x: *const f32,
        incx: ::core::ffi::c_int,
        beta: *const f32,
        y: *mut f32,
        incy: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsbmv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const f64,
        AP: *const f64,
        lda: ::core::ffi::c_int,
        x: *const f64,
        incx: ::core::ffi::c_int,
        beta: *const f64,
        y: *mut f64,
        incy: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\nsbmvBatched performs the matrix-vector operation:\n\ny_i := alpha*A_i*x_i + beta*y_i,\n\nwhere (A_i, x_i, y_i) is the i-th instance of the batch.\nalpha and beta are scalars, x_i and y_i are vectors and A_i is an\nn by n symmetric banded matrix, for i = 1, ..., batchCount.\nA should contain an upper or lower triangular n by n symmetric banded matrix.\n\n- Supported precisions in rocBLAS : s,d\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue\n@param[in]\nuplo      [hipblasFillMode_t]\nspecifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'\nif HIPBLAS_FILL_MODE_UPPER, the lower part of A is not referenced\nif HIPBLAS_FILL_MODE_LOWER, the upper part of A is not referenced\n@param[in]\nn         [int]\nnumber of rows and columns of each matrix A_i\n@param[in]\nk         [int]\nspecifies the number of sub- and super-diagonals\n@param[in]\nalpha\ndevice pointer or host pointer to scalar alpha\n@param[in]\nAP         device array of device pointers storing each matrix A_i\n@param[in]\nlda       [int]\nspecifies the leading dimension of each matrix A_i\n@param[in]\nx         device array of device pointers storing each vector x_i\n@param[in]\nincx      [int]\nspecifies the increment for the elements of each vector x_i\n@param[in]\nbeta      device pointer or host pointer to scalar beta\n@param[out]\ny         device array of device pointers storing each vector y_i\n@param[in]\nincy      [int]\nspecifies the increment for the elements of each vector y_i\n@param[in]\nbatchCount [int]\nnumber of instances in the batch\n"]
    pub fn hipblasSsbmvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const f32,
        AP: *const *const f32,
        lda: ::core::ffi::c_int,
        x: *const *const f32,
        incx: ::core::ffi::c_int,
        beta: *const f32,
        y: *const *mut f32,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsbmvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const f64,
        AP: *const *const f64,
        lda: ::core::ffi::c_int,
        x: *const *const f64,
        incx: ::core::ffi::c_int,
        beta: *const f64,
        y: *const *mut f64,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\nsbmvStridedBatched performs the matrix-vector operation:\n\ny_i := alpha*A_i*x_i + beta*y_i,\n\nwhere (A_i, x_i, y_i) is the i-th instance of the batch.\nalpha and beta are scalars, x_i and y_i are vectors and A_i is an\nn by n symmetric banded matrix, for i = 1, ..., batchCount.\nA should contain an upper or lower triangular n by n symmetric banded matrix.\n\n- Supported precisions in rocBLAS : s,d\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue\n@param[in]\nuplo      [hipblasFillMode_t]\nspecifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'\nif HIPBLAS_FILL_MODE_UPPER, the lower part of A is not referenced\nif HIPBLAS_FILL_MODE_LOWER, the upper part of A is not referenced\n@param[in]\nn         [int]\nnumber of rows and columns of each matrix A_i\n@param[in]\nk         [int]\nspecifies the number of sub- and super-diagonals\n@param[in]\nalpha\ndevice pointer or host pointer to scalar alpha\n@param[in]\nAP        Device pointer to the first matrix A_1 on the GPU\n@param[in]\nlda       [int]\nspecifies the leading dimension of each matrix A_i\n@param[in]\nstrideA     [hipblasStride]\nstride from the start of one matrix (A_i) and the next one (A_i+1)\n@param[in]\nx         Device pointer to the first vector x_1 on the GPU\n@param[in]\nincx      [int]\nspecifies the increment for the elements of each vector x_i\n@param[in]\nstridex     [hipblasStride]\nstride from the start of one vector (x_i) and the next one (x_i+1).\nThere are no restrictions placed on stridex, however the user should\ntake care to ensure that stridex is of appropriate size.\nThis typically means stridex >= n * incx. stridex should be non zero.\n@param[in]\nbeta      device pointer or host pointer to scalar beta\n@param[out]\ny         Device pointer to the first vector y_1 on the GPU\n@param[in]\nincy      [int]\nspecifies the increment for the elements of each vector y_i\n@param[in]\nstridey     [hipblasStride]\nstride from the start of one vector (y_i) and the next one (y_i+1).\nThere are no restrictions placed on stridey, however the user should\ntake care to ensure that stridey is of appropriate size.\nThis typically means stridey >= n * incy. stridey should be non zero.\n@param[in]\nbatchCount [int]\nnumber of instances in the batch\n"]
    pub fn hipblasSsbmvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const f32,
        AP: *const f32,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *const f32,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        beta: *const f32,
        y: *mut f32,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsbmvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const f64,
        AP: *const f64,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *const f64,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        beta: *const f64,
        y: *mut f64,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\nspmv performs the matrix-vector operation:\n\ny := alpha*A*x + beta*y,\n\nwhere alpha and beta are scalars, x and y are n element vectors and\nA should contain an upper or lower triangular n by n packed symmetric matrix.\n\n- Supported precisions in rocBLAS : s,d\n- Supported precisions in cuBLAS  : s,d\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nuplo      [hipblasFillMode_t]\nspecifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'\nif HIPBLAS_FILL_MODE_UPPER, the lower part of A is not referenced\nif HIPBLAS_FILL_MODE_LOWER, the upper part of A is not referenced\n@param[in]\nn         [int]\n@param[in]\nalpha\nspecifies the scalar alpha\n@param[in]\nAP         pointer storing matrix A on the GPU\n@param[in]\nx         pointer storing vector x on the GPU\n@param[in]\nincx      [int]\nspecifies the increment for the elements of x\n@param[in]\nbeta      specifies the scalar beta\n@param[out]\ny         pointer storing vector y on the GPU\n@param[in]\nincy      [int]\nspecifies the increment for the elements of y\n"]
    pub fn hipblasSspmv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        AP: *const f32,
        x: *const f32,
        incx: ::core::ffi::c_int,
        beta: *const f32,
        y: *mut f32,
        incy: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDspmv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        AP: *const f64,
        x: *const f64,
        incx: ::core::ffi::c_int,
        beta: *const f64,
        y: *mut f64,
        incy: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\nspmvBatched performs the matrix-vector operation:\n\ny_i := alpha*AP_i*x_i + beta*y_i,\n\nwhere (A_i, x_i, y_i) is the i-th instance of the batch.\nalpha and beta are scalars, x_i and y_i are vectors and A_i is an\nn by n symmetric matrix, for i = 1, ..., batchCount.\nA should contain an upper or lower triangular n by n packed symmetric matrix.\n\n- Supported precisions in rocBLAS : s,d\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue\n@param[in]\nuplo      [hipblasFillMode_t]\nspecifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'\nif HIPBLAS_FILL_MODE_UPPER, the lower part of A is not referenced\nif HIPBLAS_FILL_MODE_LOWER, the upper part of A is not referenced\n@param[in]\nn         [int]\nnumber of rows and columns of each matrix A_i\n@param[in]\nalpha\ndevice pointer or host pointer to scalar alpha\n@param[in]\nAP         device array of device pointers storing each matrix A_i\n@param[in]\nx         device array of device pointers storing each vector x_i\n@param[in]\nincx      [int]\nspecifies the increment for the elements of each vector x_i\n@param[in]\nbeta      device pointer or host pointer to scalar beta\n@param[out]\ny         device array of device pointers storing each vector y_i\n@param[in]\nincy      [int]\nspecifies the increment for the elements of each vector y_i\n@param[in]\nbatchCount [int]\nnumber of instances in the batch\n"]
    pub fn hipblasSspmvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        AP: *const *const f32,
        x: *const *const f32,
        incx: ::core::ffi::c_int,
        beta: *const f32,
        y: *const *mut f32,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDspmvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        AP: *const *const f64,
        x: *const *const f64,
        incx: ::core::ffi::c_int,
        beta: *const f64,
        y: *const *mut f64,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\nspmvStridedBatched performs the matrix-vector operation:\n\ny_i := alpha*A_i*x_i + beta*y_i,\n\nwhere (A_i, x_i, y_i) is the i-th instance of the batch.\nalpha and beta are scalars, x_i and y_i are vectors and A_i is an\nn by n symmetric matrix, for i = 1, ..., batchCount.\nA should contain an upper or lower triangular n by n packed symmetric matrix.\n\n- Supported precisions in rocBLAS : s,d\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue\n@param[in]\nuplo      [hipblasFillMode_t]\nspecifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'\nif HIPBLAS_FILL_MODE_UPPER, the lower part of A is not referenced\nif HIPBLAS_FILL_MODE_LOWER, the upper part of A is not referenced\n@param[in]\nn         [int]\nnumber of rows and columns of each matrix A_i\n@param[in]\nalpha\ndevice pointer or host pointer to scalar alpha\n@param[in]\nAP        Device pointer to the first matrix A_1 on the GPU\n@param[in]\nstrideA    [hipblasStride]\nstride from the start of one matrix (A_i) and the next one (A_i+1)\n@param[in]\nx         Device pointer to the first vector x_1 on the GPU\n@param[in]\nincx      [int]\nspecifies the increment for the elements of each vector x_i\n@param[in]\nstridex     [hipblasStride]\nstride from the start of one vector (x_i) and the next one (x_i+1).\nThere are no restrictions placed on stridex, however the user should\ntake care to ensure that stridex is of appropriate size.\nThis typically means stridex >= n * incx. stridex should be non zero.\n@param[in]\nbeta      device pointer or host pointer to scalar beta\n@param[out]\ny         Device pointer to the first vector y_1 on the GPU\n@param[in]\nincy      [int]\nspecifies the increment for the elements of each vector y_i\n@param[in]\nstridey     [hipblasStride]\nstride from the start of one vector (y_i) and the next one (y_i+1).\nThere are no restrictions placed on stridey, however the user should\ntake care to ensure that stridey is of appropriate size.\nThis typically means stridey >= n * incy. stridey should be non zero.\n@param[in]\nbatchCount [int]\nnumber of instances in the batch\n"]
    pub fn hipblasSspmvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        AP: *const f32,
        strideA: hipblasStride,
        x: *const f32,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        beta: *const f32,
        y: *mut f32,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDspmvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        AP: *const f64,
        strideA: hipblasStride,
        x: *const f64,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        beta: *const f64,
        y: *mut f64,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\nspr performs the matrix-vector operations\n\nA := A + alpha*x*x**T\n\nwhere alpha is a scalar, x is a vector, and A is an\nn by n symmetric matrix, supplied in packed form.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : s,d,c,z\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nuplo      [hipblasFillMode_t]\nspecifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'\nHIPBLAS_FILL_MODE_UPPER: The upper triangular part of A is supplied in AP.\nHIPBLAS_FILL_MODE_LOWER: The lower triangular part of A is supplied in AP.\n@param[in]\nn         [int]\nthe number of rows and columns of matrix A, must be at least 0.\n@param[in]\nalpha\ndevice pointer or host pointer to scalar alpha.\n@param[in]\nx         device pointer storing vector x.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of x.\n@param[inout]\nAP        device pointer storing the packed version of the specified triangular portion of\nthe symmetric matrix A. Of at least size ((n * (n + 1)) / 2).\nif uplo == HIPBLAS_FILL_MODE_UPPER:\nThe upper triangular portion of the symmetric matrix A is supplied.\nThe matrix is compacted so that AP contains the triangular portion column-by-column\nso that:\nAP(0) = A(0,0)\nAP(1) = A(0,1)\nAP(2) = A(1,1), etc.\nEx: (HIPBLAS_FILL_MODE_UPPER; n = 4)\n1 2 4 7\n2 3 5 8   -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]\n4 5 6 9\n7 8 9 0\nif uplo == HIPBLAS_FILL_MODE_LOWER:\nThe lower triangular portion of the symmetric matrix A is supplied.\nThe matrix is compacted so that AP contains the triangular portion column-by-column\nso that:\nAP(0) = A(0,0)\nAP(1) = A(1,0)\nAP(2) = A(2,1), etc.\nEx: (HIPBLAS_FILL_MODE_LOWER; n = 4)\n1 2 3 4\n2 5 6 7    -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]\n3 6 8 9\n4 7 9 0"]
    pub fn hipblasSspr(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        x: *const f32,
        incx: ::core::ffi::c_int,
        AP: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDspr(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        x: *const f64,
        incx: ::core::ffi::c_int,
        AP: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCspr(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        x: *const hipblasComplex,
        incx: ::core::ffi::c_int,
        AP: *mut hipblasComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZspr(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        AP: *mut hipblasDoubleComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCspr_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipComplex,
        x: *const hipComplex,
        incx: ::core::ffi::c_int,
        AP: *mut hipComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZspr_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        x: *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        AP: *mut hipDoubleComplex,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\nsprBatched performs the matrix-vector operations\n\nA_i := A_i + alpha*x_i*x_i**T\n\nwhere alpha is a scalar, x_i is a vector, and A_i is an\nn by n symmetric matrix, supplied in packed form, for i = 1, ..., batchCount.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nuplo      [hipblasFillMode_t]\nspecifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'\nHIPBLAS_FILL_MODE_UPPER: The upper triangular part of each A_i is supplied in AP.\nHIPBLAS_FILL_MODE_LOWER: The lower triangular part of each A_i is supplied in AP.\n@param[in]\nn         [int]\nthe number of rows and columns of each matrix A_i, must be at least 0.\n@param[in]\nalpha\ndevice pointer or host pointer to scalar alpha.\n@param[in]\nx         device array of device pointers storing each vector x_i.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of each x_i.\n@param[inout]\nAP        device array of device pointers storing the packed version of the specified triangular portion of\neach symmetric matrix A_i of at least size ((n * (n + 1)) / 2). Array is of at least size batchCount.\nif uplo == HIPBLAS_FILL_MODE_UPPER:\nThe upper triangular portion of each symmetric matrix A_i is supplied.\nThe matrix is compacted so that AP contains the triangular portion column-by-column\nso that:\nAP(0) = A(0,0)\nAP(1) = A(0,1)\nAP(2) = A(1,1), etc.\nEx: (HIPBLAS_FILL_MODE_UPPER; n = 4)\n1 2 4 7\n2 3 5 8   -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]\n4 5 6 9\n7 8 9 0\nif uplo == HIPBLAS_FILL_MODE_LOWER:\nThe lower triangular portion of each symmetric matrix A_i is supplied.\nThe matrix is compacted so that AP contains the triangular portion column-by-column\nso that:\nAP(0) = A(0,0)\nAP(1) = A(1,0)\nAP(2) = A(2,1), etc.\nEx: (HIPBLAS_FILL_MODE_LOWER; n = 4)\n1 2 3 4\n2 5 6 7    -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]\n3 6 8 9\n4 7 9 0\n@param[in]\nbatchCount [int]\nnumber of instances in the batch."]
    pub fn hipblasSsprBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        x: *const *const f32,
        incx: ::core::ffi::c_int,
        AP: *const *mut f32,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsprBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        x: *const *const f64,
        incx: ::core::ffi::c_int,
        AP: *const *mut f64,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsprBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        x: *const *const hipblasComplex,
        incx: ::core::ffi::c_int,
        AP: *const *mut hipblasComplex,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsprBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        AP: *const *mut hipblasDoubleComplex,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsprBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipComplex,
        x: *const *const hipComplex,
        incx: ::core::ffi::c_int,
        AP: *const *mut hipComplex,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsprBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        x: *const *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        AP: *const *mut hipDoubleComplex,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\nsprStridedBatched performs the matrix-vector operations\n\nA_i := A_i + alpha*x_i*x_i**T\n\nwhere alpha is a scalar, x_i is a vector, and A_i is an\nn by n symmetric matrix, supplied in packed form, for i = 1, ..., batchCount.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nuplo      [hipblasFillMode_t]\nspecifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'\nHIPBLAS_FILL_MODE_UPPER: The upper triangular part of each A_i is supplied in AP.\nHIPBLAS_FILL_MODE_LOWER: The lower triangular part of each A_i is supplied in AP.\n@param[in]\nn         [int]\nthe number of rows and columns of each matrix A_i, must be at least 0.\n@param[in]\nalpha\ndevice pointer or host pointer to scalar alpha.\n@param[in]\nx         device pointer pointing to the first vector (x_1).\n@param[in]\nincx      [int]\nspecifies the increment for the elements of each x_i.\n@param[in]\nstridex  [hipblasStride]\nstride from the start of one vector (x_i) and the next one (x_i+1).\n@param[inout]\nAP        device pointer storing the packed version of the specified triangular portion of\neach symmetric matrix A_i. Points to the first A_1.\nif uplo == HIPBLAS_FILL_MODE_UPPER:\nThe upper triangular portion of each symmetric matrix A_i is supplied.\nThe matrix is compacted so that AP contains the triangular portion column-by-column\nso that:\nAP(0) = A(0,0)\nAP(1) = A(0,1)\nAP(2) = A(1,1), etc.\nEx: (HIPBLAS_FILL_MODE_UPPER; n = 4)\n1 2 4 7\n2 3 5 8   -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]\n4 5 6 9\n7 8 9 0\nif uplo == HIPBLAS_FILL_MODE_LOWER:\nThe lower triangular portion of each symmetric matrix A_i is supplied.\nThe matrix is compacted so that AP contains the triangular portion column-by-column\nso that:\nAP(0) = A(0,0)\nAP(1) = A(1,0)\nAP(2) = A(2,1), etc.\nEx: (HIPBLAS_FILL_MODE_LOWER; n = 4)\n1 2 3 4\n2 5 6 7    -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]\n3 6 8 9\n4 7 9 0\n@param[in]\nstrideA    [hipblasStride]\nstride from the start of one (A_i) and the next (A_i+1)\n@param[in]\nbatchCount [int]\nnumber of instances in the batch."]
    pub fn hipblasSsprStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        x: *const f32,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        AP: *mut f32,
        strideA: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsprStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        x: *const f64,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        AP: *mut f64,
        strideA: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsprStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        x: *const hipblasComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        AP: *mut hipblasComplex,
        strideA: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsprStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        AP: *mut hipblasDoubleComplex,
        strideA: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsprStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipComplex,
        x: *const hipComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        AP: *mut hipComplex,
        strideA: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsprStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        x: *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        AP: *mut hipDoubleComplex,
        strideA: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\nspr2 performs the matrix-vector operation\n\nA := A + alpha*x*y**T + alpha*y*x**T\n\nwhere alpha is a scalar, x and y are vectors, and A is an\nn by n symmetric matrix, supplied in packed form.\n\n- Supported precisions in rocBLAS : s,d\n- Supported precisions in cuBLAS  : s,d\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nuplo      [hipblasFillMode_t]\nspecifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'\nHIPBLAS_FILL_MODE_UPPER: The upper triangular part of A is supplied in AP.\nHIPBLAS_FILL_MODE_LOWER: The lower triangular part of A is supplied in AP.\n@param[in]\nn         [int]\nthe number of rows and columns of matrix A, must be at least 0.\n@param[in]\nalpha\ndevice pointer or host pointer to scalar alpha.\n@param[in]\nx         device pointer storing vector x.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of x.\n@param[in]\ny         device pointer storing vector y.\n@param[in]\nincy      [int]\nspecifies the increment for the elements of y.\n@param[inout]\nAP        device pointer storing the packed version of the specified triangular portion of\nthe symmetric matrix A. Of at least size ((n * (n + 1)) / 2).\nif uplo == HIPBLAS_FILL_MODE_UPPER:\nThe upper triangular portion of the symmetric matrix A is supplied.\nThe matrix is compacted so that AP contains the triangular portion column-by-column\nso that:\nAP(0) = A(0,0)\nAP(1) = A(0,1)\nAP(2) = A(1,1), etc.\nEx: (HIPBLAS_FILL_MODE_UPPER; n = 4)\n1 2 4 7\n2 3 5 8   -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]\n4 5 6 9\n7 8 9 0\nif uplo == HIPBLAS_FILL_MODE_LOWER:\nThe lower triangular portion of the symmetric matrix A is supplied.\nThe matrix is compacted so that AP contains the triangular portion column-by-column\nso that:\nAP(0) = A(0,0)\nAP(1) = A(1,0)\nAP(n) = A(2,1), etc.\nEx: (HIPBLAS_FILL_MODE_LOWER; n = 4)\n1 2 3 4\n2 5 6 7    -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]\n3 6 8 9\n4 7 9 0"]
    pub fn hipblasSspr2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        x: *const f32,
        incx: ::core::ffi::c_int,
        y: *const f32,
        incy: ::core::ffi::c_int,
        AP: *mut f32,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDspr2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        x: *const f64,
        incx: ::core::ffi::c_int,
        y: *const f64,
        incy: ::core::ffi::c_int,
        AP: *mut f64,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\nspr2Batched performs the matrix-vector operation\n\nA_i := A_i + alpha*x_i*y_i**T + alpha*y_i*x_i**T\n\nwhere alpha is a scalar, x_i and y_i are vectors, and A_i is an\nn by n symmetric matrix, supplied in packed form, for i = 1, ..., batchCount.\n\n- Supported precisions in rocBLAS : s,d\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nuplo      [hipblasFillMode_t]\nspecifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'\nHIPBLAS_FILL_MODE_UPPER: The upper triangular part of each A_i is supplied in AP.\nHIPBLAS_FILL_MODE_LOWER: The lower triangular part of each A_i is supplied in AP.\n@param[in]\nn         [int]\nthe number of rows and columns of each matrix A_i, must be at least 0.\n@param[in]\nalpha\ndevice pointer or host pointer to scalar alpha.\n@param[in]\nx         device array of device pointers storing each vector x_i.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of each x_i.\n@param[in]\ny         device array of device pointers storing each vector y_i.\n@param[in]\nincy      [int]\nspecifies the increment for the elements of each y_i.\n@param[inout]\nAP        device array of device pointers storing the packed version of the specified triangular portion of\neach symmetric matrix A_i of at least size ((n * (n + 1)) / 2). Array is of at least size batchCount.\nif uplo == HIPBLAS_FILL_MODE_UPPER:\nThe upper triangular portion of each symmetric matrix A_i is supplied.\nThe matrix is compacted so that AP contains the triangular portion column-by-column\nso that:\nAP(0) = A(0,0)\nAP(1) = A(0,1)\nAP(2) = A(1,1), etc.\nEx: (HIPBLAS_FILL_MODE_UPPER; n = 4)\n1 2 4 7\n2 3 5 8   -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]\n4 5 6 9\n7 8 9 0\nif uplo == HIPBLAS_FILL_MODE_LOWER:\nThe lower triangular portion of each symmetric matrix A_i is supplied.\nThe matrix is compacted so that AP contains the triangular portion column-by-column\nso that:\nAP(0) = A(0,0)\nAP(1) = A(1,0)\nAP(n) = A(2,1), etc.\nEx: (HIPBLAS_FILL_MODE_LOWER; n = 4)\n1 2 3 4\n2 5 6 7    -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]\n3 6 8 9\n4 7 9 0\n@param[in]\nbatchCount [int]\nnumber of instances in the batch."]
    pub fn hipblasSspr2Batched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        x: *const *const f32,
        incx: ::core::ffi::c_int,
        y: *const *const f32,
        incy: ::core::ffi::c_int,
        AP: *const *mut f32,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDspr2Batched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        x: *const *const f64,
        incx: ::core::ffi::c_int,
        y: *const *const f64,
        incy: ::core::ffi::c_int,
        AP: *const *mut f64,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\nspr2StridedBatched performs the matrix-vector operation\n\nA_i := A_i + alpha*x_i*y_i**T + alpha*y_i*x_i**T\n\nwhere alpha is a scalar, x_i amd y_i are vectors, and A_i is an\nn by n symmetric matrix, supplied in packed form, for i = 1, ..., batchCount.\n\n- Supported precisions in rocBLAS : s,d\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nuplo      [hipblasFillMode_t]\nspecifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'\nHIPBLAS_FILL_MODE_UPPER: The upper triangular part of each A_i is supplied in AP.\nHIPBLAS_FILL_MODE_LOWER: The lower triangular part of each A_i is supplied in AP.\n@param[in]\nn         [int]\nthe number of rows and columns of each matrix A_i, must be at least 0.\n@param[in]\nalpha\ndevice pointer or host pointer to scalar alpha.\n@param[in]\nx         device pointer pointing to the first vector (x_1).\n@param[in]\nincx      [int]\nspecifies the increment for the elements of each x_i.\n@param[in]\nstridex  [hipblasStride]\nstride from the start of one vector (x_i) and the next one (x_i+1).\n@param[in]\ny         device pointer pointing to the first vector (y_1).\n@param[in]\nincy      [int]\nspecifies the increment for the elements of each y_i.\n@param[in]\nstridey  [hipblasStride]\nstride from the start of one vector (y_i) and the next one (y_i+1).\n@param[inout]\nAP        device pointer storing the packed version of the specified triangular portion of\neach symmetric matrix A_i. Points to the first A_1.\nif uplo == HIPBLAS_FILL_MODE_UPPER:\nThe upper triangular portion of each symmetric matrix A_i is supplied.\nThe matrix is compacted so that AP contains the triangular portion column-by-column\nso that:\nAP(0) = A(0,0)\nAP(1) = A(0,1)\nAP(2) = A(1,1), etc.\nEx: (HIPBLAS_FILL_MODE_UPPER; n = 4)\n1 2 4 7\n2 3 5 8   -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]\n4 5 6 9\n7 8 9 0\nif uplo == HIPBLAS_FILL_MODE_LOWER:\nThe lower triangular portion of each symmetric matrix A_i is supplied.\nThe matrix is compacted so that AP contains the triangular portion column-by-column\nso that:\nAP(0) = A(0,0)\nAP(1) = A(1,0)\nAP(n) = A(2,1), etc.\nEx: (HIPBLAS_FILL_MODE_LOWER; n = 4)\n1 2 3 4\n2 5 6 7    -----> [1, 2, 3, 4, 5, 6, 7, 8, 9, 0]\n3 6 8 9\n4 7 9 0\n@param[in]\nstrideA   [hipblasStride]\nstride from the start of one (A_i) and the next (A_i+1)\n@param[in]\nbatchCount [int]\nnumber of instances in the batch."]
    pub fn hipblasSspr2StridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        x: *const f32,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *const f32,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        AP: *mut f32,
        strideA: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDspr2StridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        x: *const f64,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *const f64,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        AP: *mut f64,
        strideA: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\nsymv performs the matrix-vector operation:\n\ny := alpha*A*x + beta*y,\n\nwhere alpha and beta are scalars, x and y are n element vectors and\nA should contain an upper or lower triangular n by n symmetric matrix.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : s,d,c,z\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nuplo      [hipblasFillMode_t]\nspecifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'\nif HIPBLAS_FILL_MODE_UPPER, the lower part of A is not referenced\nif HIPBLAS_FILL_MODE_LOWER, the upper part of A is not referenced\n@param[in]\nn         [int]\n@param[in]\nalpha\nspecifies the scalar alpha\n@param[in]\nAP         pointer storing matrix A on the GPU\n@param[in]\nlda       [int]\nspecifies the leading dimension of A\n@param[in]\nx         pointer storing vector x on the GPU\n@param[in]\nincx      [int]\nspecifies the increment for the elements of x\n@param[in]\nbeta      specifies the scalar beta\n@param[out]\ny         pointer storing vector y on the GPU\n@param[in]\nincy      [int]\nspecifies the increment for the elements of y\n"]
    pub fn hipblasSsymv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        AP: *const f32,
        lda: ::core::ffi::c_int,
        x: *const f32,
        incx: ::core::ffi::c_int,
        beta: *const f32,
        y: *mut f32,
        incy: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsymv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        AP: *const f64,
        lda: ::core::ffi::c_int,
        x: *const f64,
        incx: ::core::ffi::c_int,
        beta: *const f64,
        y: *mut f64,
        incy: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsymv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: ::core::ffi::c_int,
        x: *const hipblasComplex,
        incx: ::core::ffi::c_int,
        beta: *const hipblasComplex,
        y: *mut hipblasComplex,
        incy: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsymv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        x: *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        beta: *const hipblasDoubleComplex,
        y: *mut hipblasDoubleComplex,
        incy: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsymv_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: ::core::ffi::c_int,
        x: *const hipComplex,
        incx: ::core::ffi::c_int,
        beta: *const hipComplex,
        y: *mut hipComplex,
        incy: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsymv_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        x: *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        beta: *const hipDoubleComplex,
        y: *mut hipDoubleComplex,
        incy: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\nsymvBatched performs the matrix-vector operation:\n\ny_i := alpha*A_i*x_i + beta*y_i,\n\nwhere (A_i, x_i, y_i) is the i-th instance of the batch.\nalpha and beta are scalars, x_i and y_i are vectors and A_i is an\nn by n symmetric matrix, for i = 1, ..., batchCount.\nA a should contain an upper or lower triangular symmetric matrix\nand the opposing triangular part of A is not referenced\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue\n@param[in]\nuplo      [hipblasFillMode_t]\nspecifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'\nif HIPBLAS_FILL_MODE_UPPER, the lower part of A is not referenced\nif HIPBLAS_FILL_MODE_LOWER, the upper part of A is not referenced\n@param[in]\nn         [int]\nnumber of rows and columns of each matrix A_i\n@param[in]\nalpha\ndevice pointer or host pointer to scalar alpha\n@param[in]\nAP        device array of device pointers storing each matrix A_i\n@param[in]\nlda       [int]\nspecifies the leading dimension of each matrix A_i\n@param[in]\nx         device array of device pointers storing each vector x_i\n@param[in]\nincx      [int]\nspecifies the increment for the elements of each vector x_i\n@param[in]\nbeta      device pointer or host pointer to scalar beta\n@param[out]\ny         device array of device pointers storing each vector y_i\n@param[in]\nincy      [int]\nspecifies the increment for the elements of each vector y_i\n@param[in]\nbatchCount [int]\nnumber of instances in the batch\n"]
    pub fn hipblasSsymvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        AP: *const *const f32,
        lda: ::core::ffi::c_int,
        x: *const *const f32,
        incx: ::core::ffi::c_int,
        beta: *const f32,
        y: *const *mut f32,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsymvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        AP: *const *const f64,
        lda: ::core::ffi::c_int,
        x: *const *const f64,
        incx: ::core::ffi::c_int,
        beta: *const f64,
        y: *const *mut f64,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsymvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        AP: *const *const hipblasComplex,
        lda: ::core::ffi::c_int,
        x: *const *const hipblasComplex,
        incx: ::core::ffi::c_int,
        beta: *const hipblasComplex,
        y: *const *mut hipblasComplex,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsymvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        x: *const *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        beta: *const hipblasDoubleComplex,
        y: *const *mut hipblasDoubleComplex,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsymvBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipComplex,
        AP: *const *const hipComplex,
        lda: ::core::ffi::c_int,
        x: *const *const hipComplex,
        incx: ::core::ffi::c_int,
        beta: *const hipComplex,
        y: *const *mut hipComplex,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsymvBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        x: *const *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        beta: *const hipDoubleComplex,
        y: *const *mut hipDoubleComplex,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\nsymvStridedBatched performs the matrix-vector operation:\n\ny_i := alpha*A_i*x_i + beta*y_i,\n\nwhere (A_i, x_i, y_i) is the i-th instance of the batch.\nalpha and beta are scalars, x_i and y_i are vectors and A_i is an\nn by n symmetric matrix, for i = 1, ..., batchCount.\nA a should contain an upper or lower triangular symmetric matrix\nand the opposing triangular part of A is not referenced\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue\n@param[in]\nuplo      [hipblasFillMode_t]\nspecifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'\nif HIPBLAS_FILL_MODE_UPPER, the lower part of A is not referenced\nif HIPBLAS_FILL_MODE_LOWER, the upper part of A is not referenced\n@param[in]\nn         [int]\nnumber of rows and columns of each matrix A_i\n@param[in]\nalpha\ndevice pointer or host pointer to scalar alpha\n@param[in]\nAP         Device pointer to the first matrix A_1 on the GPU\n@param[in]\nlda       [int]\nspecifies the leading dimension of each matrix A_i\n@param[in]\nstrideA     [hipblasStride]\nstride from the start of one matrix (A_i) and the next one (A_i+1)\n@param[in]\nx         Device pointer to the first vector x_1 on the GPU\n@param[in]\nincx      [int]\nspecifies the increment for the elements of each vector x_i\n@param[in]\nstridex     [hipblasStride]\nstride from the start of one vector (x_i) and the next one (x_i+1).\nThere are no restrictions placed on stridex, however the user should\ntake care to ensure that stridex is of appropriate size.\nThis typically means stridex >= n * incx. stridex should be non zero.\n@param[in]\nbeta      device pointer or host pointer to scalar beta\n@param[out]\ny         Device pointer to the first vector y_1 on the GPU\n@param[in]\nincy      [int]\nspecifies the increment for the elements of each vector y_i\n@param[in]\nstridey     [hipblasStride]\nstride from the start of one vector (y_i) and the next one (y_i+1).\nThere are no restrictions placed on stridey, however the user should\ntake care to ensure that stridey is of appropriate size.\nThis typically means stridey >= n * incy. stridey should be non zero.\n@param[in]\nbatchCount [int]\nnumber of instances in the batch\n"]
    pub fn hipblasSsymvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        AP: *const f32,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *const f32,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        beta: *const f32,
        y: *mut f32,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsymvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        AP: *const f64,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *const f64,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        beta: *const f64,
        y: *mut f64,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsymvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *const hipblasComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        beta: *const hipblasComplex,
        y: *mut hipblasComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsymvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        beta: *const hipblasDoubleComplex,
        y: *mut hipblasDoubleComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsymvStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *const hipComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        beta: *const hipComplex,
        y: *mut hipComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsymvStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        beta: *const hipDoubleComplex,
        y: *mut hipDoubleComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\nsyr performs the matrix-vector operations\n\nA := A + alpha*x*x**T\n\nwhere alpha is a scalar, x is a vector, and A is an\nn by n symmetric matrix.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : s,d,c,z\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nuplo      [hipblasFillMode_t]\nspecifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'\nif HIPBLAS_FILL_MODE_UPPER, the lower part of A is not referenced\nif HIPBLAS_FILL_MODE_LOWER, the upper part of A is not referenced\n\n@param[in]\nn         [int]\nthe number of rows and columns of matrix A.\n@param[in]\nalpha\ndevice pointer or host pointer to scalar alpha.\n@param[in]\nx         device pointer storing vector x.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of x.\n@param[inout]\nAP         device pointer storing matrix A.\n@param[in]\nlda       [int]\nspecifies the leading dimension of A.\n"]
    pub fn hipblasSsyr(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        x: *const f32,
        incx: ::core::ffi::c_int,
        AP: *mut f32,
        lda: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsyr(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        x: *const f64,
        incx: ::core::ffi::c_int,
        AP: *mut f64,
        lda: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyr(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        x: *const hipblasComplex,
        incx: ::core::ffi::c_int,
        AP: *mut hipblasComplex,
        lda: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyr(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        AP: *mut hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyr_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipComplex,
        x: *const hipComplex,
        incx: ::core::ffi::c_int,
        AP: *mut hipComplex,
        lda: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyr_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        x: *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        AP: *mut hipDoubleComplex,
        lda: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\nsyrBatched performs a batch of matrix-vector operations\n\nA[i] := A[i] + alpha*x[i]*x[i]**T\n\nwhere alpha is a scalar, x is an array of vectors, and A is an array of\nn by n symmetric matrices, for i = 1 , ... , batchCount.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nuplo      [hipblasFillMode_t]\nspecifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'\nif HIPBLAS_FILL_MODE_UPPER, the lower part of A is not referenced\nif HIPBLAS_FILL_MODE_LOWER, the upper part of A is not referenced\n@param[in]\nn         [int]\nthe number of rows and columns of matrix A.\n@param[in]\nalpha\ndevice pointer or host pointer to scalar alpha.\n@param[in]\nx         device array of device pointers storing each vector x_i.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of each x_i.\n@param[inout]\nAP         device array of device pointers storing each matrix A_i.\n@param[in]\nlda       [int]\nspecifies the leading dimension of each A_i.\n@param[in]\nbatchCount [int]\nnumber of instances in the batch\n"]
    pub fn hipblasSsyrBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        x: *const *const f32,
        incx: ::core::ffi::c_int,
        AP: *const *mut f32,
        lda: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsyrBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        x: *const *const f64,
        incx: ::core::ffi::c_int,
        AP: *const *mut f64,
        lda: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyrBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        x: *const *const hipblasComplex,
        incx: ::core::ffi::c_int,
        AP: *const *mut hipblasComplex,
        lda: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyrBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        AP: *const *mut hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyrBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipComplex,
        x: *const *const hipComplex,
        incx: ::core::ffi::c_int,
        AP: *const *mut hipComplex,
        lda: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyrBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        x: *const *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        AP: *const *mut hipDoubleComplex,
        lda: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\nsyrStridedBatched performs the matrix-vector operations\n\nA[i] := A[i] + alpha*x[i]*x[i]**T\n\nwhere alpha is a scalar, vectors, and A is an array of\nn by n symmetric matrices, for i = 1 , ... , batchCount.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nuplo      [hipblasFillMode_t]\nspecifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'\nif HIPBLAS_FILL_MODE_UPPER, the lower part of A is not referenced\nif HIPBLAS_FILL_MODE_LOWER, the upper part of A is not referenced\n@param[in]\nn         [int]\nthe number of rows and columns of each matrix A.\n@param[in]\nalpha\ndevice pointer or host pointer to scalar alpha.\n@param[in]\nx         device pointer to the first vector x_1.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of each x_i.\n@param[in]\nstridex   [hipblasStride]\nspecifies the pointer increment between vectors (x_i) and (x_i+1).\n@param[inout]\nAP         device pointer to the first matrix A_1.\n@param[in]\nlda       [int]\nspecifies the leading dimension of each A_i.\n@param[in]\nstrideA   [hipblasStride]\nstride from the start of one matrix (A_i) and the next one (A_i+1)\n@param[in]\nbatchCount [int]\nnumber of instances in the batch\n"]
    pub fn hipblasSsyrStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        x: *const f32,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        AP: *mut f32,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsyrStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        x: *const f64,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        AP: *mut f64,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyrStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        x: *const hipblasComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        AP: *mut hipblasComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyrStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        AP: *mut hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyrStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipComplex,
        x: *const hipComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        AP: *mut hipComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyrStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        x: *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        AP: *mut hipDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\nsyr2 performs the matrix-vector operations\n\nA := A + alpha*x*y**T + alpha*y*x**T\n\nwhere alpha is a scalar, x and y are vectors, and A is an\nn by n symmetric matrix.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nuplo      [hipblasFillMode_t]\nspecifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'\nif HIPBLAS_FILL_MODE_UPPER, the lower part of A is not referenced\nif HIPBLAS_FILL_MODE_LOWER, the upper part of A is not referenced\n\n@param[in]\nn         [int]\nthe number of rows and columns of matrix A.\n@param[in]\nalpha\ndevice pointer or host pointer to scalar alpha.\n@param[in]\nx         device pointer storing vector x.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of x.\n@param[in]\ny         device pointer storing vector y.\n@param[in]\nincy      [int]\nspecifies the increment for the elements of y.\n@param[inout]\nAP         device pointer storing matrix A.\n@param[in]\nlda       [int]\nspecifies the leading dimension of A.\n"]
    pub fn hipblasSsyr2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        x: *const f32,
        incx: ::core::ffi::c_int,
        y: *const f32,
        incy: ::core::ffi::c_int,
        AP: *mut f32,
        lda: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsyr2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        x: *const f64,
        incx: ::core::ffi::c_int,
        y: *const f64,
        incy: ::core::ffi::c_int,
        AP: *mut f64,
        lda: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyr2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        x: *const hipblasComplex,
        incx: ::core::ffi::c_int,
        y: *const hipblasComplex,
        incy: ::core::ffi::c_int,
        AP: *mut hipblasComplex,
        lda: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyr2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        y: *const hipblasDoubleComplex,
        incy: ::core::ffi::c_int,
        AP: *mut hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyr2_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipComplex,
        x: *const hipComplex,
        incx: ::core::ffi::c_int,
        y: *const hipComplex,
        incy: ::core::ffi::c_int,
        AP: *mut hipComplex,
        lda: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyr2_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        x: *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        y: *const hipDoubleComplex,
        incy: ::core::ffi::c_int,
        AP: *mut hipDoubleComplex,
        lda: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\nsyr2Batched performs a batch of matrix-vector operations\n\nA[i] := A[i] + alpha*x[i]*y[i]**T + alpha*y[i]*x[i]**T\n\nwhere alpha is a scalar, x[i] and y[i] are vectors, and A[i] is a\nn by n symmetric matrix, for i = 1 , ... , batchCount.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nuplo      [hipblasFillMode_t]\nspecifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'\nif HIPBLAS_FILL_MODE_UPPER, the lower part of A is not referenced\nif HIPBLAS_FILL_MODE_LOWER, the upper part of A is not referenced\n@param[in]\nn         [int]\nthe number of rows and columns of matrix A.\n@param[in]\nalpha\ndevice pointer or host pointer to scalar alpha.\n@param[in]\nx         device array of device pointers storing each vector x_i.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of each x_i.\n@param[in]\ny         device array of device pointers storing each vector y_i.\n@param[in]\nincy      [int]\nspecifies the increment for the elements of each y_i.\n@param[inout]\nAP         device array of device pointers storing each matrix A_i.\n@param[in]\nlda       [int]\nspecifies the leading dimension of each A_i.\n@param[in]\nbatchCount [int]\nnumber of instances in the batch\n"]
    pub fn hipblasSsyr2Batched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        x: *const *const f32,
        incx: ::core::ffi::c_int,
        y: *const *const f32,
        incy: ::core::ffi::c_int,
        AP: *const *mut f32,
        lda: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsyr2Batched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        x: *const *const f64,
        incx: ::core::ffi::c_int,
        y: *const *const f64,
        incy: ::core::ffi::c_int,
        AP: *const *mut f64,
        lda: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyr2Batched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        x: *const *const hipblasComplex,
        incx: ::core::ffi::c_int,
        y: *const *const hipblasComplex,
        incy: ::core::ffi::c_int,
        AP: *const *mut hipblasComplex,
        lda: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyr2Batched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        y: *const *const hipblasDoubleComplex,
        incy: ::core::ffi::c_int,
        AP: *const *mut hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyr2Batched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipComplex,
        x: *const *const hipComplex,
        incx: ::core::ffi::c_int,
        y: *const *const hipComplex,
        incy: ::core::ffi::c_int,
        AP: *const *mut hipComplex,
        lda: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyr2Batched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        x: *const *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        y: *const *const hipDoubleComplex,
        incy: ::core::ffi::c_int,
        AP: *const *mut hipDoubleComplex,
        lda: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\nsyr2StridedBatched the matrix-vector operations\n\nA[i] := A[i] + alpha*x[i]*y[i]**T + alpha*y[i]*x[i]**T\n\nwhere alpha is a scalar, x[i] and y[i] are vectors, and A[i] is a\nn by n symmetric matrices, for i = 1 , ... , batchCount.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nuplo      [hipblasFillMode_t]\nspecifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'\nif HIPBLAS_FILL_MODE_UPPER, the lower part of A is not referenced\nif HIPBLAS_FILL_MODE_LOWER, the upper part of A is not referenced\n@param[in]\nn         [int]\nthe number of rows and columns of each matrix A.\n@param[in]\nalpha\ndevice pointer or host pointer to scalar alpha.\n@param[in]\nx         device pointer to the first vector x_1.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of each x_i.\n@param[in]\nstridex   [hipblasStride]\nspecifies the pointer increment between vectors (x_i) and (x_i+1).\n@param[in]\ny         device pointer to the first vector y_1.\n@param[in]\nincy      [int]\nspecifies the increment for the elements of each y_i.\n@param[in]\nstridey   [hipblasStride]\nspecifies the pointer increment between vectors (y_i) and (y_i+1).\n@param[inout]\nAP         device pointer to the first matrix A_1.\n@param[in]\nlda       [int]\nspecifies the leading dimension of each A_i.\n@param[in]\nstrideA   [hipblasStride]\nstride from the start of one matrix (A_i) and the next one (A_i+1)\n@param[in]\nbatchCount [int]\nnumber of instances in the batch\n"]
    pub fn hipblasSsyr2StridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        x: *const f32,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *const f32,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        AP: *mut f32,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsyr2StridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        x: *const f64,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *const f64,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        AP: *mut f64,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyr2StridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        x: *const hipblasComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *const hipblasComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        AP: *mut hipblasComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyr2StridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        x: *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *const hipblasDoubleComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        AP: *mut hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyr2StridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipComplex,
        x: *const hipComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *const hipComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        AP: *mut hipComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyr2StridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        x: *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *const hipDoubleComplex,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        AP: *mut hipDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\ntbmv performs one of the matrix-vector operations\n\nx := A*x      or\nx := A**T*x   or\nx := A**H*x,\n\nx is a vectors and A is a banded m by m matrix (see description below).\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : s,d,c,z\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nuplo      [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER: A is an upper banded triangular matrix.\nHIPBLAS_FILL_MODE_LOWER: A is a  lower banded triangular matrix.\n@param[in]\ntransA     [hipblasOperation_t]\nindicates whether matrix A is tranposed (conjugated) or not.\n@param[in]\ndiag      [hipblasDiagType_t]\nHIPBLAS_DIAG_UNIT: The main diagonal of A is assumed to consist of only\n1's and is not referenced.\nHIPBLAS_DIAG_NON_UNIT: No assumptions are made of A's main diagonal.\n@param[in]\nm         [int]\nthe number of rows and columns of the matrix represented by A.\n@param[in]\nk         [int]\nif uplo == HIPBLAS_FILL_MODE_UPPER, k specifies the number of super-diagonals\nof the matrix A.\nif uplo == HIPBLAS_FILL_MODE_LOWER, k specifies the number of sub-diagonals\nof the matrix A.\nk must satisfy k > 0 && k < lda.\n@param[in]\nAP         device pointer storing banded triangular matrix A.\nif uplo == HIPBLAS_FILL_MODE_UPPER:\nThe matrix represented is an upper banded triangular matrix\nwith the main diagonal and k super-diagonals, everything\nelse can be assumed to be 0.\nThe matrix is compacted so that the main diagonal resides on the k'th\nrow, the first super diagonal resides on the RHS of the k-1'th row, etc,\nwith the k'th diagonal on the RHS of the 0'th row.\nEx: (HIPBLAS_FILL_MODE_UPPER; m = 5; k = 2)\n1 6 9 0 0              0 0 9 8 7\n0 2 7 8 0              0 6 7 8 9\n0 0 3 8 7     ---->    1 2 3 4 5\n0 0 0 4 9              0 0 0 0 0\n0 0 0 0 5              0 0 0 0 0\nif uplo == HIPBLAS_FILL_MODE_LOWER:\nThe matrix represnted is a lower banded triangular matrix\nwith the main diagonal and k sub-diagonals, everything else can be\nassumed to be 0.\nThe matrix is compacted so that the main diagonal resides on the 0'th row,\nworking up to the k'th diagonal residing on the LHS of the k'th row.\nEx: (HIPBLAS_FILL_MODE_LOWER; m = 5; k = 2)\n1 0 0 0 0              1 2 3 4 5\n6 2 0 0 0              6 7 8 9 0\n9 7 3 0 0     ---->    9 8 7 0 0\n0 8 8 4 0              0 0 0 0 0\n0 0 7 9 5              0 0 0 0 0\n@param[in]\nlda       [int]\nspecifies the leading dimension of A. lda must satisfy lda > k.\n@param[inout]\nx         device pointer storing vector x.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of x.\n"]
    pub fn hipblasStbmv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        AP: *const f32,
        lda: ::core::ffi::c_int,
        x: *mut f32,
        incx: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtbmv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        AP: *const f64,
        lda: ::core::ffi::c_int,
        x: *mut f64,
        incx: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtbmv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        AP: *const hipblasComplex,
        lda: ::core::ffi::c_int,
        x: *mut hipblasComplex,
        incx: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtbmv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        AP: *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        x: *mut hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtbmv_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        AP: *const hipComplex,
        lda: ::core::ffi::c_int,
        x: *mut hipComplex,
        incx: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtbmv_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        AP: *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        x: *mut hipDoubleComplex,
        incx: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\ntbmvBatched performs one of the matrix-vector operations\n\nx_i := A_i*x_i      or\nx_i := A_i**T*x_i   or\nx_i := A_i**H*x_i,\n\nwhere (A_i, x_i) is the i-th instance of the batch.\nx_i is a vector and A_i is an m by m matrix, for i = 1, ..., batchCount.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nuplo      [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER: each A_i is an upper banded triangular matrix.\nHIPBLAS_FILL_MODE_LOWER: each A_i is a  lower banded triangular matrix.\n@param[in]\ntransA     [hipblasOperation_t]\nindicates whether each matrix A_i is tranposed (conjugated) or not.\n@param[in]\ndiag      [hipblasDiagType_t]\nHIPBLAS_DIAG_UNIT: The main diagonal of each A_i is assumed to consist of only\n1's and is not referenced.\nHIPBLAS_DIAG_NON_UNIT: No assumptions are made of each A_i's main diagonal.\n@param[in]\nm         [int]\nthe number of rows and columns of the matrix represented by each A_i.\n@param[in]\nk         [int]\nif uplo == HIPBLAS_FILL_MODE_UPPER, k specifies the number of super-diagonals\nof each matrix A_i.\nif uplo == HIPBLAS_FILL_MODE_LOWER, k specifies the number of sub-diagonals\nof each matrix A_i.\nk must satisfy k > 0 && k < lda.\n@param[in]\nAP         device array of device pointers storing each banded triangular matrix A_i.\nif uplo == HIPBLAS_FILL_MODE_UPPER:\nThe matrix represented is an upper banded triangular matrix\nwith the main diagonal and k super-diagonals, everything\nelse can be assumed to be 0.\nThe matrix is compacted so that the main diagonal resides on the k'th\nrow, the first super diagonal resides on the RHS of the k-1'th row, etc,\nwith the k'th diagonal on the RHS of the 0'th row.\nEx: (HIPBLAS_FILL_MODE_UPPER; m = 5; k = 2)\n1 6 9 0 0              0 0 9 8 7\n0 2 7 8 0              0 6 7 8 9\n0 0 3 8 7     ---->    1 2 3 4 5\n0 0 0 4 9              0 0 0 0 0\n0 0 0 0 5              0 0 0 0 0\nif uplo == HIPBLAS_FILL_MODE_LOWER:\nThe matrix represnted is a lower banded triangular matrix\nwith the main diagonal and k sub-diagonals, everything else can be\nassumed to be 0.\nThe matrix is compacted so that the main diagonal resides on the 0'th row,\nworking up to the k'th diagonal residing on the LHS of the k'th row.\nEx: (HIPBLAS_FILL_MODE_LOWER; m = 5; k = 2)\n1 0 0 0 0              1 2 3 4 5\n6 2 0 0 0              6 7 8 9 0\n9 7 3 0 0     ---->    9 8 7 0 0\n0 8 8 4 0              0 0 0 0 0\n0 0 7 9 5              0 0 0 0 0\n@param[in]\nlda       [int]\nspecifies the leading dimension of each A_i. lda must satisfy lda > k.\n@param[inout]\nx         device array of device pointer storing each vector x_i.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of each x_i.\n@param[in]\nbatchCount [int]\nnumber of instances in the batch.\n"]
    pub fn hipblasStbmvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        AP: *const *const f32,
        lda: ::core::ffi::c_int,
        x: *const *mut f32,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtbmvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        AP: *const *const f64,
        lda: ::core::ffi::c_int,
        x: *const *mut f64,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtbmvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        AP: *const *const hipblasComplex,
        lda: ::core::ffi::c_int,
        x: *const *mut hipblasComplex,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtbmvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        AP: *const *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        x: *const *mut hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtbmvBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        AP: *const *const hipComplex,
        lda: ::core::ffi::c_int,
        x: *const *mut hipComplex,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtbmvBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        AP: *const *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        x: *const *mut hipDoubleComplex,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\ntbmvStridedBatched performs one of the matrix-vector operations\n\nx_i := A_i*x_i      or\nx_i := A_i**T*x_i   or\nx_i := A_i**H*x_i,\n\nwhere (A_i, x_i) is the i-th instance of the batch.\nx_i is a vector and A_i is an m by m matrix, for i = 1, ..., batchCount.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nuplo      [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER: each A_i is an upper banded triangular matrix.\nHIPBLAS_FILL_MODE_LOWER: each A_i is a  lower banded triangular matrix.\n@param[in]\ntransA     [hipblasOperation_t]\nindicates whether each matrix A_i is tranposed (conjugated) or not.\n@param[in]\ndiag      [hipblasDiagType_t]\nHIPBLAS_DIAG_UNIT: The main diagonal of each A_i is assumed to consist of only\n1's and is not referenced.\nHIPBLAS_DIAG_NON_UNIT: No assumptions are made of each A_i's main diagonal.\n@param[in]\nm         [int]\nthe number of rows and columns of the matrix represented by each A_i.\n@param[in]\nk         [int]\nif uplo == HIPBLAS_FILL_MODE_UPPER, k specifies the number of super-diagonals\nof each matrix A_i.\nif uplo == HIPBLAS_FILL_MODE_LOWER, k specifies the number of sub-diagonals\nof each matrix A_i.\nk must satisfy k > 0 && k < lda.\n@param[in]\nAP         device array to the first matrix A_i of the batch. Stores each banded triangular matrix A_i.\nif uplo == HIPBLAS_FILL_MODE_UPPER:\nThe matrix represented is an upper banded triangular matrix\nwith the main diagonal and k super-diagonals, everything\nelse can be assumed to be 0.\nThe matrix is compacted so that the main diagonal resides on the k'th\nrow, the first super diagonal resides on the RHS of the k-1'th row, etc,\nwith the k'th diagonal on the RHS of the 0'th row.\nEx: (HIPBLAS_FILL_MODE_UPPER; m = 5; k = 2)\n1 6 9 0 0              0 0 9 8 7\n0 2 7 8 0              0 6 7 8 9\n0 0 3 8 7     ---->    1 2 3 4 5\n0 0 0 4 9              0 0 0 0 0\n0 0 0 0 5              0 0 0 0 0\nif uplo == HIPBLAS_FILL_MODE_LOWER:\nThe matrix represnted is a lower banded triangular matrix\nwith the main diagonal and k sub-diagonals, everything else can be\nassumed to be 0.\nThe matrix is compacted so that the main diagonal resides on the 0'th row,\nworking up to the k'th diagonal residing on the LHS of the k'th row.\nEx: (HIPBLAS_FILL_MODE_LOWER; m = 5; k = 2)\n1 0 0 0 0              1 2 3 4 5\n6 2 0 0 0              6 7 8 9 0\n9 7 3 0 0     ---->    9 8 7 0 0\n0 8 8 4 0              0 0 0 0 0\n0 0 7 9 5              0 0 0 0 0\n@param[in]\nlda       [int]\nspecifies the leading dimension of each A_i. lda must satisfy lda > k.\n@param[in]\nstrideA  [hipblasStride]\nstride from the start of one A_i matrix to the next A_(i + 1).\n@param[inout]\nx         device array to the first vector x_i of the batch.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of each x_i.\n@param[in]\nstridex  [hipblasStride]\nstride from the start of one x_i matrix to the next x_(i + 1).\n@param[in]\nbatchCount [int]\nnumber of instances in the batch.\n"]
    pub fn hipblasStbmvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        AP: *const f32,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *mut f32,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtbmvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        AP: *const f64,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *mut f64,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtbmvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        AP: *const hipblasComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *mut hipblasComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtbmvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        AP: *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *mut hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtbmvStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        AP: *const hipComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *mut hipComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtbmvStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        AP: *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *mut hipDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\ntbsv solves\n\nA*x = b or A**T*x = b or A**H*x = b,\n\nwhere x and b are vectors and A is a banded triangular matrix.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : s,d,c,z\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n\n@param[in]\nuplo    [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER:  A is an upper triangular matrix.\nHIPBLAS_FILL_MODE_LOWER:  A is a  lower triangular matrix.\n\n@param[in]\ntransA     [hipblasOperation_t]\nHIPBLAS_OP_N: Solves A*x = b\nHIPBLAS_OP_T: Solves A**T*x = b\nHIPBLAS_OP_C: Solves A**H*x = b\n\n@param[in]\ndiag    [hipblasDiagType_t]\nHIPBLAS_DIAG_UNIT:     A is assumed to be unit triangular (i.e. the diagonal elements\nof A are not used in computations).\nHIPBLAS_DIAG_NON_UNIT: A is not assumed to be unit triangular.\n\n@param[in]\nn         [int]\nn specifies the number of rows of b. n >= 0.\n@param[in]\nk         [int]\nif(uplo == HIPBLAS_FILL_MODE_UPPER)\nk specifies the number of super-diagonals of A.\nif(uplo == HIPBLAS_FILL_MODE_LOWER)\nk specifies the number of sub-diagonals of A.\nk >= 0.\n\n@param[in]\nAP         device pointer storing the matrix A in banded format.\n\n@param[in]\nlda       [int]\nspecifies the leading dimension of A.\nlda >= (k + 1).\n\n@param[inout]\nx         device pointer storing input vector b. Overwritten by the output vector x.\n\n@param[in]\nincx      [int]\nspecifies the increment for the elements of x.\n"]
    pub fn hipblasStbsv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        AP: *const f32,
        lda: ::core::ffi::c_int,
        x: *mut f32,
        incx: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtbsv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        AP: *const f64,
        lda: ::core::ffi::c_int,
        x: *mut f64,
        incx: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtbsv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        AP: *const hipblasComplex,
        lda: ::core::ffi::c_int,
        x: *mut hipblasComplex,
        incx: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtbsv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        AP: *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        x: *mut hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtbsv_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        AP: *const hipComplex,
        lda: ::core::ffi::c_int,
        x: *mut hipComplex,
        incx: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtbsv_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        AP: *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        x: *mut hipDoubleComplex,
        incx: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\ntbsvBatched solves\n\nA_i*x_i = b_i or A_i**T*x_i = b_i or A_i**H*x_i = b_i,\n\nwhere x_i and b_i are vectors and A_i is a banded triangular matrix,\nfor i = [1, batchCount].\n\nThe input vectors b_i are overwritten by the output vectors x_i.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n\n@param[in]\nuplo    [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER:  A_i is an upper triangular matrix.\nHIPBLAS_FILL_MODE_LOWER:  A_i is a  lower triangular matrix.\n\n@param[in]\ntransA     [hipblasOperation_t]\nHIPBLAS_OP_N: Solves A_i*x_i = b_i\nHIPBLAS_OP_T: Solves A_i**T*x_i = b_i\nHIPBLAS_OP_C: Solves A_i**H*x_i = b_i\n\n@param[in]\ndiag    [hipblasDiagType_t]\nHIPBLAS_DIAG_UNIT:     each A_i is assumed to be unit triangular (i.e. the diagonal elements\nof each A_i are not used in computations).\nHIPBLAS_DIAG_NON_UNIT: each A_i is not assumed to be unit triangular.\n\n@param[in]\nn         [int]\nn specifies the number of rows of each b_i. n >= 0.\n@param[in]\nk         [int]\nif(uplo == HIPBLAS_FILL_MODE_UPPER)\nk specifies the number of super-diagonals of each A_i.\nif(uplo == HIPBLAS_FILL_MODE_LOWER)\nk specifies the number of sub-diagonals of each A_i.\nk >= 0.\n\n@param[in]\nAP         device vector of device pointers storing each matrix A_i in banded format.\n\n@param[in]\nlda       [int]\nspecifies the leading dimension of each A_i.\nlda >= (k + 1).\n\n@param[inout]\nx         device vector of device pointers storing each input vector b_i. Overwritten by each output\nvector x_i.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of each x_i.\n@param[in]\nbatchCount [int]\nnumber of instances in the batch.\n"]
    pub fn hipblasStbsvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        AP: *const *const f32,
        lda: ::core::ffi::c_int,
        x: *const *mut f32,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtbsvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        AP: *const *const f64,
        lda: ::core::ffi::c_int,
        x: *const *mut f64,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtbsvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        AP: *const *const hipblasComplex,
        lda: ::core::ffi::c_int,
        x: *const *mut hipblasComplex,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtbsvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        AP: *const *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        x: *const *mut hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtbsvBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        AP: *const *const hipComplex,
        lda: ::core::ffi::c_int,
        x: *const *mut hipComplex,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtbsvBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        AP: *const *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        x: *const *mut hipDoubleComplex,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\ntbsvStridedBatched solves\n\nA_i*x_i = b_i or A_i**T*x_i = b_i or A_i**H*x_i = b_i,\n\nwhere x_i and b_i are vectors and A_i is a banded triangular matrix,\nfor i = [1, batchCount].\n\nThe input vectors b_i are overwritten by the output vectors x_i.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n\n@param[in]\nuplo    [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER:  A_i is an upper triangular matrix.\nHIPBLAS_FILL_MODE_LOWER:  A_i is a  lower triangular matrix.\n\n@param[in]\ntransA     [hipblasOperation_t]\nHIPBLAS_OP_N: Solves A_i*x_i = b_i\nHIPBLAS_OP_T: Solves A_i**T*x_i = b_i\nHIPBLAS_OP_C: Solves A_i**H*x_i = b_i\n\n@param[in]\ndiag    [hipblasDiagType_t]\nHIPBLAS_DIAG_UNIT:     each A_i is assumed to be unit triangular (i.e. the diagonal elements\nof each A_i are not used in computations).\nHIPBLAS_DIAG_NON_UNIT: each A_i is not assumed to be unit triangular.\n\n@param[in]\nn         [int]\nn specifies the number of rows of each b_i. n >= 0.\n@param[in]\nk         [int]\nif(uplo == HIPBLAS_FILL_MODE_UPPER)\nk specifies the number of super-diagonals of each A_i.\nif(uplo == HIPBLAS_FILL_MODE_LOWER)\nk specifies the number of sub-diagonals of each A_i.\nk >= 0.\n\n@param[in]\nAP         device pointer pointing to the first banded matrix A_1.\n\n@param[in]\nlda       [int]\nspecifies the leading dimension of each A_i.\nlda >= (k + 1).\n@param[in]\nstrideA  [hipblasStride]\nspecifies the distance between the start of one matrix (A_i) and the next (A_i+1).\n\n@param[inout]\nx         device pointer pointing to the first input vector b_1. Overwritten by output vectors x.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of each x_i.\n@param[in]\nstridex  [hipblasStride]\nspecifies the distance between the start of one vector (x_i) and the next (x_i+1).\n@param[in]\nbatchCount [int]\nnumber of instances in the batch.\n"]
    pub fn hipblasStbsvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        AP: *const f32,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *mut f32,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtbsvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        AP: *const f64,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *mut f64,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtbsvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        AP: *const hipblasComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *mut hipblasComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtbsvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        AP: *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *mut hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtbsvStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        AP: *const hipComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *mut hipComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtbsvStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        AP: *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *mut hipDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\ntpmv performs one of the matrix-vector operations\n\nx = A*x or x = A**T*x,\n\nwhere x is an n element vector and A is an n by n unit, or non-unit, upper or lower triangular matrix, supplied in the pack form.\n\nThe vector x is overwritten.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : s,d,c,z\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n\n@param[in]\nuplo    [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER:  A is an upper triangular matrix.\nHIPBLAS_FILL_MODE_LOWER:  A is a  lower triangular matrix.\n\n@param[in]\ntransA     [hipblasOperation_t]\n\n@param[in]\ndiag    [hipblasDiagType_t]\nHIPBLAS_DIAG_UNIT:     A is assumed to be unit triangular.\nHIPBLAS_DIAG_NON_UNIT:  A is not assumed to be unit triangular.\n\n@param[in]\nm       [int]\nm specifies the number of rows of A. m >= 0.\n\n@param[in]\nAP       device pointer storing matrix A,\nof dimension at least ( m * ( m + 1 ) / 2 ).\nBefore entry with uplo = HIPBLAS_FILL_MODE_UPPER, the array A\nmust contain the upper triangular matrix packed sequentially,\ncolumn by column, so that A[0] contains a_{0,0}, A[1] and A[2] contain\na_{0,1} and a_{1, 1} respectively, and so on.\nBefore entry with uplo = HIPBLAS_FILL_MODE_LOWER, the array A\nmust contain the lower triangular matrix packed sequentially,\ncolumn by column, so that A[0] contains a_{0,0}, A[1] and A[2] contain\na_{1,0} and a_{2,0} respectively, and so on.\nNote that when DIAG = HIPBLAS_DIAG_UNIT, the diagonal elements of A are\nnot referenced, but are assumed to be unity.\n\n@param[in]\nx       device pointer storing vector x.\n\n@param[in]\nincx    [int]\nspecifies the increment for the elements of x. incx must not be zero.\n"]
    pub fn hipblasStpmv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        AP: *const f32,
        x: *mut f32,
        incx: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtpmv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        AP: *const f64,
        x: *mut f64,
        incx: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtpmv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        AP: *const hipblasComplex,
        x: *mut hipblasComplex,
        incx: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtpmv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        AP: *const hipblasDoubleComplex,
        x: *mut hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtpmv_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        AP: *const hipComplex,
        x: *mut hipComplex,
        incx: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtpmv_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        AP: *const hipDoubleComplex,
        x: *mut hipDoubleComplex,
        incx: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\ntpmvBatched performs one of the matrix-vector operations\n\nx_i = A_i*x_i or x_i = A**T*x_i, 0 \\le i < batchCount\n\nwhere x_i is an n element vector and A_i is an n by n (unit, or non-unit, upper or lower triangular matrix)\n\nThe vectors x_i are overwritten.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n\n@param[in]\nuplo    [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER:  A_i is an upper triangular matrix.\nHIPBLAS_FILL_MODE_LOWER:  A_i is a  lower triangular matrix.\n\n@param[in]\ntransA     [hipblasOperation_t]\n\n@param[in]\ndiag    [hipblasDiagType_t]\nHIPBLAS_DIAG_UNIT:     A_i is assumed to be unit triangular.\nHIPBLAS_DIAG_NON_UNIT:  A_i is not assumed to be unit triangular.\n\n@param[in]\nm         [int]\nm specifies the number of rows of matrices A_i. m >= 0.\n\n@param[in]\nAP         device pointer storing pointer of matrices A_i,\nof dimension ( lda, m )\n\n@param[in]\nx         device pointer storing vectors x_i.\n\n@param[in]\nincx      [int]\nspecifies the increment for the elements of vectors x_i.\n\n@param[in]\nbatchCount [int]\nThe number of batched matrices/vectors.\n\n"]
    pub fn hipblasStpmvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        AP: *const *const f32,
        x: *const *mut f32,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtpmvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        AP: *const *const f64,
        x: *const *mut f64,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtpmvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        AP: *const *const hipblasComplex,
        x: *const *mut hipblasComplex,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtpmvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        AP: *const *const hipblasDoubleComplex,
        x: *const *mut hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtpmvBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        AP: *const *const hipComplex,
        x: *const *mut hipComplex,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtpmvBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        AP: *const *const hipDoubleComplex,
        x: *const *mut hipDoubleComplex,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\ntpmvStridedBatched performs one of the matrix-vector operations\n\nx_i = A_i*x_i or x_i = A**T*x_i, 0 \\le i < batchCount\n\nwhere x_i is an n element vector and A_i is an n by n (unit, or non-unit, upper or lower triangular matrix)\nwith strides specifying how to retrieve $x_i$ (resp. $A_i$) from $x_{i-1}$ (resp. $A_i$).\n\nThe vectors x_i are overwritten.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n\n@param[in]\nuplo    [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER:  A_i is an upper triangular matrix.\nHIPBLAS_FILL_MODE_LOWER:  A_i is a  lower triangular matrix.\n\n@param[in]\ntransA     [hipblasOperation_t]\n\n@param[in]\ndiag    [hipblasDiagType_t]\nHIPBLAS_DIAG_UNIT:     A_i is assumed to be unit triangular.\nHIPBLAS_DIAG_NON_UNIT:  A_i is not assumed to be unit triangular.\n\n@param[in]\nm         [int]\nm specifies the number of rows of matrices A_i. m >= 0.\n\n@param[in]\nAP         device pointer of the matrix A_0,\nof dimension ( lda, m )\n\n@param[in]\nstrideA  [hipblasStride]\nstride from the start of one A_i matrix to the next A_{i + 1}\n\n@param[in]\nx         device pointer storing the vector x_0.\n\n@param[in]\nincx      [int]\nspecifies the increment for the elements of one vector x.\n\n@param[in]\nstridex  [hipblasStride]\nstride from the start of one x_i vector to the next x_{i + 1}\n\n@param[in]\nbatchCount [int]\nThe number of batched matrices/vectors.\n\n"]
    pub fn hipblasStpmvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        AP: *const f32,
        strideA: hipblasStride,
        x: *mut f32,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtpmvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        AP: *const f64,
        strideA: hipblasStride,
        x: *mut f64,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtpmvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        AP: *const hipblasComplex,
        strideA: hipblasStride,
        x: *mut hipblasComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtpmvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        AP: *const hipblasDoubleComplex,
        strideA: hipblasStride,
        x: *mut hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtpmvStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        AP: *const hipComplex,
        strideA: hipblasStride,
        x: *mut hipComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtpmvStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        AP: *const hipDoubleComplex,
        strideA: hipblasStride,
        x: *mut hipDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\ntpsv solves\n\nA*x = b or A**T*x = b, or A**H*x = b,\n\nwhere x and b are vectors and A is a triangular matrix stored in the packed format.\n\nThe input vector b is overwritten by the output vector x.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : s,d,c,z\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n\n@param[in]\nuplo    [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER:  A is an upper triangular matrix.\nHIPBLAS_FILL_MODE_LOWER:  A is a  lower triangular matrix.\n\n@param[in]\ntransA  [hipblasOperation_t]\nHIPBLAS_OP_N: Solves A*x = b\nHIPBLAS_OP_T: Solves A**T*x = b\nHIPBLAS_OP_C: Solves A**H*x = b\n\n@param[in]\ndiag    [hipblasDiagType_t]\nHIPBLAS_DIAG_UNIT:     A is assumed to be unit triangular (i.e. the diagonal elements\nof A are not used in computations).\nHIPBLAS_DIAG_NON_UNIT: A is not assumed to be unit triangular.\n\n@param[in]\nm         [int]\nm specifies the number of rows of b. m >= 0.\n\n@param[in]\nAP        device pointer storing the packed version of matrix A,\nof dimension >= (n * (n + 1) / 2)\n\n@param[inout]\nx         device pointer storing vector b on input, overwritten by x on output.\n\n@param[in]\nincx      [int]\nspecifies the increment for the elements of x.\n"]
    pub fn hipblasStpsv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        AP: *const f32,
        x: *mut f32,
        incx: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtpsv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        AP: *const f64,
        x: *mut f64,
        incx: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtpsv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        AP: *const hipblasComplex,
        x: *mut hipblasComplex,
        incx: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtpsv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        AP: *const hipblasDoubleComplex,
        x: *mut hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtpsv_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        AP: *const hipComplex,
        x: *mut hipComplex,
        incx: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtpsv_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        AP: *const hipDoubleComplex,
        x: *mut hipDoubleComplex,
        incx: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\ntpsvBatched solves\n\nA_i*x_i = b_i or A_i**T*x_i = b_i, or A_i**H*x_i = b_i,\n\nwhere x_i and b_i are vectors and A_i is a triangular matrix stored in the packed format,\nfor i in [1, batchCount].\n\nThe input vectors b_i are overwritten by the output vectors x_i.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n\n@param[in]\nuplo    [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER:  each A_i is an upper triangular matrix.\nHIPBLAS_FILL_MODE_LOWER:  each A_i is a  lower triangular matrix.\n\n@param[in]\ntransA  [hipblasOperation_t]\nHIPBLAS_OP_N: Solves A*x = b\nHIPBLAS_OP_T: Solves A**T*x = b\nHIPBLAS_OP_C: Solves A**H*x = b\n\n@param[in]\ndiag    [hipblasDiagType_t]\nHIPBLAS_DIAG_UNIT:     each A_i is assumed to be unit triangular (i.e. the diagonal elements\nof each A_i are not used in computations).\nHIPBLAS_DIAG_NON_UNIT: each A_i is not assumed to be unit triangular.\n\n@param[in]\nm         [int]\nm specifies the number of rows of each b_i. m >= 0.\n\n@param[in]\nAP        device array of device pointers storing the packed versions of each matrix A_i,\nof dimension >= (n * (n + 1) / 2)\n\n@param[inout]\nx         device array of device pointers storing each input vector b_i, overwritten by x_i on output.\n\n@param[in]\nincx      [int]\nspecifies the increment for the elements of each x_i.\n@param[in]\nbatchCount [int]\nspecifies the number of instances in the batch.\n"]
    pub fn hipblasStpsvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        AP: *const *const f32,
        x: *const *mut f32,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtpsvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        AP: *const *const f64,
        x: *const *mut f64,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtpsvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        AP: *const *const hipblasComplex,
        x: *const *mut hipblasComplex,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtpsvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        AP: *const *const hipblasDoubleComplex,
        x: *const *mut hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtpsvBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        AP: *const *const hipComplex,
        x: *const *mut hipComplex,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtpsvBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        AP: *const *const hipDoubleComplex,
        x: *const *mut hipDoubleComplex,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\ntpsvStridedBatched solves\n\nA_i*x_i = b_i or A_i**T*x_i = b_i, or A_i**H*x_i = b_i,\n\nwhere x_i and b_i are vectors and A_i is a triangular matrix stored in the packed format,\nfor i in [1, batchCount].\n\nThe input vectors b_i are overwritten by the output vectors x_i.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n\n@param[in]\nuplo    [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER:  each A_i is an upper triangular matrix.\nHIPBLAS_FILL_MODE_LOWER:  each A_i is a  lower triangular matrix.\n\n@param[in]\ntransA  [hipblasOperation_t]\nHIPBLAS_OP_N: Solves A*x = b\nHIPBLAS_OP_T: Solves A**T*x = b\nHIPBLAS_OP_C: Solves A**H*x = b\n\n@param[in]\ndiag    [hipblasDiagType_t]\nHIPBLAS_DIAG_UNIT:     each A_i is assumed to be unit triangular (i.e. the diagonal elements\nof each A_i are not used in computations).\nHIPBLAS_DIAG_NON_UNIT: each A_i is not assumed to be unit triangular.\n\n@param[in]\nm         [int]\nm specifies the number of rows of each b_i. m >= 0.\n\n@param[in]\nAP        device pointer pointing to the first packed matrix A_1,\nof dimension >= (n * (n + 1) / 2)\n\n@param[in]\nstrideA  [hipblasStride]\nstride from the beginning of one packed matrix (AP_i) and the next (AP_i+1).\n\n@param[inout]\nx         device pointer pointing to the first input vector b_1. Overwritten by each x_i on output.\n\n@param[in]\nincx      [int]\nspecifies the increment for the elements of each x_i.\n@param[in]\nstridex  [hipblasStride]\nstride from the beginning of one vector (x_i) and the next (x_i+1).\n@param[in]\nbatchCount [int]\nspecifies the number of instances in the batch.\n"]
    pub fn hipblasStpsvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        AP: *const f32,
        strideA: hipblasStride,
        x: *mut f32,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtpsvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        AP: *const f64,
        strideA: hipblasStride,
        x: *mut f64,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtpsvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        AP: *const hipblasComplex,
        strideA: hipblasStride,
        x: *mut hipblasComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtpsvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        AP: *const hipblasDoubleComplex,
        strideA: hipblasStride,
        x: *mut hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtpsvStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        AP: *const hipComplex,
        strideA: hipblasStride,
        x: *mut hipComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtpsvStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        AP: *const hipDoubleComplex,
        strideA: hipblasStride,
        x: *mut hipDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\ntrmv performs one of the matrix-vector operations\n\nx = A*x or x = A**T*x,\n\nwhere x is an n element vector and A is an n by n unit, or non-unit, upper or lower triangular matrix.\n\nThe vector x is overwritten.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : s,d,c,z\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n\n@param[in]\nuplo    [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER:  A is an upper triangular matrix.\nHIPBLAS_FILL_MODE_LOWER:  A is a  lower triangular matrix.\n\n@param[in]\ntransA     [hipblasOperation_t]\n\n@param[in]\ndiag    [hipblasDiagType_t]\nHIPBLAS_DIAG_UNIT:     A is assumed to be unit triangular.\nHIPBLAS_DIAG_NON_UNIT:  A is not assumed to be unit triangular.\n\n@param[in]\nm         [int]\nm specifies the number of rows of A. m >= 0.\n\n@param[in]\nAP        device pointer storing matrix A,\nof dimension ( lda, m )\n\n@param[in]\nlda       [int]\nspecifies the leading dimension of A.\nlda = max( 1, m ).\n\n@param[in]\nx         device pointer storing vector x.\n\n@param[in]\nincx      [int]\nspecifies the increment for the elements of x.\n"]
    pub fn hipblasStrmv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        AP: *const f32,
        lda: ::core::ffi::c_int,
        x: *mut f32,
        incx: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtrmv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        AP: *const f64,
        lda: ::core::ffi::c_int,
        x: *mut f64,
        incx: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrmv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        AP: *const hipblasComplex,
        lda: ::core::ffi::c_int,
        x: *mut hipblasComplex,
        incx: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrmv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        AP: *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        x: *mut hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrmv_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        AP: *const hipComplex,
        lda: ::core::ffi::c_int,
        x: *mut hipComplex,
        incx: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrmv_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        AP: *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        x: *mut hipDoubleComplex,
        incx: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\ntrmvBatched performs one of the matrix-vector operations\n\nx_i = A_i*x_i or x_i = A**T*x_i, 0 \\le i < batchCount\n\nwhere x_i is an n element vector and A_i is an n by n (unit, or non-unit, upper or lower triangular matrix)\n\nThe vectors x_i are overwritten.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n\n@param[in]\nuplo    [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER:  A_i is an upper triangular matrix.\nHIPBLAS_FILL_MODE_LOWER:  A_i is a  lower triangular matrix.\n\n@param[in]\ntransA     [hipblasOperation_t]\n\n@param[in]\ndiag    [hipblasDiagType_t]\nHIPBLAS_DIAG_UNIT:     A_i is assumed to be unit triangular.\nHIPBLAS_DIAG_NON_UNIT:  A_i is not assumed to be unit triangular.\n\n@param[in]\nm         [int]\nm specifies the number of rows of matrices A_i. m >= 0.\n\n@param[in]\nAP        device pointer storing pointer of matrices A_i,\nof dimension ( lda, m )\n\n@param[in]\nlda       [int]\nspecifies the leading dimension of A_i.\nlda >= max( 1, m ).\n\n@param[in]\nx         device pointer storing vectors x_i.\n\n@param[in]\nincx      [int]\nspecifies the increment for the elements of vectors x_i.\n\n@param[in]\nbatchCount [int]\nThe number of batched matrices/vectors.\n\n"]
    pub fn hipblasStrmvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        AP: *const *const f32,
        lda: ::core::ffi::c_int,
        x: *const *mut f32,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtrmvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        AP: *const *const f64,
        lda: ::core::ffi::c_int,
        x: *const *mut f64,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrmvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        AP: *const *const hipblasComplex,
        lda: ::core::ffi::c_int,
        x: *const *mut hipblasComplex,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrmvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        AP: *const *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        x: *const *mut hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrmvBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        AP: *const *const hipComplex,
        lda: ::core::ffi::c_int,
        x: *const *mut hipComplex,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrmvBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        AP: *const *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        x: *const *mut hipDoubleComplex,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\ntrmvStridedBatched performs one of the matrix-vector operations\n\nx_i = A_i*x_i or x_i = A**T*x_i, 0 \\le i < batchCount\n\nwhere x_i is an n element vector and A_i is an n by n (unit, or non-unit, upper or lower triangular matrix)\nwith strides specifying how to retrieve $x_i$ (resp. $A_i$) from $x_{i-1}$ (resp. $A_i$).\n\nThe vectors x_i are overwritten.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n\n@param[in]\nuplo    [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER:  A_i is an upper triangular matrix.\nHIPBLAS_FILL_MODE_LOWER:  A_i is a  lower triangular matrix.\n\n@param[in]\ntransA     [hipblasOperation_t]\n\n@param[in]\ndiag    [hipblasDiagType_t]\nHIPBLAS_DIAG_UNIT:     A_i is assumed to be unit triangular.\nHIPBLAS_DIAG_NON_UNIT:  A_i is not assumed to be unit triangular.\n\n@param[in]\nm         [int]\nm specifies the number of rows of matrices A_i. m >= 0.\n\n@param[in]\nAP        device pointer of the matrix A_0,\nof dimension ( lda, m )\n\n@param[in]\nlda       [int]\nspecifies the leading dimension of A_i.\nlda >= max( 1, m ).\n\n@param[in]\nstrideA  [hipblasStride]\nstride from the start of one A_i matrix to the next A_{i + 1}\n\n@param[in]\nx         device pointer storing the vector x_0.\n\n@param[in]\nincx      [int]\nspecifies the increment for the elements of one vector x.\n\n@param[in]\nstridex  [hipblasStride]\nstride from the start of one x_i vector to the next x_{i + 1}\n\n@param[in]\nbatchCount [int]\nThe number of batched matrices/vectors.\n\n"]
    pub fn hipblasStrmvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        AP: *const f32,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *mut f32,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtrmvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        AP: *const f64,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *mut f64,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrmvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        AP: *const hipblasComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *mut hipblasComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrmvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        AP: *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *mut hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrmvStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        AP: *const hipComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *mut hipComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrmvStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        AP: *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *mut hipDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\ntrsv solves\n\nA*x = b or A**T*x = b,\n\nwhere x and b are vectors and A is a triangular matrix.\n\nThe vector x is overwritten on b.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : s,d,c,z\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n\n@param[in]\nuplo    [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER:  A is an upper triangular matrix.\nHIPBLAS_FILL_MODE_LOWER:  A is a  lower triangular matrix.\n\n@param[in]\ntransA     [hipblasOperation_t]\n\n@param[in]\ndiag    [hipblasDiagType_t]\nHIPBLAS_DIAG_UNIT:     A is assumed to be unit triangular.\nHIPBLAS_DIAG_NON_UNIT:  A is not assumed to be unit triangular.\n\n@param[in]\nm         [int]\nm specifies the number of rows of b. m >= 0.\n\n@param[in]\nAP        device pointer storing matrix A,\nof dimension ( lda, m )\n\n@param[in]\nlda       [int]\nspecifies the leading dimension of A.\nlda = max( 1, m ).\n\n@param[in]\nx         device pointer storing vector x.\n\n@param[in]\nincx      [int]\nspecifies the increment for the elements of x.\n"]
    pub fn hipblasStrsv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        AP: *const f32,
        lda: ::core::ffi::c_int,
        x: *mut f32,
        incx: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtrsv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        AP: *const f64,
        lda: ::core::ffi::c_int,
        x: *mut f64,
        incx: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrsv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        AP: *const hipblasComplex,
        lda: ::core::ffi::c_int,
        x: *mut hipblasComplex,
        incx: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrsv(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        AP: *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        x: *mut hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrsv_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        AP: *const hipComplex,
        lda: ::core::ffi::c_int,
        x: *mut hipComplex,
        incx: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrsv_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        AP: *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        x: *mut hipDoubleComplex,
        incx: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\ntrsvBatched solves\n\nA_i*x_i = b_i or A_i**T*x_i = b_i,\n\nwhere (A_i, x_i, b_i) is the i-th instance of the batch.\nx_i and b_i are vectors and A_i is an\nm by m triangular matrix.\n\nThe vector x is overwritten on b.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n\n@param[in]\nuplo    [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER:  A is an upper triangular matrix.\nHIPBLAS_FILL_MODE_LOWER:  A is a  lower triangular matrix.\n\n@param[in]\ntransA     [hipblasOperation_t]\n\n@param[in]\ndiag    [hipblasDiagType_t]\nHIPBLAS_DIAG_UNIT:     A is assumed to be unit triangular.\nHIPBLAS_DIAG_NON_UNIT:  A is not assumed to be unit triangular.\n\n@param[in]\nm         [int]\nm specifies the number of rows of b. m >= 0.\n\n@param[in]\nAP         device array of device pointers storing each matrix A_i.\n\n@param[in]\nlda       [int]\nspecifies the leading dimension of each A_i.\nlda = max(1, m)\n\n@param[in]\nx         device array of device pointers storing each vector x_i.\n\n@param[in]\nincx      [int]\nspecifies the increment for the elements of x.\n\n@param[in]\nbatchCount [int]\nnumber of instances in the batch\n"]
    pub fn hipblasStrsvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        AP: *const *const f32,
        lda: ::core::ffi::c_int,
        x: *const *mut f32,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtrsvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        AP: *const *const f64,
        lda: ::core::ffi::c_int,
        x: *const *mut f64,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrsvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        AP: *const *const hipblasComplex,
        lda: ::core::ffi::c_int,
        x: *const *mut hipblasComplex,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrsvBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        AP: *const *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        x: *const *mut hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrsvBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        AP: *const *const hipComplex,
        lda: ::core::ffi::c_int,
        x: *const *mut hipComplex,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrsvBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        AP: *const *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        x: *const *mut hipDoubleComplex,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 2 API\n\n\\details\ntrsvStridedBatched solves\n\nA_i*x_i = b_i or A_i**T*x_i = b_i,\n\nwhere (A_i, x_i, b_i) is the i-th instance of the batch.\nx_i and b_i are vectors and A_i is an m by m triangular matrix, for i = 1, ..., batchCount.\n\nThe vector x is overwritten on b.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n\n@param[in]\nuplo    [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER:  A is an upper triangular matrix.\nHIPBLAS_FILL_MODE_LOWER:  A is a  lower triangular matrix.\n\n@param[in]\ntransA     [hipblasOperation_t]\n\n@param[in]\ndiag    [hipblasDiagType_t]\nHIPBLAS_DIAG_UNIT:     A is assumed to be unit triangular.\nHIPBLAS_DIAG_NON_UNIT:  A is not assumed to be unit triangular.\n\n@param[in]\nm         [int]\nm specifies the number of rows of each b_i. m >= 0.\n\n@param[in]\nAP         device pointer to the first matrix (A_1) in the batch, of dimension ( lda, m )\n\n@param[in]\nstrideA  [hipblasStride]\nstride from the start of one A_i matrix to the next A_(i + 1)\n\n@param[in]\nlda       [int]\nspecifies the leading dimension of each A_i.\nlda = max( 1, m ).\n\n@param[in, out]\nx         device pointer to the first vector (x_1) in the batch.\n\n@param[in]\nstridex [hipblasStride]\nstride from the start of one x_i vector to the next x_(i + 1)\n\n@param[in]\nincx      [int]\nspecifies the increment for the elements of each x_i.\n\n@param[in]\nbatchCount [int]\nnumber of instances in the batch\n"]
    pub fn hipblasStrsvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        AP: *const f32,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *mut f32,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtrsvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        AP: *const f64,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *mut f64,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrsvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        AP: *const hipblasComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *mut hipblasComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrsvStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        AP: *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *mut hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrsvStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        AP: *const hipComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *mut hipComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrsvStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        AP: *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *mut hipDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 3 API\n\n\\details\ngemm performs one of the matrix-matrix operations\n\nC = alpha*op( A )*op( B ) + beta*C,\n\nwhere op( X ) is one of\n\nop( X ) = X      or\nop( X ) = X**T   or\nop( X ) = X**H,\n\nalpha and beta are scalars, and A, B and C are matrices, with\nop( A ) an m by k matrix, op( B ) a k by n matrix and C an m by n matrix.\n\n- Supported precisions in rocBLAS : h,s,d,c,z\n- Supported precisions in cuBLAS  : h,s,d,c,z\n\n@param[in]\nhandle    [hipblasHandle_t]\n\n.\n@param[in]\ntransA    [hipblasOperation_t]\nspecifies the form of op( A )\n@param[in]\ntransB    [hipblasOperation_t]\nspecifies the form of op( B )\n@param[in]\nm         [int]\nnumber or rows of matrices op( A ) and C\n@param[in]\nn         [int]\nnumber of columns of matrices op( B ) and C\n@param[in]\nk         [int]\nnumber of columns of matrix op( A ) and number of rows of matrix op( B )\n@param[in]\nalpha     device pointer or host pointer specifying the scalar alpha.\n@param[in]\nAP         device pointer storing matrix A.\n@param[in]\nlda       [int]\nspecifies the leading dimension of A.\n@param[in]\nBP         device pointer storing matrix B.\n@param[in]\nldb       [int]\nspecifies the leading dimension of B.\n@param[in]\nbeta      device pointer or host pointer specifying the scalar beta.\n@param[in, out]\nCP         device pointer storing matrix C on the GPU.\n@param[in]\nldc       [int]\nspecifies the leading dimension of C.\n"]
    pub fn hipblasHgemm(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipblasHalf,
        AP: *const hipblasHalf,
        lda: ::core::ffi::c_int,
        BP: *const hipblasHalf,
        ldb: ::core::ffi::c_int,
        beta: *const hipblasHalf,
        CP: *mut hipblasHalf,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSgemm(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const f32,
        AP: *const f32,
        lda: ::core::ffi::c_int,
        BP: *const f32,
        ldb: ::core::ffi::c_int,
        beta: *const f32,
        CP: *mut f32,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgemm(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const f64,
        AP: *const f64,
        lda: ::core::ffi::c_int,
        BP: *const f64,
        ldb: ::core::ffi::c_int,
        beta: *const f64,
        CP: *mut f64,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgemm(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: ::core::ffi::c_int,
        BP: *const hipblasComplex,
        ldb: ::core::ffi::c_int,
        beta: *const hipblasComplex,
        CP: *mut hipblasComplex,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgemm(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        BP: *const hipblasDoubleComplex,
        ldb: ::core::ffi::c_int,
        beta: *const hipblasDoubleComplex,
        CP: *mut hipblasDoubleComplex,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgemm_v2(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: ::core::ffi::c_int,
        BP: *const hipComplex,
        ldb: ::core::ffi::c_int,
        beta: *const hipComplex,
        CP: *mut hipComplex,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgemm_v2(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        BP: *const hipDoubleComplex,
        ldb: ::core::ffi::c_int,
        beta: *const hipDoubleComplex,
        CP: *mut hipDoubleComplex,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 3 API\n\\details\ngemmBatched performs one of the batched matrix-matrix operations\nC_i = alpha*op( A_i )*op( B_i ) + beta*C_i, for i = 1, ..., batchCount.\nwhere op( X ) is one of\nop( X ) = X      or\nop( X ) = X**T   or\nop( X ) = X**H,\nalpha and beta are scalars, and A, B and C are strided batched matrices, with\nop( A ) an m by k by batchCount strided_batched matrix,\nop( B ) an k by n by batchCount strided_batched matrix and\nC an m by n by batchCount strided_batched matrix.\n\n- Supported precisions in rocBLAS : h,s,d,c,z\n- Supported precisions in cuBLAS  : h,s,d,c,z\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\ntransA    [hipblasOperation_t]\nspecifies the form of op( A )\n@param[in]\ntransB    [hipblasOperation_t]\nspecifies the form of op( B )\n@param[in]\nm         [int]\nmatrix dimension m.\n@param[in]\nn         [int]\nmatrix dimension n.\n@param[in]\nk         [int]\nmatrix dimension k.\n@param[in]\nalpha     device pointer or host pointer specifying the scalar alpha.\n@param[in]\nAP         device array of device pointers storing each matrix A_i.\n@param[in]\nlda       [int]\nspecifies the leading dimension of each A_i.\n@param[in]\nBP         device array of device pointers storing each matrix B_i.\n@param[in]\nldb       [int]\nspecifies the leading dimension of each B_i.\n@param[in]\nbeta      device pointer or host pointer specifying the scalar beta.\n@param[in, out]\nCP         device array of device pointers storing each matrix C_i.\n@param[in]\nldc       [int]\nspecifies the leading dimension of each C_i.\n@param[in]\nbatchCount\n[int]\nnumber of gemm operations in the batch"]
    pub fn hipblasHgemmBatched(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipblasHalf,
        AP: *const *const hipblasHalf,
        lda: ::core::ffi::c_int,
        BP: *const *const hipblasHalf,
        ldb: ::core::ffi::c_int,
        beta: *const hipblasHalf,
        CP: *const *mut hipblasHalf,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSgemmBatched(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const f32,
        AP: *const *const f32,
        lda: ::core::ffi::c_int,
        BP: *const *const f32,
        ldb: ::core::ffi::c_int,
        beta: *const f32,
        CP: *const *mut f32,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgemmBatched(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const f64,
        AP: *const *const f64,
        lda: ::core::ffi::c_int,
        BP: *const *const f64,
        ldb: ::core::ffi::c_int,
        beta: *const f64,
        CP: *const *mut f64,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgemmBatched(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        AP: *const *const hipblasComplex,
        lda: ::core::ffi::c_int,
        BP: *const *const hipblasComplex,
        ldb: ::core::ffi::c_int,
        beta: *const hipblasComplex,
        CP: *const *mut hipblasComplex,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgemmBatched(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        BP: *const *const hipblasDoubleComplex,
        ldb: ::core::ffi::c_int,
        beta: *const hipblasDoubleComplex,
        CP: *const *mut hipblasDoubleComplex,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgemmBatched_v2(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipComplex,
        AP: *const *const hipComplex,
        lda: ::core::ffi::c_int,
        BP: *const *const hipComplex,
        ldb: ::core::ffi::c_int,
        beta: *const hipComplex,
        CP: *const *mut hipComplex,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgemmBatched_v2(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        BP: *const *const hipDoubleComplex,
        ldb: ::core::ffi::c_int,
        beta: *const hipDoubleComplex,
        CP: *const *mut hipDoubleComplex,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 3 API\n\n\\details\ngemmStridedBatched performs one of the strided batched matrix-matrix operations\n\nC_i = alpha*op( A_i )*op( B_i ) + beta*C_i, for i = 1, ..., batchCount.\n\nwhere op( X ) is one of\n\nop( X ) = X      or\nop( X ) = X**T   or\nop( X ) = X**H,\n\nalpha and beta are scalars, and A, B and C are strided batched matrices, with\nop( A ) an m by k by batchCount strided_batched matrix,\nop( B ) an k by n by batchCount strided_batched matrix and\nC an m by n by batchCount strided_batched matrix.\n\n- Supported precisions in rocBLAS : h,s,d,c,z\n- Supported precisions in cuBLAS  : h,s,d,c,z\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\ntransA    [hipblasOperation_t]\nspecifies the form of op( A )\n@param[in]\ntransB    [hipblasOperation_t]\nspecifies the form of op( B )\n@param[in]\nm         [int]\nmatrix dimension m.\n@param[in]\nn         [int]\nmatrix dimension n.\n@param[in]\nk         [int]\nmatrix dimension k.\n@param[in]\nalpha     device pointer or host pointer specifying the scalar alpha.\n@param[in]\nAP         device pointer pointing to the first matrix A_1.\n@param[in]\nlda       [int]\nspecifies the leading dimension of each A_i.\n@param[in]\nstrideA  [hipblasStride]\nstride from the start of one A_i matrix to the next A_(i + 1).\n@param[in]\nBP         device pointer pointing to the first matrix B_1.\n@param[in]\nldb       [int]\nspecifies the leading dimension of each B_i.\n@param[in]\nstrideB  [hipblasStride]\nstride from the start of one B_i matrix to the next B_(i + 1).\n@param[in]\nbeta      device pointer or host pointer specifying the scalar beta.\n@param[in, out]\nCP         device pointer pointing to the first matrix C_1.\n@param[in]\nldc       [int]\nspecifies the leading dimension of each C_i.\n@param[in]\nstrideC  [hipblasStride]\nstride from the start of one C_i matrix to the next C_(i + 1).\n@param[in]\nbatchCount\n[int]\nnumber of gemm operatons in the batch\n"]
    pub fn hipblasHgemmStridedBatched(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipblasHalf,
        AP: *const hipblasHalf,
        lda: ::core::ffi::c_int,
        strideA: ::core::ffi::c_longlong,
        BP: *const hipblasHalf,
        ldb: ::core::ffi::c_int,
        strideB: ::core::ffi::c_longlong,
        beta: *const hipblasHalf,
        CP: *mut hipblasHalf,
        ldc: ::core::ffi::c_int,
        strideC: ::core::ffi::c_longlong,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasSgemmStridedBatched(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const f32,
        AP: *const f32,
        lda: ::core::ffi::c_int,
        strideA: ::core::ffi::c_longlong,
        BP: *const f32,
        ldb: ::core::ffi::c_int,
        strideB: ::core::ffi::c_longlong,
        beta: *const f32,
        CP: *mut f32,
        ldc: ::core::ffi::c_int,
        strideC: ::core::ffi::c_longlong,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgemmStridedBatched(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const f64,
        AP: *const f64,
        lda: ::core::ffi::c_int,
        strideA: ::core::ffi::c_longlong,
        BP: *const f64,
        ldb: ::core::ffi::c_int,
        strideB: ::core::ffi::c_longlong,
        beta: *const f64,
        CP: *mut f64,
        ldc: ::core::ffi::c_int,
        strideC: ::core::ffi::c_longlong,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgemmStridedBatched(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: ::core::ffi::c_int,
        strideA: ::core::ffi::c_longlong,
        BP: *const hipblasComplex,
        ldb: ::core::ffi::c_int,
        strideB: ::core::ffi::c_longlong,
        beta: *const hipblasComplex,
        CP: *mut hipblasComplex,
        ldc: ::core::ffi::c_int,
        strideC: ::core::ffi::c_longlong,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgemmStridedBatched(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: ::core::ffi::c_longlong,
        BP: *const hipblasDoubleComplex,
        ldb: ::core::ffi::c_int,
        strideB: ::core::ffi::c_longlong,
        beta: *const hipblasDoubleComplex,
        CP: *mut hipblasDoubleComplex,
        ldc: ::core::ffi::c_int,
        strideC: ::core::ffi::c_longlong,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgemmStridedBatched_v2(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: ::core::ffi::c_int,
        strideA: ::core::ffi::c_longlong,
        BP: *const hipComplex,
        ldb: ::core::ffi::c_int,
        strideB: ::core::ffi::c_longlong,
        beta: *const hipComplex,
        CP: *mut hipComplex,
        ldc: ::core::ffi::c_int,
        strideC: ::core::ffi::c_longlong,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgemmStridedBatched_v2(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: ::core::ffi::c_longlong,
        BP: *const hipDoubleComplex,
        ldb: ::core::ffi::c_int,
        strideB: ::core::ffi::c_longlong,
        beta: *const hipDoubleComplex,
        CP: *mut hipDoubleComplex,
        ldc: ::core::ffi::c_int,
        strideC: ::core::ffi::c_longlong,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 3 API\n\n\\details\n\nherk performs one of the matrix-matrix operations for a Hermitian rank-k update\n\nC := alpha*op( A )*op( A )^H + beta*C\n\nwhere  alpha and beta are scalars, op(A) is an n by k matrix, and\nC is a n x n Hermitian matrix stored as either upper or lower.\n\nop( A ) = A,  and A is n by k if transA == HIPBLAS_OP_N\nop( A ) = A^H and A is k by n if transA == HIPBLAS_OP_C\n\n- Supported precisions in rocBLAS : c,z\n- Supported precisions in cuBLAS  : c,z\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n\n@param[in]\nuplo    [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER:  C is an upper triangular matrix\nHIPBLAS_FILL_MODE_LOWER:  C is a  lower triangular matrix\n\n@param[in]\ntransA  [hipblasOperation_t]\nHIPBLAS_OP_C:  op(A) = A^H\nHIPBLAS_ON_N:  op(A) = A\n\n@param[in]\nn       [int]\nn specifies the number of rows and columns of C. n >= 0.\n\n@param[in]\nk       [int]\nk specifies the number of columns of op(A). k >= 0.\n\n@param[in]\nalpha\nalpha specifies the scalar alpha. When alpha is\nzero then A is not referenced and A need not be set before\nentry.\n\n@param[in]\nAP       pointer storing matrix A on the GPU.\nMartrix dimension is ( lda, k ) when if transA = HIPBLAS_OP_N, otherwise (lda, n)\nonly the upper/lower triangular part is accessed.\n\n@param[in]\nlda     [int]\nlda specifies the first dimension of A.\nif transA = HIPBLAS_OP_N,  lda >= max( 1, n ),\notherwise lda >= max( 1, k ).\n\n@param[in]\nbeta\nbeta specifies the scalar beta. When beta is\nzero then C need not be set before entry.\n\n@param[in]\nCP       pointer storing matrix C on the GPU.\nThe imaginary component of the diagonal elements are not used but are set to zero unless quick return.\n\n@param[in]\nldc    [int]\nldc specifies the first dimension of C. ldc >= max( 1, n ).\n"]
    pub fn hipblasCherk(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const f32,
        AP: *const hipblasComplex,
        lda: ::core::ffi::c_int,
        beta: *const f32,
        CP: *mut hipblasComplex,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZherk(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const f64,
        AP: *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        beta: *const f64,
        CP: *mut hipblasDoubleComplex,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCherk_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const f32,
        AP: *const hipComplex,
        lda: ::core::ffi::c_int,
        beta: *const f32,
        CP: *mut hipComplex,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZherk_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const f64,
        AP: *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        beta: *const f64,
        CP: *mut hipDoubleComplex,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 3 API\n\n\\details\n\nherkBatched performs a batch of the matrix-matrix operations for a Hermitian rank-k update\n\nC_i := alpha*op( A_i )*op( A_i )^H + beta*C_i\n\nwhere  alpha and beta are scalars, op(A) is an n by k matrix, and\nC_i is a n x n Hermitian matrix stored as either upper or lower.\n\nop( A_i ) = A_i, and A_i is n by k if transA == HIPBLAS_OP_N\nop( A_i ) = A_i^H and A_i is k by n if transA == HIPBLAS_OP_C\n\n- Supported precisions in rocBLAS : c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n\n@param[in]\nuplo    [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER:  C_i is an upper triangular matrix\nHIPBLAS_FILL_MODE_LOWER:  C_i is a  lower triangular matrix\n\n@param[in]\ntransA  [hipblasOperation_t]\nHIPBLAS_OP_C: op(A) = A^H\nHIPBLAS_OP_N: op(A) = A\n\n@param[in]\nn       [int]\nn specifies the number of rows and columns of C_i. n >= 0.\n\n@param[in]\nk       [int]\nk specifies the number of columns of op(A). k >= 0.\n\n@param[in]\nalpha\nalpha specifies the scalar alpha. When alpha is\nzero then A is not referenced and A need not be set before\nentry.\n\n@param[in]\nAP       device array of device pointers storing each matrix_i A of dimension (lda, k)\nwhen transA is HIPBLAS_OP_N, otherwise of dimension (lda, n)\n\n@param[in]\nlda     [int]\nlda specifies the first dimension of A_i.\nif transA = HIPBLAS_OP_N,  lda >= max( 1, n ),\notherwise lda >= max( 1, k ).\n\n@param[in]\nbeta\nbeta specifies the scalar beta. When beta is\nzero then C need not be set before entry.\n\n@param[in]\nCP       device array of device pointers storing each matrix C_i on the GPU.\nThe imaginary component of the diagonal elements are not used but are set to zero unless quick return.\n\n@param[in]\nldc    [int]\nldc specifies the first dimension of C. ldc >= max( 1, n ).\n@param[in]\nbatchCount [int]\nnumber of instances in the batch.\n"]
    pub fn hipblasCherkBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const f32,
        AP: *const *const hipblasComplex,
        lda: ::core::ffi::c_int,
        beta: *const f32,
        CP: *const *mut hipblasComplex,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZherkBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const f64,
        AP: *const *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        beta: *const f64,
        CP: *const *mut hipblasDoubleComplex,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCherkBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const f32,
        AP: *const *const hipComplex,
        lda: ::core::ffi::c_int,
        beta: *const f32,
        CP: *const *mut hipComplex,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZherkBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const f64,
        AP: *const *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        beta: *const f64,
        CP: *const *mut hipDoubleComplex,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 3 API\n\n\\details\n\nherkStridedBatched performs a batch of the matrix-matrix operations for a Hermitian rank-k update\n\nC_i := alpha*op( A_i )*op( A_i )^H + beta*C_i\n\nwhere  alpha and beta are scalars, op(A) is an n by k matrix, and\nC_i is a n x n Hermitian matrix stored as either upper or lower.\n\nop( A_i ) = A_i, and A_i is n by k if transA == HIPBLAS_OP_N\nop( A_i ) = A_i^H and A_i is k by n if transA == HIPBLAS_OP_C\n\n- Supported precisions in rocBLAS : c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n\n@param[in]\nuplo    [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER:  C_i is an upper triangular matrix\nHIPBLAS_FILL_MODE_LOWER:  C_i is a  lower triangular matrix\n\n@param[in]\ntransA  [hipblasOperation_t]\nHIPBLAS_OP_C: op(A) = A^H\nHIPBLAS_OP_N: op(A) = A\n\n@param[in]\nn       [int]\nn specifies the number of rows and columns of C_i. n >= 0.\n\n@param[in]\nk       [int]\nk specifies the number of columns of op(A). k >= 0.\n\n@param[in]\nalpha\nalpha specifies the scalar alpha. When alpha is\nzero then A is not referenced and A need not be set before\nentry.\n\n@param[in]\nAP       Device pointer to the first matrix A_1 on the GPU of dimension (lda, k)\nwhen transA is HIPBLAS_OP_N, otherwise of dimension (lda, n)\n\n@param[in]\nlda     [int]\nlda specifies the first dimension of A_i.\nif transA = HIPBLAS_OP_N,  lda >= max( 1, n ),\notherwise lda >= max( 1, k ).\n\n@param[in]\nstrideA  [hipblasStride]\nstride from the start of one matrix (A_i) and the next one (A_i+1)\n\n@param[in]\nbeta\nbeta specifies the scalar beta. When beta is\nzero then C need not be set before entry.\n\n@param[in]\nCP       Device pointer to the first matrix C_1 on the GPU.\nThe imaginary component of the diagonal elements are not used but are set to zero unless quick return.\n\n@param[in]\nldc    [int]\nldc specifies the first dimension of C. ldc >= max( 1, n ).\n\n@param[inout]\nstrideC  [hipblasStride]\nstride from the start of one matrix (C_i) and the next one (C_i+1)\n\n@param[in]\nbatchCount [int]\nnumber of instances in the batch.\n"]
    pub fn hipblasCherkStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const f32,
        AP: *const hipblasComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        beta: *const f32,
        CP: *mut hipblasComplex,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZherkStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const f64,
        AP: *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        beta: *const f64,
        CP: *mut hipblasDoubleComplex,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCherkStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const f32,
        AP: *const hipComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        beta: *const f32,
        CP: *mut hipComplex,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZherkStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const f64,
        AP: *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        beta: *const f64,
        CP: *mut hipDoubleComplex,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 3 API\n\n\\details\n\nherkx performs one of the matrix-matrix operations for a Hermitian rank-k update\n\nC := alpha*op( A )*op( B )^H + beta*C\n\nwhere  alpha and beta are scalars, op(A) and op(B) are n by k matrices, and\nC is a n x n Hermitian matrix stored as either upper or lower.\nThis routine should only be used when the caller can guarantee that the result of op( A )*op( B )^T will be Hermitian.\n\n\nop( A ) = A, op( B ) = B, and A and B are n by k if trans == HIPBLAS_OP_N\nop( A ) = A^H, op( B ) = B^H,  and A and B are k by n if trans == HIPBLAS_OP_C\n\n- Supported precisions in rocBLAS : c,z\n- Supported precisions in cuBLAS  : c,z\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n\n@param[in]\nuplo    [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER:  C is an upper triangular matrix\nHIPBLAS_FILL_MODE_LOWER:  C is a  lower triangular matrix\n\n@param[in]\ntransA  [hipblasOperation_t]\nHIPBLAS_OP_C:  op( A ) = A^H, op( B ) = B^H\nHIPBLAS_OP_N:  op( A ) = A, op( B ) = B\n\n@param[in]\nn       [int]\nn specifies the number of rows and columns of C. n >= 0.\n\n@param[in]\nk       [int]\nk specifies the number of columns of op(A). k >= 0.\n\n@param[in]\nalpha\nalpha specifies the scalar alpha. When alpha is\nzero then A is not referenced and A need not be set before\nentry.\n\n@param[in]\nAP      pointer storing matrix A on the GPU.\nMartrix dimension is ( lda, k ) when if trans = HIPBLAS_OP_N, otherwise (lda, n)\nonly the upper/lower triangular part is accessed.\n\n@param[in]\nlda     [int]\nlda specifies the first dimension of A.\nif trans = HIPBLAS_OP_N,  lda >= max( 1, n ),\notherwise lda >= max( 1, k ).\n@param[in]\nBP       pointer storing matrix B on the GPU.\nMartrix dimension is ( ldb, k ) when if trans = HIPBLAS_OP_N, otherwise (ldb, n)\nonly the upper/lower triangular part is accessed.\n\n@param[in]\nldb     [int]\nldb specifies the first dimension of B.\nif trans = HIPBLAS_OP_N,  ldb >= max( 1, n ),\notherwise ldb >= max( 1, k ).\n@param[in]\nbeta\nbeta specifies the scalar beta. When beta is\nzero then C need not be set before entry.\n\n@param[in]\nCP       pointer storing matrix C on the GPU.\nThe imaginary component of the diagonal elements are not used but are set to zero unless quick return.\n\n@param[in]\nldc    [int]\nldc specifies the first dimension of C. ldc >= max( 1, n ).\n"]
    pub fn hipblasCherkx(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: ::core::ffi::c_int,
        BP: *const hipblasComplex,
        ldb: ::core::ffi::c_int,
        beta: *const f32,
        CP: *mut hipblasComplex,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZherkx(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        BP: *const hipblasDoubleComplex,
        ldb: ::core::ffi::c_int,
        beta: *const f64,
        CP: *mut hipblasDoubleComplex,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCherkx_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: ::core::ffi::c_int,
        BP: *const hipComplex,
        ldb: ::core::ffi::c_int,
        beta: *const f32,
        CP: *mut hipComplex,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZherkx_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        BP: *const hipDoubleComplex,
        ldb: ::core::ffi::c_int,
        beta: *const f64,
        CP: *mut hipDoubleComplex,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 3 API\n\n\\details\n\nherkxBatched performs a batch of the matrix-matrix operations for a Hermitian rank-k update\n\nC_i := alpha*op( A_i )*op( B_i )^H + beta*C_i\n\nwhere  alpha and beta are scalars, op(A_i) and op(B_i) are n by k matrices, and\nC_i is a n x n Hermitian matrix stored as either upper or lower.\nThis routine should only be used when the caller can guarantee that the result of op( A )*op( B )^T will be Hermitian.\n\nop( A_i ) = A_i, op( B_i ) = B_i, and A_i and B_i are n by k if trans == HIPBLAS_OP_N\nop( A_i ) = A_i^H, op( B_i ) = B_i^H,  and A_i and B_i are k by n if trans == HIPBLAS_OP_C\n\n- Supported precisions in rocBLAS : c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n\n@param[in]\nuplo    [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER:  C_i is an upper triangular matrix\nHIPBLAS_FILL_MODE_LOWER:  C_i is a  lower triangular matrix\n\n@param[in]\ntransA  [hipblasOperation_t]\nHIPBLAS_OP_C: op(A) = A^H\nHIPBLAS_OP_N: op(A) = A\n\n@param[in]\nn       [int]\nn specifies the number of rows and columns of C_i. n >= 0.\n\n@param[in]\nk       [int]\nk specifies the number of columns of op(A). k >= 0.\n\n@param[in]\nalpha\nalpha specifies the scalar alpha. When alpha is\nzero then A is not referenced and A need not be set before\nentry.\n\n@param[in]\nAP       device array of device pointers storing each matrix_i A of dimension (lda, k)\nwhen trans is HIPBLAS_OP_N, otherwise of dimension (lda, n)\n\n@param[in]\nlda     [int]\nlda specifies the first dimension of A_i.\nif trans = HIPBLAS_OP_N,  lda >= max( 1, n ),\notherwise lda >= max( 1, k ).\n\n@param[in]\nBP       device array of device pointers storing each matrix_i B of dimension (ldb, k)\nwhen trans is HIPBLAS_OP_N, otherwise of dimension (ldb, n)\n\n@param[in]\nldb     [int]\nldb specifies the first dimension of B_i.\nif trans = HIPBLAS_OP_N,  ldb >= max( 1, n ),\notherwise ldb >= max( 1, k ).\n\n@param[in]\nbeta\nbeta specifies the scalar beta. When beta is\nzero then C need not be set before entry.\n\n@param[in]\nCP       device array of device pointers storing each matrix C_i on the GPU.\nThe imaginary component of the diagonal elements are not used but are set to zero unless quick return.\n\n@param[in]\nldc    [int]\nldc specifies the first dimension of C. ldc >= max( 1, n ).\n\n@param[in]\nbatchCount [int]\nnumber of instances in the batch.\n"]
    pub fn hipblasCherkxBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        AP: *const *const hipblasComplex,
        lda: ::core::ffi::c_int,
        BP: *const *const hipblasComplex,
        ldb: ::core::ffi::c_int,
        beta: *const f32,
        CP: *const *mut hipblasComplex,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZherkxBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        BP: *const *const hipblasDoubleComplex,
        ldb: ::core::ffi::c_int,
        beta: *const f64,
        CP: *const *mut hipblasDoubleComplex,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCherkxBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipComplex,
        AP: *const *const hipComplex,
        lda: ::core::ffi::c_int,
        BP: *const *const hipComplex,
        ldb: ::core::ffi::c_int,
        beta: *const f32,
        CP: *const *mut hipComplex,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZherkxBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        BP: *const *const hipDoubleComplex,
        ldb: ::core::ffi::c_int,
        beta: *const f64,
        CP: *const *mut hipDoubleComplex,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 3 API\n\n\\details\n\nherkxStridedBatched performs a batch of the matrix-matrix operations for a Hermitian rank-k update\n\nC_i := alpha*op( A_i )*op( B_i )^H + beta*C_i\n\nwhere  alpha and beta are scalars, op(A_i) and op(B_i) are n by k matrices, and\nC_i is a n x n Hermitian matrix stored as either upper or lower.\nThis routine should only be used when the caller can guarantee that the result of op( A )*op( B )^T will be Hermitian.\n\nop( A_i ) = A_i, op( B_i ) = B_i, and A_i and B_i are n by k if trans == HIPBLAS_OP_N\nop( A_i ) = A_i^H, op( B_i ) = B_i^H,  and A_i and B_i are k by n if trans == HIPBLAS_OP_C\n\n- Supported precisions in rocBLAS : c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n\n@param[in]\nuplo    [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER:  C_i is an upper triangular matrix\nHIPBLAS_FILL_MODE_LOWER:  C_i is a  lower triangular matrix\n\n@param[in]\ntransA  [hipblasOperation_t]\nHIPBLAS_OP_C: op( A_i ) = A_i^H, op( B_i ) = B_i^H\nHIPBLAS_OP_N: op( A_i ) = A_i, op( B_i ) = B_i\n\n@param[in]\nn       [int]\nn specifies the number of rows and columns of C_i. n >= 0.\n\n@param[in]\nk       [int]\nk specifies the number of columns of op(A). k >= 0.\n\n@param[in]\nalpha\nalpha specifies the scalar alpha. When alpha is\nzero then A is not referenced and A need not be set before\nentry.\n\n@param[in]\nAP       Device pointer to the first matrix A_1 on the GPU of dimension (lda, k)\nwhen trans is HIPBLAS_OP_N, otherwise of dimension (lda, n)\n\n@param[in]\nlda     [int]\nlda specifies the first dimension of A_i.\nif trans = HIPBLAS_OP_N,  lda >= max( 1, n ),\notherwise lda >= max( 1, k ).\n\n@param[in]\nstrideA  [hipblasStride]\nstride from the start of one matrix (A_i) and the next one (A_i+1)\n\n@param[in]\nBP       Device pointer to the first matrix B_1 on the GPU of dimension (ldb, k)\nwhen trans is HIPBLAS_OP_N, otherwise of dimension (ldb, n)\n\n@param[in]\nldb     [int]\nldb specifies the first dimension of B_i.\nif trans = HIPBLAS_OP_N,  ldb >= max( 1, n ),\notherwise ldb >= max( 1, k ).\n\n@param[in]\nstrideB  [hipblasStride]\nstride from the start of one matrix (B_i) and the next one (B_i+1)\n\n@param[in]\nbeta\nbeta specifies the scalar beta. When beta is\nzero then C need not be set before entry.\n\n@param[in]\nCP       Device pointer to the first matrix C_1 on the GPU.\nThe imaginary component of the diagonal elements are not used but are set to zero unless quick return.\n\n@param[in]\nldc    [int]\nldc specifies the first dimension of C. ldc >= max( 1, n ).\n\n@param[inout]\nstrideC  [hipblasStride]\nstride from the start of one matrix (C_i) and the next one (C_i+1)\n\n@param[in]\nbatchCount [int]\nnumber of instances in the batch.\n"]
    pub fn hipblasCherkxStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        BP: *const hipblasComplex,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        beta: *const f32,
        CP: *mut hipblasComplex,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZherkxStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        BP: *const hipblasDoubleComplex,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        beta: *const f64,
        CP: *mut hipblasDoubleComplex,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCherkxStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        BP: *const hipComplex,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        beta: *const f32,
        CP: *mut hipComplex,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZherkxStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        BP: *const hipDoubleComplex,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        beta: *const f64,
        CP: *mut hipDoubleComplex,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 3 API\n\n\\details\n\nher2k performs one of the matrix-matrix operations for a Hermitian rank-2k update\n\nC := alpha*op( A )*op( B )^H + conj(alpha)*op( B )*op( A )^H + beta*C\n\nwhere  alpha and beta are scalars, op(A) and op(B) are n by k matrices, and\nC is a n x n Hermitian matrix stored as either upper or lower.\n\nop( A ) = A, op( B ) = B, and A and B are n by k if trans == HIPBLAS_OP_N\nop( A ) = A^H, op( B ) = B^H,  and A and B are k by n if trans == HIPBLAS_OP_C\n\n- Supported precisions in rocBLAS : c,z\n- Supported precisions in cuBLAS  : c,z\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n\n@param[in]\nuplo    [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER:  C is an upper triangular matrix\nHIPBLAS_FILL_MODE_LOWER:  C is a  lower triangular matrix\n\n@param[in]\ntransA  [hipblasOperation_t]\nHIPBLAS_OP_C:  op( A ) = A^H, op( B ) = B^H\nHIPBLAS_OP_N:  op( A ) = A, op( B ) = B\n\n@param[in]\nn       [int]\nn specifies the number of rows and columns of C. n >= 0.\n\n@param[in]\nk       [int]\nk specifies the number of columns of op(A). k >= 0.\n\n@param[in]\nalpha\nalpha specifies the scalar alpha. When alpha is\nzero then A is not referenced and A need not be set before\nentry.\n\n@param[in]\nAP       pointer storing matrix A on the GPU.\nMartrix dimension is ( lda, k ) when if trans = HIPBLAS_OP_N, otherwise (lda, n)\nonly the upper/lower triangular part is accessed.\n\n@param[in]\nlda     [int]\nlda specifies the first dimension of A.\nif trans = HIPBLAS_OP_N,  lda >= max( 1, n ),\notherwise lda >= max( 1, k ).\n@param[in]\nBP       pointer storing matrix B on the GPU.\nMartrix dimension is ( ldb, k ) when if trans = HIPBLAS_OP_N, otherwise (ldb, n)\nonly the upper/lower triangular part is accessed.\n\n@param[in]\nldb     [int]\nldb specifies the first dimension of B.\nif trans = HIPBLAS_OP_N,  ldb >= max( 1, n ),\notherwise ldb >= max( 1, k ).\n@param[in]\nbeta\nbeta specifies the scalar beta. When beta is\nzero then C need not be set before entry.\n\n@param[in]\nCP       pointer storing matrix C on the GPU.\nThe imaginary component of the diagonal elements are not used but are set to zero unless quick return.\n\n@param[in]\nldc    [int]\nldc specifies the first dimension of C. ldc >= max( 1, n ).\n"]
    pub fn hipblasCher2k(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: ::core::ffi::c_int,
        BP: *const hipblasComplex,
        ldb: ::core::ffi::c_int,
        beta: *const f32,
        CP: *mut hipblasComplex,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZher2k(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        BP: *const hipblasDoubleComplex,
        ldb: ::core::ffi::c_int,
        beta: *const f64,
        CP: *mut hipblasDoubleComplex,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCher2k_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: ::core::ffi::c_int,
        BP: *const hipComplex,
        ldb: ::core::ffi::c_int,
        beta: *const f32,
        CP: *mut hipComplex,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZher2k_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        BP: *const hipDoubleComplex,
        ldb: ::core::ffi::c_int,
        beta: *const f64,
        CP: *mut hipDoubleComplex,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 3 API\n\n\\details\n\nher2kBatched performs a batch of the matrix-matrix operations for a Hermitian rank-2k update\n\nC_i := alpha*op( A_i )*op( B_i )^H + conj(alpha)*op( B_i )*op( A_i )^H + beta*C_i\n\nwhere  alpha and beta are scalars, op(A_i) and op(B_i) are n by k matrices, and\nC_i is a n x n Hermitian matrix stored as either upper or lower.\n\nop( A_i ) = A_i, op( B_i ) = B_i, and A_i and B_i are n by k if trans == HIPBLAS_OP_N\nop( A_i ) = A_i^H, op( B_i ) = B_i^H,  and A_i and B_i are k by n if trans == HIPBLAS_OP_C\n\n- Supported precisions in rocBLAS : c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n\n@param[in]\nuplo    [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER:  C_i is an upper triangular matrix\nHIPBLAS_FILL_MODE_LOWER:  C_i is a  lower triangular matrix\n\n@param[in]\ntransA  [hipblasOperation_t]\nHIPBLAS_OP_C: op(A) = A^H\nHIPBLAS_OP_N: op(A) = A\n\n@param[in]\nn       [int]\nn specifies the number of rows and columns of C_i. n >= 0.\n\n@param[in]\nk       [int]\nk specifies the number of columns of op(A). k >= 0.\n\n@param[in]\nalpha\nalpha specifies the scalar alpha. When alpha is\nzero then A is not referenced and A need not be set before\nentry.\n\n@param[in]\nAP       device array of device pointers storing each matrix_i A of dimension (lda, k)\nwhen trans is HIPBLAS_OP_N, otherwise of dimension (lda, n)\n\n@param[in]\nlda     [int]\nlda specifies the first dimension of A_i.\nif trans = HIPBLAS_OP_N,  lda >= max( 1, n ),\notherwise lda >= max( 1, k ).\n@param[in]\nBP       device array of device pointers storing each matrix_i B of dimension (ldb, k)\nwhen trans is HIPBLAS_OP_N, otherwise of dimension (ldb, n)\n\n@param[in]\nldb     [int]\nldb specifies the first dimension of B_i.\nif trans = HIPBLAS_OP_N,  ldb >= max( 1, n ),\notherwise ldb >= max( 1, k ).\n@param[in]\nbeta\nbeta specifies the scalar beta. When beta is\nzero then C need not be set before entry.\n\n@param[in]\nCP       device array of device pointers storing each matrix C_i on the GPU.\nThe imaginary component of the diagonal elements are not used but are set to zero unless quick return.\n\n@param[in]\nldc    [int]\nldc specifies the first dimension of C. ldc >= max( 1, n ).\n@param[in]\nbatchCount [int]\nnumber of instances in the batch.\n"]
    pub fn hipblasCher2kBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        AP: *const *const hipblasComplex,
        lda: ::core::ffi::c_int,
        BP: *const *const hipblasComplex,
        ldb: ::core::ffi::c_int,
        beta: *const f32,
        CP: *const *mut hipblasComplex,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZher2kBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        BP: *const *const hipblasDoubleComplex,
        ldb: ::core::ffi::c_int,
        beta: *const f64,
        CP: *const *mut hipblasDoubleComplex,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCher2kBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipComplex,
        AP: *const *const hipComplex,
        lda: ::core::ffi::c_int,
        BP: *const *const hipComplex,
        ldb: ::core::ffi::c_int,
        beta: *const f32,
        CP: *const *mut hipComplex,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZher2kBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        BP: *const *const hipDoubleComplex,
        ldb: ::core::ffi::c_int,
        beta: *const f64,
        CP: *const *mut hipDoubleComplex,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 3 API\n\n\\details\n\nher2kStridedBatched performs a batch of the matrix-matrix operations for a Hermitian rank-2k update\n\nC_i := alpha*op( A_i )*op( B_i )^H + conj(alpha)*op( B_i )*op( A_i )^H + beta*C_i\n\nwhere  alpha and beta are scalars, op(A_i) and op(B_i) are n by k matrices, and\nC_i is a n x n Hermitian matrix stored as either upper or lower.\n\nop( A_i ) = A_i, op( B_i ) = B_i, and A_i and B_i are n by k if trans == HIPBLAS_OP_N\nop( A_i ) = A_i^H, op( B_i ) = B_i^H,  and A_i and B_i are k by n if trans == HIPBLAS_OP_C\n\n- Supported precisions in rocBLAS : c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n\n@param[in]\nuplo    [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER:  C_i is an upper triangular matrix\nHIPBLAS_FILL_MODE_LOWER:  C_i is a  lower triangular matrix\n\n@param[in]\ntransA  [hipblasOperation_t]\nHIPBLAS_OP_C: op( A_i ) = A_i^H, op( B_i ) = B_i^H\nHIPBLAS_OP_N: op( A_i ) = A_i, op( B_i ) = B_i\n\n@param[in]\nn       [int]\nn specifies the number of rows and columns of C_i. n >= 0.\n\n@param[in]\nk       [int]\nk specifies the number of columns of op(A). k >= 0.\n\n@param[in]\nalpha\nalpha specifies the scalar alpha. When alpha is\nzero then A is not referenced and A need not be set before\nentry.\n\n@param[in]\nAP       Device pointer to the first matrix A_1 on the GPU of dimension (lda, k)\nwhen trans is HIPBLAS_OP_N, otherwise of dimension (lda, n)\n\n@param[in]\nlda     [int]\nlda specifies the first dimension of A_i.\nif trans = HIPBLAS_OP_N,  lda >= max( 1, n ),\notherwise lda >= max( 1, k ).\n\n@param[in]\nstrideA  [hipblasStride]\nstride from the start of one matrix (A_i) and the next one (A_i+1)\n\n@param[in]\nBP       Device pointer to the first matrix B_1 on the GPU of dimension (ldb, k)\nwhen trans is HIPBLAS_OP_N, otherwise of dimension (ldb, n)\n\n@param[in]\nldb     [int]\nldb specifies the first dimension of B_i.\nif trans = HIPBLAS_OP_N,  ldb >= max( 1, n ),\notherwise ldb >= max( 1, k ).\n\n@param[in]\nstrideB  [hipblasStride]\nstride from the start of one matrix (B_i) and the next one (B_i+1)\n\n@param[in]\nbeta\nbeta specifies the scalar beta. When beta is\nzero then C need not be set before entry.\n\n@param[in]\nCP       Device pointer to the first matrix C_1 on the GPU.\nThe imaginary component of the diagonal elements are not used but are set to zero unless quick return.\n\n@param[in]\nldc    [int]\nldc specifies the first dimension of C. ldc >= max( 1, n ).\n\n@param[inout]\nstrideC  [hipblasStride]\nstride from the start of one matrix (C_i) and the next one (C_i+1)\n\n@param[in]\nbatchCount [int]\nnumber of instances in the batch.\n"]
    pub fn hipblasCher2kStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        BP: *const hipblasComplex,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        beta: *const f32,
        CP: *mut hipblasComplex,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZher2kStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        BP: *const hipblasDoubleComplex,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        beta: *const f64,
        CP: *mut hipblasDoubleComplex,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCher2kStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        BP: *const hipComplex,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        beta: *const f32,
        CP: *mut hipComplex,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZher2kStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        BP: *const hipDoubleComplex,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        beta: *const f64,
        CP: *mut hipDoubleComplex,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 3 API\n\n\\details\n\nsymm performs one of the matrix-matrix operations:\n\nC := alpha*A*B + beta*C if side == HIPBLAS_SIDE_LEFT,\nC := alpha*B*A + beta*C if side == HIPBLAS_SIDE_RIGHT,\n\nwhere alpha and beta are scalars, B and C are m by n matrices, and\nA is a symmetric matrix stored as either upper or lower.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : s,d,c,z\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n\n@param[in]\nside  [hipblasSideMode_t]\nHIPBLAS_SIDE_LEFT:      C := alpha*A*B + beta*C\nHIPBLAS_SIDE_RIGHT:     C := alpha*B*A + beta*C\n\n@param[in]\nuplo    [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER:  A is an upper triangular matrix\nHIPBLAS_FILL_MODE_LOWER:  A is a  lower triangular matrix\n\n@param[in]\nm       [int]\nm specifies the number of rows of B and C. m >= 0.\n\n@param[in]\nn       [int]\nn specifies the number of columns of B and C. n >= 0.\n\n@param[in]\nalpha\nalpha specifies the scalar alpha. When alpha is\nzero then A and B are not referenced.\n\n@param[in]\nAP       pointer storing matrix A on the GPU.\nA is m by m if side == HIPBLAS_SIDE_LEFT\nA is n by n if side == HIPBLAS_SIDE_RIGHT\nonly the upper/lower triangular part is accessed.\n\n@param[in]\nlda     [int]\nlda specifies the first dimension of A.\nif side = HIPBLAS_SIDE_LEFT,  lda >= max( 1, m ),\notherwise lda >= max( 1, n ).\n\n@param[in]\nBP       pointer storing matrix B on the GPU.\nMatrix dimension is m by n\n\n@param[in]\nldb     [int]\nldb specifies the first dimension of B. ldb >= max( 1, m )\n\n@param[in]\nbeta\nbeta specifies the scalar beta. When beta is\nzero then C need not be set before entry.\n\n@param[in]\nCP       pointer storing matrix C on the GPU.\nMatrix dimension is m by n\n\n@param[in]\nldc    [int]\nldc specifies the first dimension of C. ldc >= max( 1, m )\n"]
    pub fn hipblasSsymm(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        AP: *const f32,
        lda: ::core::ffi::c_int,
        BP: *const f32,
        ldb: ::core::ffi::c_int,
        beta: *const f32,
        CP: *mut f32,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsymm(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        AP: *const f64,
        lda: ::core::ffi::c_int,
        BP: *const f64,
        ldb: ::core::ffi::c_int,
        beta: *const f64,
        CP: *mut f64,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsymm(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: ::core::ffi::c_int,
        BP: *const hipblasComplex,
        ldb: ::core::ffi::c_int,
        beta: *const hipblasComplex,
        CP: *mut hipblasComplex,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsymm(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        BP: *const hipblasDoubleComplex,
        ldb: ::core::ffi::c_int,
        beta: *const hipblasDoubleComplex,
        CP: *mut hipblasDoubleComplex,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsymm_v2(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: ::core::ffi::c_int,
        BP: *const hipComplex,
        ldb: ::core::ffi::c_int,
        beta: *const hipComplex,
        CP: *mut hipComplex,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsymm_v2(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        BP: *const hipDoubleComplex,
        ldb: ::core::ffi::c_int,
        beta: *const hipDoubleComplex,
        CP: *mut hipDoubleComplex,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 3 API\n\n\\details\n\nsymmBatched performs a batch of the matrix-matrix operations:\n\nC_i := alpha*A_i*B_i + beta*C_i if side == HIPBLAS_SIDE_LEFT,\nC_i := alpha*B_i*A_i + beta*C_i if side == HIPBLAS_SIDE_RIGHT,\n\nwhere alpha and beta are scalars, B_i and C_i are m by n matrices, and\nA_i is a symmetric matrix stored as either upper or lower.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n\n@param[in]\nside  [hipblasSideMode_t]\nHIPBLAS_SIDE_LEFT:      C_i := alpha*A_i*B_i + beta*C_i\nHIPBLAS_SIDE_RIGHT:     C_i := alpha*B_i*A_i + beta*C_i\n\n@param[in]\nuplo    [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER:  A_i is an upper triangular matrix\nHIPBLAS_FILL_MODE_LOWER:  A_i is a  lower triangular matrix\n\n@param[in]\nm       [int]\nm specifies the number of rows of B_i and C_i. m >= 0.\n\n@param[in]\nn       [int]\nn specifies the number of columns of B_i and C_i. n >= 0.\n\n@param[in]\nalpha\nalpha specifies the scalar alpha. When alpha is\nzero then A_i and B_i are not referenced.\n\n@param[in]\nAP      device array of device pointers storing each matrix A_i on the GPU.\nA_i is m by m if side == HIPBLAS_SIDE_LEFT\nA_i is n by n if side == HIPBLAS_SIDE_RIGHT\nonly the upper/lower triangular part is accessed.\n\n@param[in]\nlda     [int]\nlda specifies the first dimension of A_i.\nif side = HIPBLAS_SIDE_LEFT,  lda >= max( 1, m ),\notherwise lda >= max( 1, n ).\n\n@param[in]\nBP       device array of device pointers storing each matrix B_i on the GPU.\nMatrix dimension is m by n\n\n@param[in]\nldb     [int]\nldb specifies the first dimension of B_i. ldb >= max( 1, m )\n\n@param[in]\nbeta\nbeta specifies the scalar beta. When beta is\nzero then C_i need not be set before entry.\n\n@param[in]\nCP       device array of device pointers storing each matrix C_i on the GPU.\nMatrix dimension is m by n\n\n@param[in]\nldc    [int]\nldc specifies the first dimension of C_i. ldc >= max( 1, m )\n\n@param[in]\nbatchCount [int]\nnumber of instances in the batch.\n"]
    pub fn hipblasSsymmBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        AP: *const *const f32,
        lda: ::core::ffi::c_int,
        BP: *const *const f32,
        ldb: ::core::ffi::c_int,
        beta: *const f32,
        CP: *const *mut f32,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsymmBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        AP: *const *const f64,
        lda: ::core::ffi::c_int,
        BP: *const *const f64,
        ldb: ::core::ffi::c_int,
        beta: *const f64,
        CP: *const *mut f64,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsymmBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        AP: *const *const hipblasComplex,
        lda: ::core::ffi::c_int,
        BP: *const *const hipblasComplex,
        ldb: ::core::ffi::c_int,
        beta: *const hipblasComplex,
        CP: *const *mut hipblasComplex,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsymmBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        BP: *const *const hipblasDoubleComplex,
        ldb: ::core::ffi::c_int,
        beta: *const hipblasDoubleComplex,
        CP: *const *mut hipblasDoubleComplex,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsymmBatched_v2(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipComplex,
        AP: *const *const hipComplex,
        lda: ::core::ffi::c_int,
        BP: *const *const hipComplex,
        ldb: ::core::ffi::c_int,
        beta: *const hipComplex,
        CP: *const *mut hipComplex,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsymmBatched_v2(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        BP: *const *const hipDoubleComplex,
        ldb: ::core::ffi::c_int,
        beta: *const hipDoubleComplex,
        CP: *const *mut hipDoubleComplex,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 3 API\n\n\\details\n\nsymmStridedBatched performs a batch of the matrix-matrix operations:\n\nC_i := alpha*A_i*B_i + beta*C_i if side == HIPBLAS_SIDE_LEFT,\nC_i := alpha*B_i*A_i + beta*C_i if side == HIPBLAS_SIDE_RIGHT,\n\nwhere alpha and beta are scalars, B_i and C_i are m by n matrices, and\nA_i is a symmetric matrix stored as either upper or lower.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n\n@param[in]\nside  [hipblasSideMode_t]\nHIPBLAS_SIDE_LEFT:      C_i := alpha*A_i*B_i + beta*C_i\nHIPBLAS_SIDE_RIGHT:     C_i := alpha*B_i*A_i + beta*C_i\n\n@param[in]\nuplo    [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER:  A_i is an upper triangular matrix\nHIPBLAS_FILL_MODE_LOWER:  A_i is a  lower triangular matrix\n\n@param[in]\nm       [int]\nm specifies the number of rows of B_i and C_i. m >= 0.\n\n@param[in]\nn       [int]\nn specifies the number of columns of B_i and C_i. n >= 0.\n\n@param[in]\nalpha\nalpha specifies the scalar alpha. When alpha is\nzero then A_i and B_i are not referenced.\n\n@param[in]\nAP       device pointer to first matrix A_1\nA_i is m by m if side == HIPBLAS_SIDE_LEFT\nA_i is n by n if side == HIPBLAS_SIDE_RIGHT\nonly the upper/lower triangular part is accessed.\n\n@param[in]\nlda     [int]\nlda specifies the first dimension of A_i.\nif side = HIPBLAS_SIDE_LEFT,  lda >= max( 1, m ),\notherwise lda >= max( 1, n ).\n\n@param[in]\nstrideA  [hipblasStride]\nstride from the start of one matrix (A_i) and the next one (A_i+1)\n\n@param[in]\nBP       device pointer to first matrix B_1 of dimension (ldb, n) on the GPU.\n\n@param[in]\nldb     [int]\nldb specifies the first dimension of B_i. ldb >= max( 1, m )\n\n@param[in]\nstrideB  [hipblasStride]\nstride from the start of one matrix (B_i) and the next one (B_i+1)\n@param[in]\nbeta\nbeta specifies the scalar beta. When beta is\nzero then C need not be set before entry.\n\n@param[in]\nCP        device pointer to first matrix C_1 of dimension (ldc, n) on the GPU.\n\n@param[in]\nldc    [int]\nldc specifies the first dimension of C. ldc >= max( 1, m ).\n\n@param[inout]\nstrideC  [hipblasStride]\nstride from the start of one matrix (C_i) and the next one (C_i+1)\n\n@param[in]\nbatchCount [int]\nnumber of instances in the batch.\n"]
    pub fn hipblasSsymmStridedBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        AP: *const f32,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        BP: *const f32,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        beta: *const f32,
        CP: *mut f32,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsymmStridedBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        AP: *const f64,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        BP: *const f64,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        beta: *const f64,
        CP: *mut f64,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsymmStridedBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        BP: *const hipblasComplex,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        beta: *const hipblasComplex,
        CP: *mut hipblasComplex,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsymmStridedBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        BP: *const hipblasDoubleComplex,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        beta: *const hipblasDoubleComplex,
        CP: *mut hipblasDoubleComplex,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsymmStridedBatched_v2(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        BP: *const hipComplex,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        beta: *const hipComplex,
        CP: *mut hipComplex,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsymmStridedBatched_v2(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        BP: *const hipDoubleComplex,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        beta: *const hipDoubleComplex,
        CP: *mut hipDoubleComplex,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 3 API\n\n\\details\n\nsyrk performs one of the matrix-matrix operations for a symmetric rank-k update\n\nC := alpha*op( A )*op( A )^T + beta*C\n\nwhere  alpha and beta are scalars, op(A) is an n by k matrix, and\nC is a symmetric n x n matrix stored as either upper or lower.\n\nop( A ) = A, and A is n by k if transA == HIPBLAS_OP_N\nop( A ) = A^T and A is k by n if transA == HIPBLAS_OP_T\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : s,d,c,z\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n\n@param[in]\nuplo    [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER:  C is an upper triangular matrix\nHIPBLAS_FILL_MODE_LOWER:  C is a  lower triangular matrix\n\n@param[in]\ntransA  [hipblasOperation_t]\nHIPBLAS_OP_T: op(A) = A^T\nHIPBLAS_OP_N: op(A) = A\nHIPBLAS_OP_C: op(A) = A^T\n\nHIPBLAS_OP_C is not supported for complex types, see cherk\nand zherk.\n\n@param[in]\nn       [int]\nn specifies the number of rows and columns of C. n >= 0.\n\n@param[in]\nk       [int]\nk specifies the number of columns of op(A). k >= 0.\n\n@param[in]\nalpha\nalpha specifies the scalar alpha. When alpha is\nzero then A is not referenced and A need not be set before\nentry.\n\n@param[in]\nAP       pointer storing matrix A on the GPU.\nMartrix dimension is ( lda, k ) when if transA = HIPBLAS_OP_N, otherwise (lda, n)\nonly the upper/lower triangular part is accessed.\n\n@param[in]\nlda     [int]\nlda specifies the first dimension of A.\nif transA = HIPBLAS_OP_N,  lda >= max( 1, n ),\notherwise lda >= max( 1, k ).\n\n@param[in]\nbeta\nbeta specifies the scalar beta. When beta is\nzero then C need not be set before entry.\n\n@param[in]\nCP       pointer storing matrix C on the GPU.\n\n@param[in]\nldc    [int]\nldc specifies the first dimension of C. ldc >= max( 1, n ).\n"]
    pub fn hipblasSsyrk(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const f32,
        AP: *const f32,
        lda: ::core::ffi::c_int,
        beta: *const f32,
        CP: *mut f32,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsyrk(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const f64,
        AP: *const f64,
        lda: ::core::ffi::c_int,
        beta: *const f64,
        CP: *mut f64,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyrk(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: ::core::ffi::c_int,
        beta: *const hipblasComplex,
        CP: *mut hipblasComplex,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyrk(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        beta: *const hipblasDoubleComplex,
        CP: *mut hipblasDoubleComplex,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyrk_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: ::core::ffi::c_int,
        beta: *const hipComplex,
        CP: *mut hipComplex,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyrk_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        beta: *const hipDoubleComplex,
        CP: *mut hipDoubleComplex,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 3 API\n\n\\details\n\nsyrkBatched performs a batch of the matrix-matrix operations for a symmetric rank-k update\n\nC_i := alpha*op( A_i )*op( A_i )^T + beta*C_i\n\nwhere  alpha and beta are scalars, op(A_i) is an n by k matrix, and\nC_i is a symmetric n x n matrix stored as either upper or lower.\n\nop( A_i ) = A_i, and A_i is n by k if transA == HIPBLAS_OP_N\nop( A_i ) = A_i^T and A_i is k by n if transA == HIPBLAS_OP_T\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n\n@param[in]\nuplo    [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER:  C_i is an upper triangular matrix\nHIPBLAS_FILL_MODE_LOWER:  C_i is a  lower triangular matrix\n\n@param[in]\ntransA  [hipblasOperation_t]\nHIPBLAS_OP_T: op(A) = A^T\nHIPBLAS_OP_N: op(A) = A\nHIPBLAS_OP_C: op(A) = A^T\n\nHIPBLAS_OP_C is not supported for complex types, see cherk\nand zherk.\n\n@param[in]\nn       [int]\nn specifies the number of rows and columns of C_i. n >= 0.\n\n@param[in]\nk       [int]\nk specifies the number of columns of op(A). k >= 0.\n\n@param[in]\nalpha\nalpha specifies the scalar alpha. When alpha is\nzero then A is not referenced and A need not be set before\nentry.\n\n@param[in]\nAP       device array of device pointers storing each matrix_i A of dimension (lda, k)\nwhen transA is HIPBLAS_OP_N, otherwise of dimension (lda, n)\n\n@param[in]\nlda     [int]\nlda specifies the first dimension of A_i.\nif transA = HIPBLAS_OP_N,  lda >= max( 1, n ),\notherwise lda >= max( 1, k ).\n\n@param[in]\nbeta\nbeta specifies the scalar beta. When beta is\nzero then C need not be set before entry.\n\n@param[in]\nCP       device array of device pointers storing each matrix C_i on the GPU.\n\n@param[in]\nldc    [int]\nldc specifies the first dimension of C. ldc >= max( 1, n ).\n@param[in]\nbatchCount [int]\nnumber of instances in the batch.\n"]
    pub fn hipblasSsyrkBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const f32,
        AP: *const *const f32,
        lda: ::core::ffi::c_int,
        beta: *const f32,
        CP: *const *mut f32,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsyrkBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const f64,
        AP: *const *const f64,
        lda: ::core::ffi::c_int,
        beta: *const f64,
        CP: *const *mut f64,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyrkBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        AP: *const *const hipblasComplex,
        lda: ::core::ffi::c_int,
        beta: *const hipblasComplex,
        CP: *const *mut hipblasComplex,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyrkBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        beta: *const hipblasDoubleComplex,
        CP: *const *mut hipblasDoubleComplex,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyrkBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipComplex,
        AP: *const *const hipComplex,
        lda: ::core::ffi::c_int,
        beta: *const hipComplex,
        CP: *const *mut hipComplex,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyrkBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        beta: *const hipDoubleComplex,
        CP: *const *mut hipDoubleComplex,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 3 API\n\n\\details\n\nsyrkStridedBatched performs a batch of the matrix-matrix operations for a symmetric rank-k update\n\nC_i := alpha*op( A_i )*op( A_i )^T + beta*C_i\n\nwhere  alpha and beta are scalars, op(A_i) is an n by k matrix, and\nC_i is a symmetric n x n matrix stored as either upper or lower.\n\nop( A_i ) = A_i, and A_i is n by k if transA == HIPBLAS_OP_N\nop( A_i ) = A_i^T and A_i is k by n if transA == HIPBLAS_OP_T\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n\n@param[in]\nuplo    [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER:  C_i is an upper triangular matrix\nHIPBLAS_FILL_MODE_LOWER:  C_i is a  lower triangular matrix\n\n@param[in]\ntransA  [hipblasOperation_t]\nHIPBLAS_OP_T: op(A) = A^T\nHIPBLAS_OP_N: op(A) = A\nHIPBLAS_OP_C: op(A) = A^T\n\nHIPBLAS_OP_C is not supported for complex types, see cherk\nand zherk.\n\n@param[in]\nn       [int]\nn specifies the number of rows and columns of C_i. n >= 0.\n\n@param[in]\nk       [int]\nk specifies the number of columns of op(A). k >= 0.\n\n@param[in]\nalpha\nalpha specifies the scalar alpha. When alpha is\nzero then A is not referenced and A need not be set before\nentry.\n\n@param[in]\nAP       Device pointer to the first matrix A_1 on the GPU of dimension (lda, k)\nwhen transA is HIPBLAS_OP_N, otherwise of dimension (lda, n)\n\n@param[in]\nlda     [int]\nlda specifies the first dimension of A_i.\nif transA = HIPBLAS_OP_N,  lda >= max( 1, n ),\notherwise lda >= max( 1, k ).\n\n@param[in]\nstrideA  [hipblasStride]\nstride from the start of one matrix (A_i) and the next one (A_i+1)\n\n@param[in]\nbeta\nbeta specifies the scalar beta. When beta is\nzero then C need not be set before entry.\n\n@param[in]\nCP       Device pointer to the first matrix C_1 on the GPU. on the GPU.\n\n@param[in]\nldc    [int]\nldc specifies the first dimension of C. ldc >= max( 1, n ).\n\n@param[inout]\nstrideC  [hipblasStride]\nstride from the start of one matrix (C_i) and the next one (C_i+1)\n\n@param[in]\nbatchCount [int]\nnumber of instances in the batch.\n"]
    pub fn hipblasSsyrkStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const f32,
        AP: *const f32,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        beta: *const f32,
        CP: *mut f32,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsyrkStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const f64,
        AP: *const f64,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        beta: *const f64,
        CP: *mut f64,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyrkStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        beta: *const hipblasComplex,
        CP: *mut hipblasComplex,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyrkStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        beta: *const hipblasDoubleComplex,
        CP: *mut hipblasDoubleComplex,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyrkStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        beta: *const hipComplex,
        CP: *mut hipComplex,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyrkStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        beta: *const hipDoubleComplex,
        CP: *mut hipDoubleComplex,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 3 API\n\n\\details\n\nsyr2k performs one of the matrix-matrix operations for a symmetric rank-2k update\n\nC := alpha*(op( A )*op( B )^T + op( B )*op( A )^T) + beta*C\n\nwhere  alpha and beta are scalars, op(A) and op(B) are n by k matrix, and\nC is a symmetric n x n matrix stored as either upper or lower.\n\nop( A ) = A, op( B ) = B, and A and B are n by k if trans == HIPBLAS_OP_N\nop( A ) = A^T, op( B ) = B^T,  and A and B are k by n if trans == HIPBLAS_OP_T\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : s,d,c,z\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n\n@param[in]\nuplo    [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER:  C is an upper triangular matrix\nHIPBLAS_FILL_MODE_LOWER:  C is a  lower triangular matrix\n\n@param[in]\ntransA  [hipblasOperation_t]\nHIPBLAS_OP_T:      op( A ) = A^T, op( B ) = B^T\nHIPBLAS_OP_N:           op( A ) = A, op( B ) = B\n\n@param[in]\nn       [int]\nn specifies the number of rows and columns of C. n >= 0.\n\n@param[in]\nk       [int]\nk specifies the number of columns of op(A) and op(B). k >= 0.\n\n@param[in]\nalpha\nalpha specifies the scalar alpha. When alpha is\nzero then A is not referenced and A need not be set before\nentry.\n\n@param[in]\nAP       pointer storing matrix A on the GPU.\nMartrix dimension is ( lda, k ) when if trans = HIPBLAS_OP_N, otherwise (lda, n)\nonly the upper/lower triangular part is accessed.\n\n@param[in]\nlda     [int]\nlda specifies the first dimension of A.\nif trans = HIPBLAS_OP_N,  lda >= max( 1, n ),\notherwise lda >= max( 1, k ).\n@param[in]\nBP       pointer storing matrix B on the GPU.\nMartrix dimension is ( ldb, k ) when if trans = HIPBLAS_OP_N, otherwise (ldb, n)\nonly the upper/lower triangular part is accessed.\n\n@param[in]\nldb     [int]\nldb specifies the first dimension of B.\nif trans = HIPBLAS_OP_N,  ldb >= max( 1, n ),\notherwise ldb >= max( 1, k ).\n@param[in]\nbeta\nbeta specifies the scalar beta. When beta is\nzero then C need not be set before entry.\n\n@param[in]\nCP       pointer storing matrix C on the GPU.\n\n@param[in]\nldc    [int]\nldc specifies the first dimension of C. ldc >= max( 1, n ).\n"]
    pub fn hipblasSsyr2k(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const f32,
        AP: *const f32,
        lda: ::core::ffi::c_int,
        BP: *const f32,
        ldb: ::core::ffi::c_int,
        beta: *const f32,
        CP: *mut f32,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsyr2k(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const f64,
        AP: *const f64,
        lda: ::core::ffi::c_int,
        BP: *const f64,
        ldb: ::core::ffi::c_int,
        beta: *const f64,
        CP: *mut f64,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyr2k(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: ::core::ffi::c_int,
        BP: *const hipblasComplex,
        ldb: ::core::ffi::c_int,
        beta: *const hipblasComplex,
        CP: *mut hipblasComplex,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyr2k(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        BP: *const hipblasDoubleComplex,
        ldb: ::core::ffi::c_int,
        beta: *const hipblasDoubleComplex,
        CP: *mut hipblasDoubleComplex,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyr2k_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: ::core::ffi::c_int,
        BP: *const hipComplex,
        ldb: ::core::ffi::c_int,
        beta: *const hipComplex,
        CP: *mut hipComplex,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyr2k_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        BP: *const hipDoubleComplex,
        ldb: ::core::ffi::c_int,
        beta: *const hipDoubleComplex,
        CP: *mut hipDoubleComplex,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 3 API\n\n\\details\n\nsyr2kBatched performs a batch of the matrix-matrix operations for a symmetric rank-2k update\n\nC_i := alpha*(op( A_i )*op( B_i )^T + op( B_i )*op( A_i )^T) + beta*C_i\n\nwhere  alpha and beta are scalars, op(A_i) and op(B_i) are n by k matrix, and\nC_i is a symmetric n x n matrix stored as either upper or lower.\n\nop( A_i ) = A_i, op( B_i ) = B_i, and A_i and B_i are n by k if trans == HIPBLAS_OP_N\nop( A_i ) = A_i^T, op( B_i ) = B_i^T,  and A_i and B_i are k by n if trans == HIPBLAS_OP_T\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n\n@param[in]\nuplo    [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER:  C_i is an upper triangular matrix\nHIPBLAS_FILL_MODE_LOWER:  C_i is a  lower triangular matrix\n\n@param[in]\ntransA  [hipblasOperation_t]\nHIPBLAS_OP_T:      op( A_i ) = A_i^T, op( B_i ) = B_i^T\nHIPBLAS_OP_N:           op( A_i ) = A_i, op( B_i ) = B_i\n\n@param[in]\nn       [int]\nn specifies the number of rows and columns of C_i. n >= 0.\n\n@param[in]\nk       [int]\nk specifies the number of columns of op(A). k >= 0.\n\n@param[in]\nalpha\nalpha specifies the scalar alpha. When alpha is\nzero then A is not referenced and A need not be set before\nentry.\n\n@param[in]\nAP       device array of device pointers storing each matrix_i A of dimension (lda, k)\nwhen trans is HIPBLAS_OP_N, otherwise of dimension (lda, n)\n\n@param[in]\nlda     [int]\nlda specifies the first dimension of A_i.\nif trans = HIPBLAS_OP_N,  lda >= max( 1, n ),\notherwise lda >= max( 1, k ).\n@param[in]\nBP      device array of device pointers storing each matrix_i B of dimension (ldb, k)\nwhen trans is HIPBLAS_OP_N, otherwise of dimension (ldb, n)\n@param[in]\nldb     [int]\nldb specifies the first dimension of B.\nif trans = HIPBLAS_OP_N,  ldb >= max( 1, n ),\notherwise ldb >= max( 1, k ).\n@param[in]\nbeta\nbeta specifies the scalar beta. When beta is\nzero then C need not be set before entry.\n\n@param[in]\nCP      device array of device pointers storing each matrix C_i on the GPU.\n\n@param[in]\nldc    [int]\nldc specifies the first dimension of C. ldc >= max( 1, n ).\n@param[in]\nbatchCount [int]\nnumber of instances in the batch.\n"]
    pub fn hipblasSsyr2kBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const f32,
        AP: *const *const f32,
        lda: ::core::ffi::c_int,
        BP: *const *const f32,
        ldb: ::core::ffi::c_int,
        beta: *const f32,
        CP: *const *mut f32,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsyr2kBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const f64,
        AP: *const *const f64,
        lda: ::core::ffi::c_int,
        BP: *const *const f64,
        ldb: ::core::ffi::c_int,
        beta: *const f64,
        CP: *const *mut f64,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyr2kBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        AP: *const *const hipblasComplex,
        lda: ::core::ffi::c_int,
        BP: *const *const hipblasComplex,
        ldb: ::core::ffi::c_int,
        beta: *const hipblasComplex,
        CP: *const *mut hipblasComplex,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyr2kBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        BP: *const *const hipblasDoubleComplex,
        ldb: ::core::ffi::c_int,
        beta: *const hipblasDoubleComplex,
        CP: *const *mut hipblasDoubleComplex,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyr2kBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipComplex,
        AP: *const *const hipComplex,
        lda: ::core::ffi::c_int,
        BP: *const *const hipComplex,
        ldb: ::core::ffi::c_int,
        beta: *const hipComplex,
        CP: *const *mut hipComplex,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyr2kBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        BP: *const *const hipDoubleComplex,
        ldb: ::core::ffi::c_int,
        beta: *const hipDoubleComplex,
        CP: *const *mut hipDoubleComplex,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 3 API\n\n\\details\n\nsyr2kStridedBatched performs a batch of the matrix-matrix operations for a symmetric rank-2k update\n\nC_i := alpha*(op( A_i )*op( B_i )^T + op( B_i )*op( A_i )^T) + beta*C_i\n\nwhere  alpha and beta are scalars, op(A_i) and op(B_i) are n by k matrix, and\nC_i is a symmetric n x n matrix stored as either upper or lower.\n\nop( A_i ) = A_i, op( B_i ) = B_i, and A_i and B_i are n by k if trans == HIPBLAS_OP_N\nop( A_i ) = A_i^T, op( B_i ) = B_i^T,  and A_i and B_i are k by n if trans == HIPBLAS_OP_T\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n\n@param[in]\nuplo    [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER:  C_i is an upper triangular matrix\nHIPBLAS_FILL_MODE_LOWER:  C_i is a  lower triangular matrix\n\n@param[in]\ntransA  [hipblasOperation_t]\nHIPBLAS_OP_T:      op( A_i ) = A_i^T, op( B_i ) = B_i^T\nHIPBLAS_OP_N:           op( A_i ) = A_i, op( B_i ) = B_i\n\n@param[in]\nn       [int]\nn specifies the number of rows and columns of C_i. n >= 0.\n\n@param[in]\nk       [int]\nk specifies the number of columns of op(A). k >= 0.\n\n@param[in]\nalpha\nalpha specifies the scalar alpha. When alpha is\nzero then A is not referenced and A need not be set before\nentry.\n\n@param[in]\nAP       Device pointer to the first matrix A_1 on the GPU of dimension (lda, k)\nwhen trans is HIPBLAS_OP_N, otherwise of dimension (lda, n)\n\n@param[in]\nlda     [int]\nlda specifies the first dimension of A_i.\nif trans = HIPBLAS_OP_N,  lda >= max( 1, n ),\notherwise lda >= max( 1, k ).\n\n@param[in]\nstrideA  [hipblasStride]\nstride from the start of one matrix (A_i) and the next one (A_i+1)\n\n@param[in]\nBP       Device pointer to the first matrix B_1 on the GPU of dimension (ldb, k)\nwhen trans is HIPBLAS_OP_N, otherwise of dimension (ldb, n)\n\n@param[in]\nldb     [int]\nldb specifies the first dimension of B_i.\nif trans = HIPBLAS_OP_N,  ldb >= max( 1, n ),\notherwise ldb >= max( 1, k ).\n\n@param[in]\nstrideB  [hipblasStride]\nstride from the start of one matrix (B_i) and the next one (B_i+1)\n\n@param[in]\nbeta\nbeta specifies the scalar beta. When beta is\nzero then C need not be set before entry.\n\n@param[in]\nCP       Device pointer to the first matrix C_1 on the GPU.\n\n@param[in]\nldc    [int]\nldc specifies the first dimension of C. ldc >= max( 1, n ).\n\n@param[inout]\nstrideC  [hipblasStride]\nstride from the start of one matrix (C_i) and the next one (C_i+1)\n\n@param[in]\nbatchCount [int]\nnumber of instances in the batch.\n"]
    pub fn hipblasSsyr2kStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const f32,
        AP: *const f32,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        BP: *const f32,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        beta: *const f32,
        CP: *mut f32,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsyr2kStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const f64,
        AP: *const f64,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        BP: *const f64,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        beta: *const f64,
        CP: *mut f64,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyr2kStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        BP: *const hipblasComplex,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        beta: *const hipblasComplex,
        CP: *mut hipblasComplex,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyr2kStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        BP: *const hipblasDoubleComplex,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        beta: *const hipblasDoubleComplex,
        CP: *mut hipblasDoubleComplex,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyr2kStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        BP: *const hipComplex,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        beta: *const hipComplex,
        CP: *mut hipComplex,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyr2kStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        BP: *const hipDoubleComplex,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        beta: *const hipDoubleComplex,
        CP: *mut hipDoubleComplex,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 3 API\n\n\\details\n\nsyrkx performs one of the matrix-matrix operations for a symmetric rank-k update\n\nC := alpha*op( A )*op( B )^T + beta*C\n\nwhere  alpha and beta are scalars, op(A) and op(B) are n by k matrix, and\nC is a symmetric n x n matrix stored as either upper or lower.\nThis routine should only be used when the caller can guarantee that the result of op( A )*op( B )^T will be symmetric.\n\nop( A ) = A, op( B ) = B, and A and B are n by k if trans == HIPBLAS_OP_N\nop( A ) = A^T, op( B ) = B^T,  and A and B are k by n if trans == HIPBLAS_OP_T\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : s,d,c,z\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n\n@param[in]\nuplo    [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER:  C is an upper triangular matrix\nHIPBLAS_FILL_MODE_LOWER:  C is a  lower triangular matrix\n\n@param[in]\ntransA  [hipblasOperation_t]\nHIPBLAS_OP_T:      op( A ) = A^T, op( B ) = B^T\nHIPBLAS_OP_N:           op( A ) = A, op( B ) = B\n\n@param[in]\nn       [int]\nn specifies the number of rows and columns of C. n >= 0.\n\n@param[in]\nk       [int]\nk specifies the number of columns of op(A) and op(B). k >= 0.\n\n@param[in]\nalpha\nalpha specifies the scalar alpha. When alpha is\nzero then A is not referenced and A need not be set before\nentry.\n\n@param[in]\nAP       pointer storing matrix A on the GPU.\nMartrix dimension is ( lda, k ) when if trans = HIPBLAS_OP_N, otherwise (lda, n)\nonly the upper/lower triangular part is accessed.\n\n@param[in]\nlda     [int]\nlda specifies the first dimension of A.\nif trans = HIPBLAS_OP_N,  lda >= max( 1, n ),\notherwise lda >= max( 1, k ).\n\n@param[in]\nBP       pointer storing matrix B on the GPU.\nMartrix dimension is ( ldb, k ) when if trans = HIPBLAS_OP_N, otherwise (ldb, n)\nonly the upper/lower triangular part is accessed.\n\n@param[in]\nldb     [int]\nldb specifies the first dimension of B.\nif trans = HIPBLAS_OP_N,  ldb >= max( 1, n ),\notherwise ldb >= max( 1, k ).\n\n@param[in]\nbeta\nbeta specifies the scalar beta. When beta is\nzero then C need not be set before entry.\n\n@param[in]\nCP       pointer storing matrix C on the GPU.\n\n@param[in]\nldc    [int]\nldc specifies the first dimension of C. ldc >= max( 1, n ).\n"]
    pub fn hipblasSsyrkx(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const f32,
        AP: *const f32,
        lda: ::core::ffi::c_int,
        BP: *const f32,
        ldb: ::core::ffi::c_int,
        beta: *const f32,
        CP: *mut f32,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsyrkx(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const f64,
        AP: *const f64,
        lda: ::core::ffi::c_int,
        BP: *const f64,
        ldb: ::core::ffi::c_int,
        beta: *const f64,
        CP: *mut f64,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyrkx(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: ::core::ffi::c_int,
        BP: *const hipblasComplex,
        ldb: ::core::ffi::c_int,
        beta: *const hipblasComplex,
        CP: *mut hipblasComplex,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyrkx(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        BP: *const hipblasDoubleComplex,
        ldb: ::core::ffi::c_int,
        beta: *const hipblasDoubleComplex,
        CP: *mut hipblasDoubleComplex,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyrkx_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: ::core::ffi::c_int,
        BP: *const hipComplex,
        ldb: ::core::ffi::c_int,
        beta: *const hipComplex,
        CP: *mut hipComplex,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyrkx_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        BP: *const hipDoubleComplex,
        ldb: ::core::ffi::c_int,
        beta: *const hipDoubleComplex,
        CP: *mut hipDoubleComplex,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 3 API\n\n\\details\n\nsyrkxBatched performs a batch of the matrix-matrix operations for a symmetric rank-k update\n\nC_i := alpha*op( A_i )*op( B_i )^T + beta*C_i\n\nwhere  alpha and beta are scalars, op(A_i) and op(B_i) are n by k matrix, and\nC_i is a symmetric n x n matrix stored as either upper or lower.\nThis routine should only be used when the caller can guarantee that the result of op( A_i )*op( B_i )^T will be symmetric.\n\nop( A_i ) = A_i, op( B_i ) = B_i, and A_i and B_i are n by k if trans == HIPBLAS_OP_N\nop( A_i ) = A_i^T, op( B_i ) = B_i^T,  and A_i and B_i are k by n if trans == HIPBLAS_OP_T\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n\n@param[in]\nuplo    [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER:  C_i is an upper triangular matrix\nHIPBLAS_FILL_MODE_LOWER:  C_i is a  lower triangular matrix\n\n@param[in]\ntransA  [hipblasOperation_t]\nHIPBLAS_OP_T:      op( A_i ) = A_i^T, op( B_i ) = B_i^T\nHIPBLAS_OP_N:           op( A_i ) = A_i, op( B_i ) = B_i\n\n@param[in]\nn       [int]\nn specifies the number of rows and columns of C_i. n >= 0.\n\n@param[in]\nk       [int]\nk specifies the number of columns of op(A). k >= 0.\n\n@param[in]\nalpha\nalpha specifies the scalar alpha. When alpha is\nzero then A is not referenced and A need not be set before\nentry.\n\n@param[in]\nAP       device array of device pointers storing each matrix_i A of dimension (lda, k)\nwhen trans is HIPBLAS_OP_N, otherwise of dimension (lda, n)\n\n@param[in]\nlda     [int]\nlda specifies the first dimension of A_i.\nif trans = HIPBLAS_OP_N,  lda >= max( 1, n ),\notherwise lda >= max( 1, k ).\n\n@param[in]\nBP       device array of device pointers storing each matrix_i B of dimension (ldb, k)\nwhen trans is HIPBLAS_OP_N, otherwise of dimension (ldb, n)\n\n@param[in]\nldb     [int]\nldb specifies the first dimension of B.\nif trans = HIPBLAS_OP_N,  ldb >= max( 1, n ),\notherwise ldb >= max( 1, k ).\n\n@param[in]\nbeta\nbeta specifies the scalar beta. When beta is\nzero then C need not be set before entry.\n\n@param[in]\nCP       device array of device pointers storing each matrix C_i on the GPU.\n\n@param[in]\nldc    [int]\nldc specifies the first dimension of C. ldc >= max( 1, n ).\n\n@param[in]\nbatchCount [int]\nnumber of instances in the batch.\n"]
    pub fn hipblasSsyrkxBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const f32,
        AP: *const *const f32,
        lda: ::core::ffi::c_int,
        BP: *const *const f32,
        ldb: ::core::ffi::c_int,
        beta: *const f32,
        CP: *const *mut f32,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsyrkxBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const f64,
        AP: *const *const f64,
        lda: ::core::ffi::c_int,
        BP: *const *const f64,
        ldb: ::core::ffi::c_int,
        beta: *const f64,
        CP: *const *mut f64,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyrkxBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        AP: *const *const hipblasComplex,
        lda: ::core::ffi::c_int,
        BP: *const *const hipblasComplex,
        ldb: ::core::ffi::c_int,
        beta: *const hipblasComplex,
        CP: *const *mut hipblasComplex,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyrkxBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        BP: *const *const hipblasDoubleComplex,
        ldb: ::core::ffi::c_int,
        beta: *const hipblasDoubleComplex,
        CP: *const *mut hipblasDoubleComplex,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyrkxBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipComplex,
        AP: *const *const hipComplex,
        lda: ::core::ffi::c_int,
        BP: *const *const hipComplex,
        ldb: ::core::ffi::c_int,
        beta: *const hipComplex,
        CP: *const *mut hipComplex,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyrkxBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        BP: *const *const hipDoubleComplex,
        ldb: ::core::ffi::c_int,
        beta: *const hipDoubleComplex,
        CP: *const *mut hipDoubleComplex,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 3 API\n\n\\details\n\nsyrkxStridedBatched performs a batch of the matrix-matrix operations for a symmetric rank-k update\n\nC_i := alpha*op( A_i )*op( B_i )^T + beta*C_i\n\nwhere  alpha and beta are scalars, op(A_i) and op(B_i) are n by k matrix, and\nC_i is a symmetric n x n matrix stored as either upper or lower.\nThis routine should only be used when the caller can guarantee that the result of op( A_i )*op( B_i )^T will be symmetric.\n\nop( A_i ) = A_i, op( B_i ) = B_i, and A_i and B_i are n by k if trans == HIPBLAS_OP_N\nop( A_i ) = A_i^T, op( B_i ) = B_i^T,  and A_i and B_i are k by n if trans == HIPBLAS_OP_T\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n\n@param[in]\nuplo    [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER:  C_i is an upper triangular matrix\nHIPBLAS_FILL_MODE_LOWER:  C_i is a  lower triangular matrix\n\n@param[in]\ntransA  [hipblasOperation_t]\nHIPBLAS_OP_T:      op( A_i ) = A_i^T, op( B_i ) = B_i^T\nHIPBLAS_OP_N:           op( A_i ) = A_i, op( B_i ) = B_i\n\n@param[in]\nn       [int]\nn specifies the number of rows and columns of C_i. n >= 0.\n\n@param[in]\nk       [int]\nk specifies the number of columns of op(A). k >= 0.\n\n@param[in]\nalpha\nalpha specifies the scalar alpha. When alpha is\nzero then A is not referenced and A need not be set before\nentry.\n\n@param[in]\nAP       Device pointer to the first matrix A_1 on the GPU of dimension (lda, k)\nwhen trans is HIPBLAS_OP_N, otherwise of dimension (lda, n)\n\n@param[in]\nlda     [int]\nlda specifies the first dimension of A_i.\nif trans = HIPBLAS_OP_N,  lda >= max( 1, n ),\notherwise lda >= max( 1, k ).\n\n@param[in]\nstrideA  [hipblasStride]\nstride from the start of one matrix (A_i) and the next one (A_i+1)\n\n@param[in]\nBP       Device pointer to the first matrix B_1 on the GPU of dimension (ldb, k)\nwhen trans is HIPBLAS_OP_N, otherwise of dimension (ldb, n)\n\n@param[in]\nldb     [int]\nldb specifies the first dimension of B_i.\nif trans = HIPBLAS_OP_N,  ldb >= max( 1, n ),\notherwise ldb >= max( 1, k ).\n\n@param[in]\nstrideB  [hipblasStride]\nstride from the start of one matrix (B_i) and the next one (B_i+1)\n\n@param[in]\nbeta\nbeta specifies the scalar beta. When beta is\nzero then C need not be set before entry.\n\n@param[in]\nCP       Device pointer to the first matrix C_1 on the GPU.\n\n@param[in]\nldc    [int]\nldc specifies the first dimension of C. ldc >= max( 1, n ).\n\n@param[inout]\nstrideC  [hipblasStride]\nstride from the start of one matrix (C_i) and the next one (C_i+1)\n\n@param[in]\nbatchCount [int]\nnumber of instances in the batch.\n"]
    pub fn hipblasSsyrkxStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const f32,
        AP: *const f32,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        BP: *const f32,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        beta: *const f32,
        CP: *mut f32,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDsyrkxStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const f64,
        AP: *const f64,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        BP: *const f64,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        beta: *const f64,
        CP: *mut f64,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyrkxStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        BP: *const hipblasComplex,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        beta: *const hipblasComplex,
        CP: *mut hipblasComplex,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyrkxStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        BP: *const hipblasDoubleComplex,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        beta: *const hipblasDoubleComplex,
        CP: *mut hipblasDoubleComplex,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCsyrkxStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        BP: *const hipComplex,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        beta: *const hipComplex,
        CP: *mut hipComplex,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZsyrkxStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        BP: *const hipDoubleComplex,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        beta: *const hipDoubleComplex,
        CP: *mut hipDoubleComplex,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 3 API\n\n\\details\ngeam performs one of the matrix-matrix operations\n\nC = alpha*op( A ) + beta*op( B ),\n\nwhere op( X ) is one of\n\nop( X ) = X      or\nop( X ) = X**T   or\nop( X ) = X**H,\n\nalpha and beta are scalars, and A, B and C are matrices, with\nop( A ) an m by n matrix, op( B ) an m by n matrix, and C an m by n matrix.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : s,d,c,z\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\ntransA    [hipblasOperation_t]\nspecifies the form of op( A )\n@param[in]\ntransB    [hipblasOperation_t]\nspecifies the form of op( B )\n@param[in]\nm         [int]\nmatrix dimension m.\n@param[in]\nn         [int]\nmatrix dimension n.\n@param[in]\nalpha     device pointer or host pointer specifying the scalar alpha.\n@param[in]\nAP         device pointer storing matrix A.\n@param[in]\nlda       [int]\nspecifies the leading dimension of A.\n@param[in]\nbeta      device pointer or host pointer specifying the scalar beta.\n@param[in]\nBP         device pointer storing matrix B.\n@param[in]\nldb       [int]\nspecifies the leading dimension of B.\n@param[in, out]\nCP         device pointer storing matrix C.\n@param[in]\nldc       [int]\nspecifies the leading dimension of C.\n"]
    pub fn hipblasSgeam(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        AP: *const f32,
        lda: ::core::ffi::c_int,
        beta: *const f32,
        BP: *const f32,
        ldb: ::core::ffi::c_int,
        CP: *mut f32,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgeam(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        AP: *const f64,
        lda: ::core::ffi::c_int,
        beta: *const f64,
        BP: *const f64,
        ldb: ::core::ffi::c_int,
        CP: *mut f64,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgeam(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: ::core::ffi::c_int,
        beta: *const hipblasComplex,
        BP: *const hipblasComplex,
        ldb: ::core::ffi::c_int,
        CP: *mut hipblasComplex,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgeam(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        beta: *const hipblasDoubleComplex,
        BP: *const hipblasDoubleComplex,
        ldb: ::core::ffi::c_int,
        CP: *mut hipblasDoubleComplex,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgeam_v2(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: ::core::ffi::c_int,
        beta: *const hipComplex,
        BP: *const hipComplex,
        ldb: ::core::ffi::c_int,
        CP: *mut hipComplex,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgeam_v2(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        beta: *const hipDoubleComplex,
        BP: *const hipDoubleComplex,
        ldb: ::core::ffi::c_int,
        CP: *mut hipDoubleComplex,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 3 API\n\n\\details\ngeamBatched performs one of the batched matrix-matrix operations\n\nC_i = alpha*op( A_i ) + beta*op( B_i )  for i = 0, 1, ... batchCount - 1\n\nwhere alpha and beta are scalars, and op(A_i), op(B_i) and C_i are m by n matrices\nand op( X ) is one of\n\nop( X ) = X      or\nop( X ) = X**T\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\ntransA    [hipblasOperation_t]\nspecifies the form of op( A )\n@param[in]\ntransB    [hipblasOperation_t]\nspecifies the form of op( B )\n@param[in]\nm         [int]\nmatrix dimension m.\n@param[in]\nn         [int]\nmatrix dimension n.\n@param[in]\nalpha     device pointer or host pointer specifying the scalar alpha.\n@param[in]\nAP         device array of device pointers storing each matrix A_i on the GPU.\nEach A_i is of dimension ( lda, k ), where k is m\nwhen  transA == HIPBLAS_OP_N and\nis  n  when  transA == HIPBLAS_OP_T.\n@param[in]\nlda       [int]\nspecifies the leading dimension of A.\n@param[in]\nbeta      device pointer or host pointer specifying the scalar beta.\n@param[in]\nBP         device array of device pointers storing each matrix B_i on the GPU.\nEach B_i is of dimension ( ldb, k ), where k is m\nwhen  transB == HIPBLAS_OP_N and\nis  n  when  transB == HIPBLAS_OP_T.\n@param[in]\nldb       [int]\nspecifies the leading dimension of B.\n@param[in, out]\nCP         device array of device pointers storing each matrix C_i on the GPU.\nEach C_i is of dimension ( ldc, n ).\n@param[in]\nldc       [int]\nspecifies the leading dimension of C.\n\n@param[in]\nbatchCount [int]\nnumber of instances i in the batch.\n"]
    pub fn hipblasSgeamBatched(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        AP: *const *const f32,
        lda: ::core::ffi::c_int,
        beta: *const f32,
        BP: *const *const f32,
        ldb: ::core::ffi::c_int,
        CP: *const *mut f32,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgeamBatched(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        AP: *const *const f64,
        lda: ::core::ffi::c_int,
        beta: *const f64,
        BP: *const *const f64,
        ldb: ::core::ffi::c_int,
        CP: *const *mut f64,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgeamBatched(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        AP: *const *const hipblasComplex,
        lda: ::core::ffi::c_int,
        beta: *const hipblasComplex,
        BP: *const *const hipblasComplex,
        ldb: ::core::ffi::c_int,
        CP: *const *mut hipblasComplex,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgeamBatched(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        beta: *const hipblasDoubleComplex,
        BP: *const *const hipblasDoubleComplex,
        ldb: ::core::ffi::c_int,
        CP: *const *mut hipblasDoubleComplex,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgeamBatched_v2(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipComplex,
        AP: *const *const hipComplex,
        lda: ::core::ffi::c_int,
        beta: *const hipComplex,
        BP: *const *const hipComplex,
        ldb: ::core::ffi::c_int,
        CP: *const *mut hipComplex,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgeamBatched_v2(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        beta: *const hipDoubleComplex,
        BP: *const *const hipDoubleComplex,
        ldb: ::core::ffi::c_int,
        CP: *const *mut hipDoubleComplex,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 3 API\n\n\\details\ngeamStridedBatched performs one of the batched matrix-matrix operations\n\nC_i = alpha*op( A_i ) + beta*op( B_i )  for i = 0, 1, ... batchCount - 1\n\nwhere alpha and beta are scalars, and op(A_i), op(B_i) and C_i are m by n matrices\nand op( X ) is one of\n\nop( X ) = X      or\nop( X ) = X**T\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n\n@param[in]\ntransA    [hipblasOperation_t]\nspecifies the form of op( A )\n\n@param[in]\ntransB    [hipblasOperation_t]\nspecifies the form of op( B )\n\n@param[in]\nm         [int]\nmatrix dimension m.\n\n@param[in]\nn         [int]\nmatrix dimension n.\n\n@param[in]\nalpha     device pointer or host pointer specifying the scalar alpha.\n\n@param[in]\nAP         device pointer to the first matrix A_0 on the GPU.\nEach A_i is of dimension ( lda, k ), where k is m\nwhen  transA == HIPBLAS_OP_N and\nis  n  when  transA == HIPBLAS_OP_T.\n\n@param[in]\nlda       [int]\nspecifies the leading dimension of A.\n\n@param[in]\nstrideA  [hipblasStride]\nstride from the start of one matrix (A_i) and the next one (A_i+1)\n\n@param[in]\nbeta      device pointer or host pointer specifying the scalar beta.\n\n@param[in]\nBP         pointer to the first matrix B_0 on the GPU.\nEach B_i is of dimension ( ldb, k ), where k is m\nwhen  transB == HIPBLAS_OP_N and\nis  n  when  transB == HIPBLAS_OP_T.\n\n@param[in]\nldb       [int]\nspecifies the leading dimension of B.\n\n@param[in]\nstrideB  [hipblasStride]\nstride from the start of one matrix (B_i) and the next one (B_i+1)\n\n@param[in, out]\nCP         pointer to the first matrix C_0 on the GPU.\nEach C_i is of dimension ( ldc, n ).\n\n@param[in]\nldc       [int]\nspecifies the leading dimension of C.\n\n@param[in]\nstrideC  [hipblasStride]\nstride from the start of one matrix (C_i) and the next one (C_i+1)\n\n@param[in]\nbatchCount [int]\nnumber of instances i in the batch.\n"]
    pub fn hipblasSgeamStridedBatched(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        AP: *const f32,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        beta: *const f32,
        BP: *const f32,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        CP: *mut f32,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgeamStridedBatched(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        AP: *const f64,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        beta: *const f64,
        BP: *const f64,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        CP: *mut f64,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgeamStridedBatched(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        beta: *const hipblasComplex,
        BP: *const hipblasComplex,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        CP: *mut hipblasComplex,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgeamStridedBatched(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        beta: *const hipblasDoubleComplex,
        BP: *const hipblasDoubleComplex,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        CP: *mut hipblasDoubleComplex,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgeamStridedBatched_v2(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        beta: *const hipComplex,
        BP: *const hipComplex,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        CP: *mut hipComplex,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgeamStridedBatched_v2(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        beta: *const hipDoubleComplex,
        BP: *const hipDoubleComplex,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        CP: *mut hipDoubleComplex,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 3 API\n\n\\details\n\nhemm performs one of the matrix-matrix operations:\n\nC := alpha*A*B + beta*C if side == HIPBLAS_SIDE_LEFT,\nC := alpha*B*A + beta*C if side == HIPBLAS_SIDE_RIGHT,\n\nwhere alpha and beta are scalars, B and C are m by n matrices, and\nA is a Hermitian matrix stored as either upper or lower.\n\n- Supported precisions in rocBLAS : c,z\n- Supported precisions in cuBLAS  : c,z\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n\n@param[in]\nside  [hipblasSideMode_t]\nHIPBLAS_SIDE_LEFT:      C := alpha*A*B + beta*C\nHIPBLAS_SIDE_RIGHT:     C := alpha*B*A + beta*C\n\n@param[in]\nuplo    [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER:  A is an upper triangular matrix\nHIPBLAS_FILL_MODE_LOWER:  A is a  lower triangular matrix\n\n@param[in]\nn       [int]\nn specifies the number of rows of B and C. n >= 0.\n\n@param[in]\nk       [int]\nn specifies the number of columns of B and C. k >= 0.\n\n@param[in]\nalpha\nalpha specifies the scalar alpha. When alpha is\nzero then A and B are not referenced.\n\n@param[in]\nAP       pointer storing matrix A on the GPU.\nA is m by m if side == HIPBLAS_SIDE_LEFT\nA is n by n if side == HIPBLAS_SIDE_RIGHT\nOnly the upper/lower triangular part is accessed.\nThe imaginary component of the diagonal elements is not used.\n\n@param[in]\nlda     [int]\nlda specifies the first dimension of A.\nif side = HIPBLAS_SIDE_LEFT,  lda >= max( 1, m ),\notherwise lda >= max( 1, n ).\n\n@param[in]\nBP       pointer storing matrix B on the GPU.\nMatrix dimension is m by n\n\n@param[in]\nldb     [int]\nldb specifies the first dimension of B. ldb >= max( 1, m )\n\n@param[in]\nbeta\nbeta specifies the scalar beta. When beta is\nzero then C need not be set before entry.\n\n@param[in]\nCP       pointer storing matrix C on the GPU.\nMatrix dimension is m by n\n\n@param[in]\nldc    [int]\nldc specifies the first dimension of C. ldc >= max( 1, m )\n"]
    pub fn hipblasChemm(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: ::core::ffi::c_int,
        BP: *const hipblasComplex,
        ldb: ::core::ffi::c_int,
        beta: *const hipblasComplex,
        CP: *mut hipblasComplex,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhemm(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        BP: *const hipblasDoubleComplex,
        ldb: ::core::ffi::c_int,
        beta: *const hipblasDoubleComplex,
        CP: *mut hipblasDoubleComplex,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChemm_v2(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: ::core::ffi::c_int,
        BP: *const hipComplex,
        ldb: ::core::ffi::c_int,
        beta: *const hipComplex,
        CP: *mut hipComplex,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhemm_v2(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        BP: *const hipDoubleComplex,
        ldb: ::core::ffi::c_int,
        beta: *const hipDoubleComplex,
        CP: *mut hipDoubleComplex,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 3 API\n\n\\details\n\nhemmBatched performs a batch of the matrix-matrix operations:\n\nC_i := alpha*A_i*B_i + beta*C_i if side == HIPBLAS_SIDE_LEFT,\nC_i := alpha*B_i*A_i + beta*C_i if side == HIPBLAS_SIDE_RIGHT,\n\nwhere alpha and beta are scalars, B_i and C_i are m by n matrices, and\nA_i is a Hermitian matrix stored as either upper or lower.\n\n- Supported precisions in rocBLAS : c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n\n@param[in]\nside  [hipblasSideMode_t]\nHIPBLAS_SIDE_LEFT:      C_i := alpha*A_i*B_i + beta*C_i\nHIPBLAS_SIDE_RIGHT:     C_i := alpha*B_i*A_i + beta*C_i\n\n@param[in]\nuplo    [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER:  A_i is an upper triangular matrix\nHIPBLAS_FILL_MODE_LOWER:  A_i is a  lower triangular matrix\n\n@param[in]\nn       [int]\nn specifies the number of rows of B_i and C_i. n >= 0.\n\n@param[in]\nk       [int]\nk specifies the number of columns of B_i and C_i. k >= 0.\n\n@param[in]\nalpha\nalpha specifies the scalar alpha. When alpha is\nzero then A_i and B_i are not referenced.\n\n@param[in]\nAP       device array of device pointers storing each matrix A_i on the GPU.\nA_i is m by m if side == HIPBLAS_SIDE_LEFT\nA_i is n by n if side == HIPBLAS_SIDE_RIGHT\nOnly the upper/lower triangular part is accessed.\nThe imaginary component of the diagonal elements is not used.\n\n@param[in]\nlda     [int]\nlda specifies the first dimension of A_i.\nif side = HIPBLAS_SIDE_LEFT,  lda >= max( 1, m ),\notherwise lda >= max( 1, n ).\n\n@param[in]\nBP       device array of device pointers storing each matrix B_i on the GPU.\nMatrix dimension is m by n\n\n@param[in]\nldb     [int]\nldb specifies the first dimension of B_i. ldb >= max( 1, m )\n\n@param[in]\nbeta\nbeta specifies the scalar beta. When beta is\nzero then C_i need not be set before entry.\n\n@param[in]\nCP       device array of device pointers storing each matrix C_i on the GPU.\nMatrix dimension is m by n\n\n@param[in]\nldc    [int]\nldc specifies the first dimension of C_i. ldc >= max( 1, m )\n\n@param[in]\nbatchCount [int]\nnumber of instances in the batch.\n"]
    pub fn hipblasChemmBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        AP: *const *const hipblasComplex,
        lda: ::core::ffi::c_int,
        BP: *const *const hipblasComplex,
        ldb: ::core::ffi::c_int,
        beta: *const hipblasComplex,
        CP: *const *mut hipblasComplex,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhemmBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        BP: *const *const hipblasDoubleComplex,
        ldb: ::core::ffi::c_int,
        beta: *const hipblasDoubleComplex,
        CP: *const *mut hipblasDoubleComplex,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChemmBatched_v2(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipComplex,
        AP: *const *const hipComplex,
        lda: ::core::ffi::c_int,
        BP: *const *const hipComplex,
        ldb: ::core::ffi::c_int,
        beta: *const hipComplex,
        CP: *const *mut hipComplex,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhemmBatched_v2(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        BP: *const *const hipDoubleComplex,
        ldb: ::core::ffi::c_int,
        beta: *const hipDoubleComplex,
        CP: *const *mut hipDoubleComplex,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 3 API\n\n\\details\n\nhemmStridedBatched performs a batch of the matrix-matrix operations:\n\nC_i := alpha*A_i*B_i + beta*C_i if side == HIPBLAS_SIDE_LEFT,\nC_i := alpha*B_i*A_i + beta*C_i if side == HIPBLAS_SIDE_RIGHT,\n\nwhere alpha and beta are scalars, B_i and C_i are m by n matrices, and\nA_i is a Hermitian matrix stored as either upper or lower.\n\n- Supported precisions in rocBLAS : c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n\n@param[in]\nside  [hipblasSideMode_t]\nHIPBLAS_SIDE_LEFT:      C_i := alpha*A_i*B_i + beta*C_i\nHIPBLAS_SIDE_RIGHT:     C_i := alpha*B_i*A_i + beta*C_i\n\n@param[in]\nuplo    [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER:  A_i is an upper triangular matrix\nHIPBLAS_FILL_MODE_LOWER:  A_i is a  lower triangular matrix\n\n@param[in]\nn       [int]\nn specifies the number of rows of B_i and C_i. n >= 0.\n\n@param[in]\nk       [int]\nk specifies the number of columns of B_i and C_i. k >= 0.\n\n@param[in]\nalpha\nalpha specifies the scalar alpha. When alpha is\nzero then A_i and B_i are not referenced.\n\n@param[in]\nAP       device pointer to first matrix A_1\nA_i is m by m if side == HIPBLAS_SIDE_LEFT\nA_i is n by n if side == HIPBLAS_SIDE_RIGHT\nOnly the upper/lower triangular part is accessed.\nThe imaginary component of the diagonal elements is not used.\n\n@param[in]\nlda     [int]\nlda specifies the first dimension of A_i.\nif side = HIPBLAS_SIDE_LEFT,  lda >= max( 1, m ),\notherwise lda >= max( 1, n ).\n\n@param[in]\nstrideA  [hipblasStride]\nstride from the start of one matrix (A_i) and the next one (A_i+1)\n\n@param[in]\nBP       device pointer to first matrix B_1 of dimension (ldb, n) on the GPU\n\n@param[in]\nldb     [int]\nldb specifies the first dimension of B_i.\nif side = HIPBLAS_OP_N,  ldb >= max( 1, m ),\notherwise ldb >= max( 1, n ).\n\n@param[in]\nstrideB  [hipblasStride]\nstride from the start of one matrix (B_i) and the next one (B_i+1)\n\n@param[in]\nbeta\nbeta specifies the scalar beta. When beta is\nzero then C need not be set before entry.\n\n@param[in]\nCP        device pointer to first matrix C_1 of dimension (ldc, n) on the GPU.\n\n@param[in]\nldc    [int]\nldc specifies the first dimension of C. ldc >= max( 1, m )\n\n@param[inout]\nstrideC  [hipblasStride]\nstride from the start of one matrix (C_i) and the next one (C_i+1)\n\n@param[in]\nbatchCount [int]\nnumber of instances in the batch\n"]
    pub fn hipblasChemmStridedBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        BP: *const hipblasComplex,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        beta: *const hipblasComplex,
        CP: *mut hipblasComplex,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhemmStridedBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        BP: *const hipblasDoubleComplex,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        beta: *const hipblasDoubleComplex,
        CP: *mut hipblasDoubleComplex,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasChemmStridedBatched_v2(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        BP: *const hipComplex,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        beta: *const hipComplex,
        CP: *mut hipComplex,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZhemmStridedBatched_v2(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        BP: *const hipDoubleComplex,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        beta: *const hipDoubleComplex,
        CP: *mut hipDoubleComplex,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 3 API\n\n\\details\n\ntrmm performs one of the matrix-matrix operations\n\nC := alpha*op( A )*B,   or   C := alpha*B*op( A )\n\nwhere  alpha  is a scalar, B and C are an m by n matrices,  A  is a unit, or\nnon-unit,  upper or lower triangular matrix  and  op( A )  is one  of\n\nop( A ) = A   or   op( A ) = A^T   or   op( A ) = A^H.\n\nNote that trmm can provide in-place functionality by passing in the same address for both\nmatrices B and C and by setting ldb equal to ldc.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : s,d,c,z\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n\n@param[in]\nside    [hipblasSideMode_t]\nSpecifies whether op(A) multiplies B from the left or right as follows:\nHIPBLAS_SIDE_LEFT:       C := alpha*op( A )*B.\nHIPBLAS_SIDE_RIGHT:      C := alpha*B*op( A ).\n\n@param[in]\nuplo    [hipblasFillMode_t]\nSpecifies whether the matrix A is an upper or lower triangular matrix as follows:\nHIPBLAS_FILL_MODE_UPPER:  A is an upper triangular matrix.\nHIPBLAS_FILL_MODE_LOWER:  A is a  lower triangular matrix.\n\n@param[in]\ntransA  [hipblasOperation_t]\nSpecifies the form of op(A) to be used in the matrix multiplication as follows:\nHIPBLAS_OP_N: op(A) = A.\nHIPBLAS_OP_T: op(A) = A^T.\nHIPBLAS_OP_C: op(A) = A^H.\n\n@param[in]\ndiag    [hipblasDiagType_t]\nSpecifies whether or not A is unit triangular as follows:\nHIPBLAS_DIAG_UNIT:      A is assumed to be unit triangular.\nHIPBLAS_DIAG_NON_UNIT:  A is not assumed to be unit triangular.\n\n@param[in]\nm       [int]\nm specifies the number of rows of B and C. m >= 0.\n\n@param[in]\nn       [int]\nn specifies the number of columns of B and C. n >= 0.\n\n@param[in]\nalpha\nalpha specifies the scalar alpha. When alpha is\nzero then A is not referenced and B need not be set before\nentry.\n\n@param[in]\nA       Device pointer to matrix A on the GPU.\nA has dimension ( lda, k ), where k is m\nwhen  side == HIPBLAS_SIDE_LEFT  and\nis  n  when  side == HIPBLAS_SIDE_RIGHT.\n\nWhen uplo == HIPBLAS_FILL_MODE_UPPER the  leading  k by k\nupper triangular part of the array  A must contain the upper\ntriangular matrix  and the strictly lower triangular part of\nA is not referenced.\n\nWhen uplo == HIPBLAS_FILL_MODE_LOWER the  leading  k by k\nlower triangular part of the array  A must contain the lower\ntriangular matrix  and the strictly upper triangular part of\nA is not referenced.\n\nNote that when  diag == HIPBLAS_DIAG_UNIT  the diagonal elements of\nA  are not referenced either,  but are assumed to be  unity.\n\n@param[in]\nlda     [int]\nlda specifies the first dimension of A.\nif side == HIPBLAS_SIDE_LEFT,  lda >= max( 1, m ),\nif side == HIPBLAS_SIDE_RIGHT, lda >= max( 1, n ).\n\n@param[inout]\nB       Device pointer to the matrix B of dimension (ldb, n) on the GPU.\n\n@param[in]\nldb    [int]\nldb specifies the first dimension of B. ldb >= max( 1, m ).\n\n@param[in]\nC      Device pointer to the matrix C of dimension (ldc, n) on the GPU.\nUsers can pass in the same matrix B to parameter C to achieve\nin-place functionality of trmm.\n@param[in]\nldc    [int]\nldc specifies the first dimension of C. ldc >= max( 1, m ).\n"]
    pub fn hipblasStrmm(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        A: *const f32,
        lda: ::core::ffi::c_int,
        B: *const f32,
        ldb: ::core::ffi::c_int,
        C: *mut f32,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtrmm(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        A: *const f64,
        lda: ::core::ffi::c_int,
        B: *const f64,
        ldb: ::core::ffi::c_int,
        C: *mut f64,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrmm(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        A: *const hipblasComplex,
        lda: ::core::ffi::c_int,
        B: *const hipblasComplex,
        ldb: ::core::ffi::c_int,
        C: *mut hipblasComplex,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrmm(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        A: *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        B: *const hipblasDoubleComplex,
        ldb: ::core::ffi::c_int,
        C: *mut hipblasDoubleComplex,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrmm_v2(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipComplex,
        A: *const hipComplex,
        lda: ::core::ffi::c_int,
        B: *const hipComplex,
        ldb: ::core::ffi::c_int,
        C: *mut hipComplex,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrmm_v2(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        A: *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        B: *const hipDoubleComplex,
        ldb: ::core::ffi::c_int,
        C: *mut hipDoubleComplex,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 3 API\n\n\\details\n\ntrmmBatched performs one of the batched matrix-matrix operations\n\nC_i := alpha*op( A_i )*B_i,   or   C_i := alpha*B_i*op( A_i )  for i = 0, 1, ... batchCount -1\n\nwhere alpha is a scalar, B_i and C_i are m by n matrices, A_i is a unit, or\nnon-unit, upper or lower triangular matrix and op( A_i ) is one of\n\nop( A_i ) = A_i   or   op( A_i ) = A_i^T   or   op( A_i ) = A_i^H.\n\nNote that trmmBatched can provide in-place functionality by passing in the same address for both\nmatrices B and C and by setting ldb equal to ldc.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n\n@param[in]\nside    [hipblasSideMode_t]\nSpecifies whether op(A_i) multiplies B_i from the left or right as follows:\nHIPBLAS_SIDE_LEFT:       B_i := alpha*op( A_i )*B_i.\nHIPBLAS_SIDE_RIGHT:      B_i := alpha*B_i*op( A_i ).\n\n@param[in]\nuplo    [hipblasFillMode_t]\nSpecifies whether the matrix A is an upper or lower triangular matrix as follows:\nHIPBLAS_FILL_MODE_UPPER:  A is an upper triangular matrix.\nHIPBLAS_FILL_MODE_LOWER:  A is a  lower triangular matrix.\n\n@param[in]\ntransA  [hipblasOperation_t]\nSpecifies the form of op(A_i) to be used in the matrix multiplication as follows:\nHIPBLAS_OP_N:  op(A_i) = A_i.\nHIPBLAS_OP_T:  op(A_i) = A_i^T.\nHIPBLAS_OP_C:  op(A_i) = A_i^H.\n\n@param[in]\ndiag    [hipblasDiagType_t]\nSpecifies whether or not A_i is unit triangular as follows:\nHIPBLAS_DIAG_UNIT:      A_i is assumed to be unit triangular.\nHIPBLAS_DIAG_NON_UNIT:  A_i is not assumed to be unit triangular.\n\n@param[in]\nm       [int]\nm specifies the number of rows of B_i and C_i. m >= 0.\n\n@param[in]\nn       [int]\nn specifies the number of columns of B_i and C_i. n >= 0.\n\n@param[in]\nalpha\nalpha specifies the scalar alpha. When alpha is\nzero then A_i is not referenced and B_i need not be set before\nentry.\n\n@param[in]\nA       Device array of device pointers storing each matrix A_i on the GPU.\nEach A_i is of dimension ( lda, k ), where k is m\nwhen  side == HIPBLAS_SIDE_LEFT  and\nis  n  when  side == HIPBLAS_SIDE_RIGHT.\n\nWhen uplo == HIPBLAS_FILL_MODE_UPPER the  leading  k by k\nupper triangular part of the array  A must contain the upper\ntriangular matrix  and the strictly lower triangular part of\nA is not referenced.\n\nWhen uplo == HIPBLAS_FILL_MODE_LOWER the  leading  k by k\nlower triangular part of the array  A must contain the lower\ntriangular matrix  and the strictly upper triangular part of\nA is not referenced.\n\nNote that when  diag == HIPBLAS_DIAG_UNIT  the diagonal elements of\nA_i  are not referenced either,  but are assumed to be  unity.\n\n@param[in]\nlda     [int]\nlda specifies the first dimension of A.\nif side == HIPBLAS_SIDE_LEFT,  lda >= max( 1, m ),\nif side == HIPBLAS_SIDE_RIGHT, lda >= max( 1, n ).\n\n@param[inout]\nB       device array of device pointers storing each matrix B_i of\ndimension (ldb, n) on the GPU.\n\n@param[in]\nldb    [int]\nldb specifies the first dimension of B_i. ldb >= max( 1, m ).\n\n@param[in]\nC      device array of device pointers storing each matrix C_i of\ndimension (ldc, n) on the GPU. Users can pass in the same\nmatrices B to parameter C to achieve in-place functionality of trmmBatched.\n\n@param[in]\nldc    lec specifies the first dimension of C_i. ldc >= max( 1, m ).\n\n@param[in]\nbatchCount [int]\nnumber of instances i in the batch."]
    pub fn hipblasStrmmBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        A: *const *const f32,
        lda: ::core::ffi::c_int,
        B: *const *const f32,
        ldb: ::core::ffi::c_int,
        C: *const *mut f32,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtrmmBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        A: *const *const f64,
        lda: ::core::ffi::c_int,
        B: *const *const f64,
        ldb: ::core::ffi::c_int,
        C: *const *mut f64,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrmmBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        A: *const *const hipblasComplex,
        lda: ::core::ffi::c_int,
        B: *const *const hipblasComplex,
        ldb: ::core::ffi::c_int,
        C: *const *mut hipblasComplex,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrmmBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        A: *const *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        B: *const *const hipblasDoubleComplex,
        ldb: ::core::ffi::c_int,
        C: *const *mut hipblasDoubleComplex,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrmmBatched_v2(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipComplex,
        A: *const *const hipComplex,
        lda: ::core::ffi::c_int,
        B: *const *const hipComplex,
        ldb: ::core::ffi::c_int,
        C: *const *mut hipComplex,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrmmBatched_v2(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        A: *const *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        B: *const *const hipDoubleComplex,
        ldb: ::core::ffi::c_int,
        C: *const *mut hipDoubleComplex,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 3 API\n\n\\details\n\ntrmmStridedBatched performs one of the strided_batched matrix-matrix operations\n\nC_i := alpha*op( A_i )*B_i,   or   C_i := alpha*B_i*op( A_i )  for i = 0, 1, ... batchCount -1\n\nwhere alpha is a scalar,  B_i and C_i are m by n matrices, A_i is a unit, or\nnon-unit, upper or lower triangular matrix and op( A_i ) is one of\n\nop( A_i ) = A_i   or   op( A_i ) = A_i^T   or   op( A_i ) = A_i^H.\n\nNote that trmmStridedBatched can provide in-place functionality by passing\nin the same address for both matrices B and C and by setting ldb equal to ldc.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n\n@param[in]\nside    [hipblasSideMode_t]\nSpecifies whether op(A_i) multiplies B_i from the left or right as follows:\nHIPBLAS_SIDE_LEFT:       C_i := alpha*op( A_i )*B_i.\nHIPBLAS_SIDE_RIGHT:      C_i := alpha*B_i*op( A_i ).\n\n@param[in]\nuplo    [hipblasFillMode_t]\nSpecifies whether the matrix A is an upper or lower triangular matrix as follows:\nHIPBLAS_FILL_MODE_UPPER:  A is an upper triangular matrix.\nHIPBLAS_FILL_MODE_LOWER:  A is a  lower triangular matrix.\n\n@param[in]\ntransA  [hipblasOperation_t]\nSpecifies the form of op(A_i) to be used in the matrix multiplication as follows:\nHIPBLAS_OP_N:  op(A_i) = A_i.\nHIPBLAS_OP_T:  op(A_i) = A_i^T.\nHIPBLAS_OP_C:  op(A_i) = A_i^H.\n\n@param[in]\ndiag    [hipblasDiagType_t]\nSpecifies whether or not A_i is unit triangular as follows:\nHIPBLAS_DIAG_UNIT:      A_i is assumed to be unit triangular.\nHIPBLAS_DIAG_NON_UNIT:  A_i is not assumed to be unit triangular.\n\n@param[in]\nm       [int]\nm specifies the number of rows of B_i and C_i. m >= 0.\n\n@param[in]\nn       [int]\nn specifies the number of columns of B_i and C_i. n >= 0.\n\n@param[in]\nalpha\nalpha specifies the scalar alpha. When alpha is\nzero then A_i is not referenced and B_i need not be set before\nentry.\n\n@param[in]\nA       Device pointer to the first matrix A_0 on the GPU.\nEach A_i is of dimension ( lda, k ), where k is m\nwhen  side == HIPBLAS_SIDE_LEFT  and\nis  n  when  side == HIPBLAS_SIDE_RIGHT.\n\nWhen uplo == HIPBLAS_FILL_MODE_UPPER the  leading  k by k\nupper triangular part of the array  A must contain the upper\ntriangular matrix  and the strictly lower triangular part of\nA is not referenced.\n\nWhen uplo == HIPBLAS_FILL_MODE_LOWER the  leading  k by k\nlower triangular part of the array  A must contain the lower\ntriangular matrix  and the strictly upper triangular part of\nA is not referenced.\n\nNote that when  diag == HIPBLAS_DIAG_UNIT  the diagonal elements of\nA_i  are not referenced either,  but are assumed to be  unity.\n\n@param[in]\nlda     [int]\nlda specifies the first dimension of A.\nif side == HIPBLAS_SIDE_LEFT,  lda >= max( 1, m ),\nif side == HIPBLAS_SIDE_RIGHT, lda >= max( 1, n ).\n\n@param[in]\nstrideA  [hipblasStride]\nstride from the start of one matrix (A_i) and the next one (A_i+1)\n\n@param[inout]\nB      Device pointer to the first matrix B_0 on the GPU. Each B_i is of\ndimension ( ldb, n )\n\n@param[in]\nldb    [int]\nldb specifies the first dimension of B_i. ldb >= max( 1, m ).\n\n@param[in]\nstrideB  [hipblasStride]\nstride from the start of one matrix (B_i) and the next one (B_i+1)\n\n@param[in]\nC      Device pointer to the first matrix C_0 on the GPU. Each C_i is of\ndimension ( ldc, n ).\n\n@param[in]\nldc    [int]\nldc specifies the first dimension of C_i. ldc >= max( 1, m ).\n\n@param[in]\nstrideC [hipblasStride]\nstride from the start of one matrix (C_i) and the next one (C_i+1)\n\n@param[in]\nbatchCount [int]\nnumber of instances i in the batch."]
    pub fn hipblasStrmmStridedBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        A: *const f32,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        B: *const f32,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        C: *mut f32,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtrmmStridedBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        A: *const f64,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        B: *const f64,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        C: *mut f64,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrmmStridedBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        A: *const hipblasComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        B: *const hipblasComplex,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        C: *mut hipblasComplex,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrmmStridedBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        A: *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        B: *const hipblasDoubleComplex,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        C: *mut hipblasDoubleComplex,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrmmStridedBatched_v2(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipComplex,
        A: *const hipComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        B: *const hipComplex,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        C: *mut hipComplex,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrmmStridedBatched_v2(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        A: *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        B: *const hipDoubleComplex,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        C: *mut hipDoubleComplex,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 3 API\n\n\\details\n\ntrsm solves\n\nop(A)*X = alpha*B or  X*op(A) = alpha*B,\n\nwhere alpha is a scalar, X and B are m by n matrices,\nA is triangular matrix and op(A) is one of\n\nop( A ) = A   or   op( A ) = A^T   or   op( A ) = A^H.\n\nThe matrix X is overwritten on B.\n\nNote about memory allocation:\nWhen trsm is launched with a k evenly divisible by the internal block size of 128,\nand is no larger than 10 of these blocks, the API takes advantage of utilizing pre-allocated\nmemory found in the handle to increase overall performance. This memory can be managed by using\nthe environment variable WORKBUF_TRSM_B_CHNK. When this variable is not set the device memory\nused for temporary storage will default to 1 MB and may result in chunking, which in turn may\nreduce performance. Under these circumstances it is recommended that WORKBUF_TRSM_B_CHNK be set\nto the desired chunk of right hand sides to be used at a time.\n\n(where k is m when HIPBLAS_SIDE_LEFT and is n when HIPBLAS_SIDE_RIGHT)\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : s,d,c,z\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n\n@param[in]\nside    [hipblasSideMode_t]\nHIPBLAS_SIDE_LEFT:       op(A)*X = alpha*B.\nHIPBLAS_SIDE_RIGHT:      X*op(A) = alpha*B.\n\n@param[in]\nuplo    [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER:  A is an upper triangular matrix.\nHIPBLAS_FILL_MODE_LOWER:  A is a  lower triangular matrix.\n\n@param[in]\ntransA  [hipblasOperation_t]\nHIPBLAS_OP_N: op(A) = A.\nHIPBLAS_OP_T: op(A) = A^T.\nHIPBLAS_OP_C: op(A) = A^H.\n\n@param[in]\ndiag    [hipblasDiagType_t]\nHIPBLAS_DIAG_UNIT:     A is assumed to be unit triangular.\nHIPBLAS_DIAG_NON_UNIT:  A is not assumed to be unit triangular.\n\n@param[in]\nm       [int]\nm specifies the number of rows of B. m >= 0.\n\n@param[in]\nn       [int]\nn specifies the number of columns of B. n >= 0.\n\n@param[in]\nalpha\ndevice pointer or host pointer specifying the scalar alpha. When alpha is\n&zero then A is not referenced and B need not be set before\nentry.\n\n@param[in]\nAP       device pointer storing matrix A.\nof dimension ( lda, k ), where k is m\nwhen  HIPBLAS_SIDE_LEFT  and\nis  n  when  HIPBLAS_SIDE_RIGHT\nonly the upper/lower triangular part is accessed.\n\n@param[in]\nlda     [int]\nlda specifies the first dimension of A.\nif side = HIPBLAS_SIDE_LEFT,  lda >= max( 1, m ),\nif side = HIPBLAS_SIDE_RIGHT, lda >= max( 1, n ).\n\n@param[in,out]\nBP       device pointer storing matrix B.\n\n@param[in]\nldb    [int]\nldb specifies the first dimension of B. ldb >= max( 1, m ).\n"]
    pub fn hipblasStrsm(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        AP: *const f32,
        lda: ::core::ffi::c_int,
        BP: *mut f32,
        ldb: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtrsm(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        AP: *const f64,
        lda: ::core::ffi::c_int,
        BP: *mut f64,
        ldb: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrsm(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: ::core::ffi::c_int,
        BP: *mut hipblasComplex,
        ldb: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrsm(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        BP: *mut hipblasDoubleComplex,
        ldb: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrsm_v2(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: ::core::ffi::c_int,
        BP: *mut hipComplex,
        ldb: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrsm_v2(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        BP: *mut hipDoubleComplex,
        ldb: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 3 API\n\\details\ntrsmBatched performs the following batched operation:\n\nop(A_i)*X_i = alpha*B_i or  X_i*op(A_i) = alpha*B_i, for i = 1, ..., batchCount.\n\nwhere alpha is a scalar, X and B are batched m by n matrices,\nA is triangular batched matrix and op(A) is one of\n\nop( A ) = A   or   op( A ) = A^T   or   op( A ) = A^H.\n\nEach matrix X_i is overwritten on B_i for i = 1, ..., batchCount.\n\nNote about memory allocation:\nWhen trsm is launched with a k evenly divisible by the internal block size of 128,\nand is no larger than 10 of these blocks, the API takes advantage of utilizing pre-allocated\nmemory found in the handle to increase overall performance. This memory can be managed by using\nthe environment variable WORKBUF_TRSM_B_CHNK. When this variable is not set the device memory\nused for temporary storage will default to 1 MB and may result in chunking, which in turn may\nreduce performance. Under these circumstances it is recommended that WORKBUF_TRSM_B_CHNK be set\nto the desired chunk of right hand sides to be used at a time.\n(where k is m when HIPBLAS_SIDE_LEFT and is n when HIPBLAS_SIDE_RIGHT)\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : s,d,c,z\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nside    [hipblasSideMode_t]\nHIPBLAS_SIDE_LEFT:       op(A)*X = alpha*B.\nHIPBLAS_SIDE_RIGHT:      X*op(A) = alpha*B.\n@param[in]\nuplo    [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER:  each A_i is an upper triangular matrix.\nHIPBLAS_FILL_MODE_LOWER:  each A_i is a  lower triangular matrix.\n@param[in]\ntransA  [hipblasOperation_t]\nHIPBLAS_OP_N: op(A) = A.\nHIPBLAS_OP_T: op(A) = A^T.\nHIPBLAS_OP_C: op(A) = A^H.\n@param[in]\ndiag    [hipblasDiagType_t]\nHIPBLAS_DIAG_UNIT:     each A_i is assumed to be unit triangular.\nHIPBLAS_DIAG_NON_UNIT:  each A_i is not assumed to be unit triangular.\n@param[in]\nm       [int]\nm specifies the number of rows of each B_i. m >= 0.\n@param[in]\nn       [int]\nn specifies the number of columns of each B_i. n >= 0.\n@param[in]\nalpha\ndevice pointer or host pointer specifying the scalar alpha. When alpha is\n&zero then A is not referenced and B need not be set before\nentry.\n@param[in]\nAP       device array of device pointers storing each matrix A_i on the GPU.\nMatricies are of dimension ( lda, k ), where k is m\nwhen  HIPBLAS_SIDE_LEFT  and is  n  when  HIPBLAS_SIDE_RIGHT\nonly the upper/lower triangular part is accessed.\n@param[in]\nlda     [int]\nlda specifies the first dimension of each A_i.\nif side = HIPBLAS_SIDE_LEFT,  lda >= max( 1, m ),\nif side = HIPBLAS_SIDE_RIGHT, lda >= max( 1, n ).\n@param[in,out]\nBP       device array of device pointers storing each matrix B_i on the GPU.\n@param[in]\nldb    [int]\nldb specifies the first dimension of each B_i. ldb >= max( 1, m ).\n@param[in]\nbatchCount [int]\nnumber of trsm operatons in the batch."]
    pub fn hipblasStrsmBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        AP: *const *const f32,
        lda: ::core::ffi::c_int,
        BP: *const *mut f32,
        ldb: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtrsmBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        AP: *const *const f64,
        lda: ::core::ffi::c_int,
        BP: *const *mut f64,
        ldb: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrsmBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        AP: *const *const hipblasComplex,
        lda: ::core::ffi::c_int,
        BP: *const *mut hipblasComplex,
        ldb: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrsmBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        BP: *const *mut hipblasDoubleComplex,
        ldb: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrsmBatched_v2(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipComplex,
        AP: *const *const hipComplex,
        lda: ::core::ffi::c_int,
        BP: *const *mut hipComplex,
        ldb: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrsmBatched_v2(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        BP: *const *mut hipDoubleComplex,
        ldb: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 3 API\n\\details\ntrsmSridedBatched performs the following strided batched operation:\n\nop(A_i)*X_i = alpha*B_i or  X_i*op(A_i) = alpha*B_i, for i = 1, ..., batchCount.\n\nwhere alpha is a scalar, X and B are strided batched m by n matrices,\nA is triangular strided batched matrix and op(A) is one of\n\nop( A ) = A   or   op( A ) = A^T   or   op( A ) = A^H.\n\nEach matrix X_i is overwritten on B_i for i = 1, ..., batchCount.\n\nNote about memory allocation:\nWhen trsm is launched with a k evenly divisible by the internal block size of 128,\nand is no larger than 10 of these blocks, the API takes advantage of utilizing pre-allocated\nmemory found in the handle to increase overall performance. This memory can be managed by using\nthe environment variable WORKBUF_TRSM_B_CHNK. When this variable is not set the device memory\nused for temporary storage will default to 1 MB and may result in chunking, which in turn may\nreduce performance. Under these circumstances it is recommended that WORKBUF_TRSM_B_CHNK be set\nto the desired chunk of right hand sides to be used at a time.\n(where k is m when HIPBLAS_SIDE_LEFT and is n when HIPBLAS_SIDE_RIGHT)\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nside    [hipblasSideMode_t]\nHIPBLAS_SIDE_LEFT:       op(A)*X = alpha*B.\nHIPBLAS_SIDE_RIGHT:      X*op(A) = alpha*B.\n@param[in]\nuplo    [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER:  each A_i is an upper triangular matrix.\nHIPBLAS_FILL_MODE_LOWER:  each A_i is a  lower triangular matrix.\n@param[in]\ntransA  [hipblasOperation_t]\nHIPBLAS_OP_N: op(A) = A.\nHIPBLAS_OP_T: op(A) = A^T.\nHIPBLAS_OP_C: op(A) = A^H.\n@param[in]\ndiag    [hipblasDiagType_t]\nHIPBLAS_DIAG_UNIT:     each A_i is assumed to be unit triangular.\nHIPBLAS_DIAG_NON_UNIT:  each A_i is not assumed to be unit triangular.\n@param[in]\nm       [int]\nm specifies the number of rows of each B_i. m >= 0.\n@param[in]\nn       [int]\nn specifies the number of columns of each B_i. n >= 0.\n@param[in]\nalpha\ndevice pointer or host pointer specifying the scalar alpha. When alpha is\n&zero then A is not referenced and B need not be set before\nentry.\n@param[in]\nAP       device pointer pointing to the first matrix A_1.\nof dimension ( lda, k ), where k is m\nwhen  HIPBLAS_SIDE_LEFT  and\nis  n  when  HIPBLAS_SIDE_RIGHT\nonly the upper/lower triangular part is accessed.\n@param[in]\nlda     [int]\nlda specifies the first dimension of each A_i.\nif side = HIPBLAS_SIDE_LEFT,  lda >= max( 1, m ),\nif side = HIPBLAS_SIDE_RIGHT, lda >= max( 1, n ).\n@param[in]\nstrideA [hipblasStride]\nstride from the start of one A_i matrix to the next A_(i + 1).\n@param[in,out]\nBP       device pointer pointing to the first matrix B_1.\n@param[in]\nldb    [int]\nldb specifies the first dimension of each B_i. ldb >= max( 1, m ).\n@param[in]\nstrideB [hipblasStride]\nstride from the start of one B_i matrix to the next B_(i + 1).\n@param[in]\nbatchCount [int]\nnumber of trsm operatons in the batch."]
    pub fn hipblasStrsmStridedBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const f32,
        AP: *const f32,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        BP: *mut f32,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtrsmStridedBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const f64,
        AP: *const f64,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        BP: *mut f64,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrsmStridedBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipblasComplex,
        AP: *const hipblasComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        BP: *mut hipblasComplex,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrsmStridedBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipblasDoubleComplex,
        AP: *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        BP: *mut hipblasDoubleComplex,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrsmStridedBatched_v2(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipComplex,
        AP: *const hipComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        BP: *mut hipComplex,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrsmStridedBatched_v2(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const hipDoubleComplex,
        AP: *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        BP: *mut hipDoubleComplex,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 3 API\n\n\\details\ntrtri  compute the inverse of a matrix A, namely, invA\n\nand write the result into invA;\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nuplo      [hipblasFillMode_t]\nspecifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'\nif HIPBLAS_FILL_MODE_UPPER, the lower part of A is not referenced\nif HIPBLAS_FILL_MODE_LOWER, the upper part of A is not referenced\n@param[in]\ndiag      [hipblasDiagType_t]\n= 'HIPBLAS_DIAG_NON_UNIT', A is non-unit triangular;\n= 'HIPBLAS_DIAG_UNIT', A is unit triangular;\n@param[in]\nn         [int]\nsize of matrix A and invA\n@param[in]\nAP         device pointer storing matrix A.\n@param[in]\nlda       [int]\nspecifies the leading dimension of A.\n@param[out]\ninvA      device pointer storing matrix invA.\n@param[in]\nldinvA    [int]\nspecifies the leading dimension of invA."]
    pub fn hipblasStrtri(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        AP: *const f32,
        lda: ::core::ffi::c_int,
        invA: *mut f32,
        ldinvA: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtrtri(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        AP: *const f64,
        lda: ::core::ffi::c_int,
        invA: *mut f64,
        ldinvA: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrtri(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        AP: *const hipblasComplex,
        lda: ::core::ffi::c_int,
        invA: *mut hipblasComplex,
        ldinvA: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrtri(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        AP: *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        invA: *mut hipblasDoubleComplex,
        ldinvA: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrtri_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        AP: *const hipComplex,
        lda: ::core::ffi::c_int,
        invA: *mut hipComplex,
        ldinvA: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrtri_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        AP: *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        invA: *mut hipDoubleComplex,
        ldinvA: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 3 API\n\n\\details\ntrtriBatched  compute the inverse of A_i and write into invA_i where\nA_i and invA_i are the i-th matrices in the batch,\nfor i = 1, ..., batchCount.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nuplo      [hipblasFillMode_t]\nspecifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'\n@param[in]\ndiag      [hipblasDiagType_t]\n= 'HIPBLAS_DIAG_NON_UNIT', A is non-unit triangular;\n= 'HIPBLAS_DIAG_UNIT', A is unit triangular;\n@param[in]\nn         [int]\n@param[in]\nAP         device array of device pointers storing each matrix A_i.\n@param[in]\nlda       [int]\nspecifies the leading dimension of each A_i.\n@param[out]\ninvA      device array of device pointers storing the inverse of each matrix A_i.\nPartial inplace operation is supported, see below.\nIf UPLO = 'U', the leading N-by-N upper triangular part of the invA will store\nthe inverse of the upper triangular matrix, and the strictly lower\ntriangular part of invA is cleared.\nIf UPLO = 'L', the leading N-by-N lower triangular part of the invA will store\nthe inverse of the lower triangular matrix, and the strictly upper\ntriangular part of invA is cleared.\n@param[in]\nldinvA    [int]\nspecifies the leading dimension of each invA_i.\n@param[in]\nbatchCount [int]\nnumbers of matrices in the batch"]
    pub fn hipblasStrtriBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        AP: *const *const f32,
        lda: ::core::ffi::c_int,
        invA: *mut *mut f32,
        ldinvA: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtrtriBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        AP: *const *const f64,
        lda: ::core::ffi::c_int,
        invA: *mut *mut f64,
        ldinvA: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrtriBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        AP: *const *const hipblasComplex,
        lda: ::core::ffi::c_int,
        invA: *mut *mut hipblasComplex,
        ldinvA: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrtriBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        AP: *const *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        invA: *mut *mut hipblasDoubleComplex,
        ldinvA: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrtriBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        AP: *const *const hipComplex,
        lda: ::core::ffi::c_int,
        invA: *mut *mut hipComplex,
        ldinvA: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrtriBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        AP: *const *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        invA: *mut *mut hipDoubleComplex,
        ldinvA: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 3 API\n\n\\details\ntrtriStridedBatched compute the inverse of A_i and write into invA_i where\nA_i and invA_i are the i-th matrices in the batch,\nfor i = 1, ..., batchCount\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nuplo      [hipblasFillMode_t]\nspecifies whether the upper 'HIPBLAS_FILL_MODE_UPPER' or lower 'HIPBLAS_FILL_MODE_LOWER'\n@param[in]\ndiag      [hipblasDiagType_t]\n= 'HIPBLAS_DIAG_NON_UNIT', A is non-unit triangular;\n= 'HIPBLAS_DIAG_UNIT', A is unit triangular;\n@param[in]\nn         [int]\n@param[in]\nAP         device pointer pointing to address of first matrix A_1.\n@param[in]\nlda       [int]\nspecifies the leading dimension of each A.\n@param[in]\nstrideA  [hipblasStride]\n\"batch stride a\": stride from the start of one A_i matrix to the next A_(i + 1).\n@param[out]\ninvA      device pointer storing the inverses of each matrix A_i.\nPartial inplace operation is supported, see below.\nIf UPLO = 'U', the leading N-by-N upper triangular part of the invA will store\nthe inverse of the upper triangular matrix, and the strictly lower\ntriangular part of invA is cleared.\nIf UPLO = 'L', the leading N-by-N lower triangular part of the invA will store\nthe inverse of the lower triangular matrix, and the strictly upper\ntriangular part of invA is cleared.\n@param[in]\nldinvA    [int]\nspecifies the leading dimension of each invA_i.\n@param[in]\nstride_invA  [hipblasStride]\n\"batch stride invA\": stride from the start of one invA_i matrix to the next invA_(i + 1).\n@param[in]\nbatchCount  [int]\nnumbers of matrices in the batch"]
    pub fn hipblasStrtriStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        AP: *const f32,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        invA: *mut f32,
        ldinvA: ::core::ffi::c_int,
        stride_invA: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDtrtriStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        AP: *const f64,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        invA: *mut f64,
        ldinvA: ::core::ffi::c_int,
        stride_invA: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrtriStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        AP: *const hipblasComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        invA: *mut hipblasComplex,
        ldinvA: ::core::ffi::c_int,
        stride_invA: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrtriStridedBatched(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        AP: *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        invA: *mut hipblasDoubleComplex,
        ldinvA: ::core::ffi::c_int,
        stride_invA: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCtrtriStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        AP: *const hipComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        invA: *mut hipComplex,
        ldinvA: ::core::ffi::c_int,
        stride_invA: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZtrtriStridedBatched_v2(
        handle: hipblasHandle_t,
        uplo: hipblasFillMode_t,
        diag: hipblasDiagType_t,
        n: ::core::ffi::c_int,
        AP: *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        invA: *mut hipDoubleComplex,
        ldinvA: ::core::ffi::c_int,
        stride_invA: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 3 API\n\n\\details\ndgmm performs one of the matrix-matrix operations\n\nC = A * diag(x) if side == HIPBLAS_SIDE_RIGHT\nC = diag(x) * A if side == HIPBLAS_SIDE_LEFT\n\nwhere C and A are m by n dimensional matrices. diag( x ) is a diagonal matrix\nand x is vector of dimension n if side == HIPBLAS_SIDE_RIGHT and dimension m\nif side == HIPBLAS_SIDE_LEFT.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : s,d,c,z\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nside      [hipblasSideMode_t]\nspecifies the side of diag(x)\n@param[in]\nm         [int]\nmatrix dimension m.\n@param[in]\nn         [int]\nmatrix dimension n.\n@param[in]\nAP         device pointer storing matrix A.\n@param[in]\nlda       [int]\nspecifies the leading dimension of A.\n@param[in]\nx         device pointer storing vector x.\n@param[in]\nincx      [int]\nspecifies the increment between values of x\n@param[in, out]\nCP         device pointer storing matrix C.\n@param[in]\nldc       [int]\nspecifies the leading dimension of C.\n"]
    pub fn hipblasSdgmm(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        AP: *const f32,
        lda: ::core::ffi::c_int,
        x: *const f32,
        incx: ::core::ffi::c_int,
        CP: *mut f32,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDdgmm(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        AP: *const f64,
        lda: ::core::ffi::c_int,
        x: *const f64,
        incx: ::core::ffi::c_int,
        CP: *mut f64,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCdgmm(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        AP: *const hipblasComplex,
        lda: ::core::ffi::c_int,
        x: *const hipblasComplex,
        incx: ::core::ffi::c_int,
        CP: *mut hipblasComplex,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdgmm(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        AP: *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        x: *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        CP: *mut hipblasDoubleComplex,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCdgmm_v2(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        AP: *const hipComplex,
        lda: ::core::ffi::c_int,
        x: *const hipComplex,
        incx: ::core::ffi::c_int,
        CP: *mut hipComplex,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdgmm_v2(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        AP: *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        x: *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        CP: *mut hipDoubleComplex,
        ldc: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 3 API\n\n\\details\ndgmmBatched performs one of the batched matrix-matrix operations\n\nC_i = A_i * diag(x_i) for i = 0, 1, ... batchCount-1 if side == HIPBLAS_SIDE_RIGHT\nC_i = diag(x_i) * A_i for i = 0, 1, ... batchCount-1 if side == HIPBLAS_SIDE_LEFT\n\nwhere C_i and A_i are m by n dimensional matrices. diag(x_i) is a diagonal matrix\nand x_i is vector of dimension n if side == HIPBLAS_SIDE_RIGHT and dimension m\nif side == HIPBLAS_SIDE_LEFT.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nside      [hipblasSideMode_t]\nspecifies the side of diag(x)\n@param[in]\nm         [int]\nmatrix dimension m.\n@param[in]\nn         [int]\nmatrix dimension n.\n@param[in]\nAP         device array of device pointers storing each matrix A_i on the GPU.\nEach A_i is of dimension ( lda, n )\n@param[in]\nlda       [int]\nspecifies the leading dimension of A_i.\n@param[in]\nx         device array of device pointers storing each vector x_i on the GPU.\nEach x_i is of dimension n if side == HIPBLAS_SIDE_RIGHT and dimension\nm if side == HIPBLAS_SIDE_LEFT\n@param[in]\nincx      [int]\nspecifies the increment between values of x_i\n@param[in, out]\nCP         device array of device pointers storing each matrix C_i on the GPU.\nEach C_i is of dimension ( ldc, n ).\n@param[in]\nldc       [int]\nspecifies the leading dimension of C_i.\n@param[in]\nbatchCount [int]\nnumber of instances in the batch.\n"]
    pub fn hipblasSdgmmBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        AP: *const *const f32,
        lda: ::core::ffi::c_int,
        x: *const *const f32,
        incx: ::core::ffi::c_int,
        CP: *const *mut f32,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDdgmmBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        AP: *const *const f64,
        lda: ::core::ffi::c_int,
        x: *const *const f64,
        incx: ::core::ffi::c_int,
        CP: *const *mut f64,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCdgmmBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        AP: *const *const hipblasComplex,
        lda: ::core::ffi::c_int,
        x: *const *const hipblasComplex,
        incx: ::core::ffi::c_int,
        CP: *const *mut hipblasComplex,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdgmmBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        AP: *const *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        x: *const *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        CP: *const *mut hipblasDoubleComplex,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCdgmmBatched_v2(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        AP: *const *const hipComplex,
        lda: ::core::ffi::c_int,
        x: *const *const hipComplex,
        incx: ::core::ffi::c_int,
        CP: *const *mut hipComplex,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdgmmBatched_v2(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        AP: *const *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        x: *const *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        CP: *const *mut hipDoubleComplex,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS Level 3 API\n\n\\details\ndgmmStridedBatched performs one of the batched matrix-matrix operations\n\nC_i = A_i * diag(x_i)   if side == HIPBLAS_SIDE_RIGHT   for i = 0, 1, ... batchCount-1\nC_i = diag(x_i) * A_i   if side == HIPBLAS_SIDE_LEFT    for i = 0, 1, ... batchCount-1\n\nwhere C_i and A_i are m by n dimensional matrices. diag(x_i) is a diagonal matrix\nand x_i is vector of dimension n if side == HIPBLAS_SIDE_RIGHT and dimension m\nif side == HIPBLAS_SIDE_LEFT.\n\n- Supported precisions in rocBLAS : s,d,c,z\n- Supported precisions in cuBLAS  : No support\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nside      [hipblasSideMode_t]\nspecifies the side of diag(x)\n@param[in]\nm         [int]\nmatrix dimension m.\n@param[in]\nn         [int]\nmatrix dimension n.\n@param[in]\nAP         device pointer to the first matrix A_0 on the GPU.\nEach A_i is of dimension ( lda, n )\n@param[in]\nlda       [int]\nspecifies the leading dimension of A.\n@param[in]\nstrideA  [hipblasStride]\nstride from the start of one matrix (A_i) and the next one (A_i+1)\n@param[in]\nx         pointer to the first vector x_0 on the GPU.\nEach x_i is of dimension n if side == HIPBLAS_SIDE_RIGHT and dimension\nm if side == HIPBLAS_SIDE_LEFT\n@param[in]\nincx      [int]\nspecifies the increment between values of x\n@param[in]\nstridex  [hipblasStride]\nstride from the start of one vector(x_i) and the next one (x_i+1)\n@param[in, out]\nCP         device pointer to the first matrix C_0 on the GPU.\nEach C_i is of dimension ( ldc, n ).\n@param[in]\nldc       [int]\nspecifies the leading dimension of C.\n@param[in]\nstrideC  [hipblasStride]\nstride from the start of one matrix (C_i) and the next one (C_i+1)\n@param[in]\nbatchCount [int]\nnumber of instances i in the batch.\n"]
    pub fn hipblasSdgmmStridedBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        AP: *const f32,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *const f32,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        CP: *mut f32,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDdgmmStridedBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        AP: *const f64,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *const f64,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        CP: *mut f64,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCdgmmStridedBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        AP: *const hipblasComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *const hipblasComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        CP: *mut hipblasComplex,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdgmmStridedBatched(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        AP: *const hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *const hipblasDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        CP: *mut hipblasDoubleComplex,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCdgmmStridedBatched_v2(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        AP: *const hipComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *const hipComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        CP: *mut hipComplex,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZdgmmStridedBatched_v2(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        AP: *const hipDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        x: *const hipDoubleComplex,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        CP: *mut hipDoubleComplex,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief SOLVER API\n\n\\details\ngetrf computes the LU factorization of a general n-by-n matrix A\nusing partial pivoting with row interchanges. The LU factorization can\nbe done without pivoting if ipiv is passed as a nullptr.\n\nIn the case that ipiv is not null, the factorization has the form:\n\n\\f[\nA = PLU\n\\f]\n\nwhere P is a permutation matrix, L is lower triangular with unit\ndiagonal elements, and U is upper triangular.\n\nIn the case that ipiv is null, the factorization is done without pivoting:\n\n\\f[\nA = LU\n\\f]\n\n- Supported precisions in rocSOLVER : s,d,c,z\n- Supported precisions in cuBLAS    : s,d,c,z\n\n@param[in]\nhandle    hipblasHandle_t.\n@param[in]\nn         int. n >= 0.\\n\nThe number of columns and rows of the matrix A.\n@param[inout]\nA         pointer to type. Array on the GPU of dimension lda*n.\\n\nOn entry, the n-by-n matrix A to be factored.\nOn exit, the factors L and U from the factorization.\nThe unit diagonal elements of L are not stored.\n@param[in]\nlda       int. lda >= n.\\n\nSpecifies the leading dimension of A.\n@param[out]\nipiv      pointer to int. Array on the GPU of dimension n.\\n\nThe vector of pivot indices. Elements of ipiv are 1-based indices.\nFor 1 <= i <= n, the row i of the\nmatrix was interchanged with row ipiv[i].\nMatrix P of the factorization can be derived from ipiv.\nThe factorization here can be done without pivoting if ipiv is passed\nin as a nullptr.\n@param[out]\ninfo      pointer to a int on the GPU.\\n\nIf info = 0, successful exit.\nIf info = j > 0, U is singular. U[j,j] is the first zero pivot."]
    pub fn hipblasSgetrf(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        A: *mut f32,
        lda: ::core::ffi::c_int,
        ipiv: *mut ::core::ffi::c_int,
        info: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgetrf(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        A: *mut f64,
        lda: ::core::ffi::c_int,
        ipiv: *mut ::core::ffi::c_int,
        info: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgetrf(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        A: *mut hipblasComplex,
        lda: ::core::ffi::c_int,
        ipiv: *mut ::core::ffi::c_int,
        info: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgetrf(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        A: *mut hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        ipiv: *mut ::core::ffi::c_int,
        info: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgetrf_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        A: *mut hipComplex,
        lda: ::core::ffi::c_int,
        ipiv: *mut ::core::ffi::c_int,
        info: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgetrf_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        A: *mut hipDoubleComplex,
        lda: ::core::ffi::c_int,
        ipiv: *mut ::core::ffi::c_int,
        info: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief SOLVER API\n\n\\details\ngetrfBatched computes the LU factorization of a batch of general\nn-by-n matrices using partial pivoting with row interchanges. The LU factorization can\nbe done without pivoting if ipiv is passed as a nullptr.\n\nIn the case that ipiv is not null, the factorization of matrix \\f$A_i\\f$ in the batch has the form:\n\n\\f[\nA_i = P_iL_iU_i\n\\f]\n\nwhere \\f$P_i\\f$ is a permutation matrix, \\f$L_i\\f$ is lower triangular with unit\ndiagonal elements, and \\f$U_i\\f$ is upper triangular.\n\nIn the case that ipiv is null, the factorization is done without pivoting:\n\n\\f[\nA_i = L_iU_i\n\\f]\n\n- Supported precisions in rocSOLVER : s,d,c,z\n- Supported precisions in cuBLAS    : s,d,c,z\n\n@param[in]\nhandle    hipblasHandle_t.\n@param[in]\nn         int. n >= 0.\\n\nThe number of columns and rows of all matrices A_i in the batch.\n@param[inout]\nA         array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\\n\nOn entry, the n-by-n matrices A_i to be factored.\nOn exit, the factors L_i and U_i from the factorizations.\nThe unit diagonal elements of L_i are not stored.\n@param[in]\nlda       int. lda >= n.\\n\nSpecifies the leading dimension of matrices A_i.\n@param[out]\nipiv      pointer to int. Array on the GPU.\\n\nContains the vectors of pivot indices ipiv_i (corresponding to A_i).\nDimension of ipiv_i is n.\nElements of ipiv_i are 1-based indices.\nFor each instance A_i in the batch and for 1 <= j <= n, the row j of the\nmatrix A_i was interchanged with row ipiv_i[j].\nMatrix P_i of the factorization can be derived from ipiv_i.\nThe factorization here can be done without pivoting if ipiv is passed\nin as a nullptr.\n@param[out]\ninfo      pointer to int. Array of batchCount integers on the GPU.\\n\nIf info[i] = 0, successful exit for factorization of A_i.\nIf info[i] = j > 0, U_i is singular. U_i[j,j] is the first zero pivot.\n@param[in]\nbatchCount int. batchCount >= 0.\\n\nNumber of matrices in the batch."]
    pub fn hipblasSgetrfBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        A: *const *mut f32,
        lda: ::core::ffi::c_int,
        ipiv: *mut ::core::ffi::c_int,
        info: *mut ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgetrfBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        A: *const *mut f64,
        lda: ::core::ffi::c_int,
        ipiv: *mut ::core::ffi::c_int,
        info: *mut ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgetrfBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        A: *const *mut hipblasComplex,
        lda: ::core::ffi::c_int,
        ipiv: *mut ::core::ffi::c_int,
        info: *mut ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgetrfBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        A: *const *mut hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        ipiv: *mut ::core::ffi::c_int,
        info: *mut ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgetrfBatched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        A: *const *mut hipComplex,
        lda: ::core::ffi::c_int,
        ipiv: *mut ::core::ffi::c_int,
        info: *mut ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgetrfBatched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        A: *const *mut hipDoubleComplex,
        lda: ::core::ffi::c_int,
        ipiv: *mut ::core::ffi::c_int,
        info: *mut ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief SOLVER API\n\n\\details\ngetrfStridedBatched computes the LU factorization of a batch of\ngeneral n-by-n matrices using partial pivoting with row interchanges. The LU factorization can\nbe done without pivoting if ipiv is passed as a nullptr.\n\nIn the case that ipiv is not null, the factorization of matrix \\f$A_i\\f$ in the batch has the form:\n\n\\f[\nA_i = P_iL_iU_i\n\\f]\n\nwhere \\f$P_i\\f$ is a permutation matrix, \\f$L_i\\f$ is lower triangular with unit\ndiagonal elements, and \\f$U_i\\f$ is upper triangular.\n\nIn the case that ipiv is null, the factorization is done without pivoting:\n\n\\f[\nA_i = L_iU_i\n\\f]\n\n- Supported precisions in rocSOLVER : s,d,c,z\n- Supported precisions in cuBLAS    : s,d,c,z\n\n@param[in]\nhandle    hipblasHandle_t.\n@param[in]\nn         int. n >= 0.\\n\nThe number of columns and rows of all matrices A_i in the batch.\n@param[inout]\nA         pointer to type. Array on the GPU (the size depends on the value of strideA).\\n\nOn entry, the n-by-n matrices A_i to be factored.\nOn exit, the factors L_i and U_i from the factorization.\nThe unit diagonal elements of L_i are not stored.\n@param[in]\nlda       int. lda >= n.\\n\nSpecifies the leading dimension of matrices A_i.\n@param[in]\nstrideA   hipblasStride.\\n\nStride from the start of one matrix A_i to the next one A_(i+1).\nThere is no restriction for the value of strideA. Normal use case is strideA >= lda*n\n@param[out]\nipiv      pointer to int. Array on the GPU (the size depends on the value of strideP).\\n\nContains the vectors of pivots indices ipiv_i (corresponding to A_i).\nDimension of ipiv_i is n.\nElements of ipiv_i are 1-based indices.\nFor each instance A_i in the batch and for 1 <= j <= n, the row j of the\nmatrix A_i was interchanged with row ipiv_i[j].\nMatrix P_i of the factorization can be derived from ipiv_i.\nThe factorization here can be done without pivoting if ipiv is passed\nin as a nullptr.\n@param[in]\nstrideP   hipblasStride.\\n\nStride from the start of one vector ipiv_i to the next one ipiv_(i+1).\nThere is no restriction for the value of strideP. Normal use case is strideP >= n.\n@param[out]\ninfo      pointer to int. Array of batchCount integers on the GPU.\\n\nIf info[i] = 0, successful exit for factorization of A_i.\nIf info[i] = j > 0, U_i is singular. U_i[j,j] is the first zero pivot.\n@param[in]\nbatchCount int. batchCount >= 0.\\n\nNumber of matrices in the batch."]
    pub fn hipblasSgetrfStridedBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        A: *mut f32,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        ipiv: *mut ::core::ffi::c_int,
        strideP: hipblasStride,
        info: *mut ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgetrfStridedBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        A: *mut f64,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        ipiv: *mut ::core::ffi::c_int,
        strideP: hipblasStride,
        info: *mut ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgetrfStridedBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        A: *mut hipblasComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        ipiv: *mut ::core::ffi::c_int,
        strideP: hipblasStride,
        info: *mut ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgetrfStridedBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        A: *mut hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        ipiv: *mut ::core::ffi::c_int,
        strideP: hipblasStride,
        info: *mut ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgetrfStridedBatched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        A: *mut hipComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        ipiv: *mut ::core::ffi::c_int,
        strideP: hipblasStride,
        info: *mut ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgetrfStridedBatched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        A: *mut hipDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        ipiv: *mut ::core::ffi::c_int,
        strideP: hipblasStride,
        info: *mut ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief SOLVER API\n\n\\details\ngetrs solves a system of n linear equations on n variables in its factorized form.\n\nIt solves one of the following systems, depending on the value of trans:\n\n\\f[\n\\begin{array}{cl}\nA X = B & \\: \\text{not transposed,}\\\\\nA^T X = B & \\: \\text{transposed, or}\\\\\nA^H X = B & \\: \\text{conjugate transposed.}\n\\end{array}\n\\f]\n\nMatrix A is defined by its triangular factors as returned by \\ref hipblasSgetrf \"getrf\".\n\n- Supported precisions in rocSOLVER : s,d,c,z\n- Supported precisions in cuBLAS    : s,d,c,z\n\n\n@param[in]\nhandle      hipblasHandle_t.\n@param[in]\ntrans       hipblasOperation_t.\\n\nSpecifies the form of the system of equations.\n@param[in]\nn           int. n >= 0.\\n\nThe order of the system, i.e. the number of columns and rows of A.\n@param[in]\nnrhs        int. nrhs >= 0.\\n\nThe number of right hand sides, i.e., the number of columns\nof the matrix B.\n@param[in]\nA           pointer to type. Array on the GPU of dimension lda*n.\\n\nThe factors L and U of the factorization A = P*L*U returned by \\ref hipblasSgetrf \"getrf\".\n@param[in]\nlda         int. lda >= n.\\n\nThe leading dimension of A.\n@param[in]\nipiv        pointer to int. Array on the GPU of dimension n.\\n\nThe pivot indices returned by \\ref hipblasSgetrf \"getrf\".\n@param[in,out]\nB           pointer to type. Array on the GPU of dimension ldb*nrhs.\\n\nOn entry, the right hand side matrix B.\nOn exit, the solution matrix X.\n@param[in]\nldb         int. ldb >= n.\\n\nThe leading dimension of B.\n@param[out]\ninfo      pointer to a int on the host.\\n\nIf info = 0, successful exit.\nIf info = j < 0, the argument at position -j is invalid."]
    pub fn hipblasSgetrs(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        n: ::core::ffi::c_int,
        nrhs: ::core::ffi::c_int,
        A: *mut f32,
        lda: ::core::ffi::c_int,
        ipiv: *const ::core::ffi::c_int,
        B: *mut f32,
        ldb: ::core::ffi::c_int,
        info: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgetrs(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        n: ::core::ffi::c_int,
        nrhs: ::core::ffi::c_int,
        A: *mut f64,
        lda: ::core::ffi::c_int,
        ipiv: *const ::core::ffi::c_int,
        B: *mut f64,
        ldb: ::core::ffi::c_int,
        info: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgetrs(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        n: ::core::ffi::c_int,
        nrhs: ::core::ffi::c_int,
        A: *mut hipblasComplex,
        lda: ::core::ffi::c_int,
        ipiv: *const ::core::ffi::c_int,
        B: *mut hipblasComplex,
        ldb: ::core::ffi::c_int,
        info: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgetrs(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        n: ::core::ffi::c_int,
        nrhs: ::core::ffi::c_int,
        A: *mut hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        ipiv: *const ::core::ffi::c_int,
        B: *mut hipblasDoubleComplex,
        ldb: ::core::ffi::c_int,
        info: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgetrs_v2(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        n: ::core::ffi::c_int,
        nrhs: ::core::ffi::c_int,
        A: *mut hipComplex,
        lda: ::core::ffi::c_int,
        ipiv: *const ::core::ffi::c_int,
        B: *mut hipComplex,
        ldb: ::core::ffi::c_int,
        info: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgetrs_v2(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        n: ::core::ffi::c_int,
        nrhs: ::core::ffi::c_int,
        A: *mut hipDoubleComplex,
        lda: ::core::ffi::c_int,
        ipiv: *const ::core::ffi::c_int,
        B: *mut hipDoubleComplex,
        ldb: ::core::ffi::c_int,
        info: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief SOLVER API\n\n\\details getrsBatched solves a batch of systems of n linear equations on n\nvariables in its factorized forms.\n\nFor each instance i in the batch, it solves one of the following systems, depending on the value of trans:\n\n\\f[\n\\begin{array}{cl}\nA_i X_i = B_i & \\: \\text{not transposed,}\\\\\nA_i^T X_i = B_i & \\: \\text{transposed, or}\\\\\nA_i^H X_i = B_i & \\: \\text{conjugate transposed.}\n\\end{array}\n\\f]\n\nMatrix \\f$A_i\\f$ is defined by its triangular factors as returned by \\ref hipblasSgetrfBatched \"getrfBatched\".\n\n- Supported precisions in rocSOLVER : s,d,c,z\n- Supported precisions in cuBLAS    : s,d,c,z\n\n@param[in]\nhandle      hipblasHandle_t.\n@param[in]\ntrans       hipblasOperation_t.\\n\nSpecifies the form of the system of equations of each instance in the batch.\n@param[in]\nn           int. n >= 0.\\n\nThe order of the system, i.e. the number of columns and rows of all A_i matrices.\n@param[in]\nnrhs        int. nrhs >= 0.\\n\nThe number of right hand sides, i.e., the number of columns\nof all the matrices B_i.\n@param[in]\nA           Array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\\n\nThe factors L_i and U_i of the factorization A_i = P_i*L_i*U_i returned by \\ref hipblasSgetrfBatched \"getrfBatched\".\n@param[in]\nlda         int. lda >= n.\\n\nThe leading dimension of matrices A_i.\n@param[in]\nipiv        pointer to int. Array on the GPU.\\n\nContains the vectors ipiv_i of pivot indices returned by \\ref hipblasSgetrfBatched \"getrfBatched\".\n@param[in,out]\nB           Array of pointers to type. Each pointer points to an array on the GPU of dimension ldb*nrhs.\\n\nOn entry, the right hand side matrices B_i.\nOn exit, the solution matrix X_i of each system in the batch.\n@param[in]\nldb         int. ldb >= n.\\n\nThe leading dimension of matrices B_i.\n@param[out]\ninfo      pointer to a int on the host.\\n\nIf info = 0, successful exit.\nIf info = j < 0, the argument at position -j is invalid.\n@param[in]\nbatchCount int. batchCount >= 0.\\n\nNumber of instances (systems) in the batch.\n"]
    pub fn hipblasSgetrsBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        n: ::core::ffi::c_int,
        nrhs: ::core::ffi::c_int,
        A: *const *mut f32,
        lda: ::core::ffi::c_int,
        ipiv: *const ::core::ffi::c_int,
        B: *const *mut f32,
        ldb: ::core::ffi::c_int,
        info: *mut ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgetrsBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        n: ::core::ffi::c_int,
        nrhs: ::core::ffi::c_int,
        A: *const *mut f64,
        lda: ::core::ffi::c_int,
        ipiv: *const ::core::ffi::c_int,
        B: *const *mut f64,
        ldb: ::core::ffi::c_int,
        info: *mut ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgetrsBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        n: ::core::ffi::c_int,
        nrhs: ::core::ffi::c_int,
        A: *const *mut hipblasComplex,
        lda: ::core::ffi::c_int,
        ipiv: *const ::core::ffi::c_int,
        B: *const *mut hipblasComplex,
        ldb: ::core::ffi::c_int,
        info: *mut ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgetrsBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        n: ::core::ffi::c_int,
        nrhs: ::core::ffi::c_int,
        A: *const *mut hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        ipiv: *const ::core::ffi::c_int,
        B: *const *mut hipblasDoubleComplex,
        ldb: ::core::ffi::c_int,
        info: *mut ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgetrsBatched_v2(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        n: ::core::ffi::c_int,
        nrhs: ::core::ffi::c_int,
        A: *const *mut hipComplex,
        lda: ::core::ffi::c_int,
        ipiv: *const ::core::ffi::c_int,
        B: *const *mut hipComplex,
        ldb: ::core::ffi::c_int,
        info: *mut ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgetrsBatched_v2(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        n: ::core::ffi::c_int,
        nrhs: ::core::ffi::c_int,
        A: *const *mut hipDoubleComplex,
        lda: ::core::ffi::c_int,
        ipiv: *const ::core::ffi::c_int,
        B: *const *mut hipDoubleComplex,
        ldb: ::core::ffi::c_int,
        info: *mut ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief SOLVER API\n\n\\details\ngetrsStridedBatched solves a batch of systems of n linear equations\non n variables in its factorized forms.\n\nFor each instance i in the batch, it solves one of the following systems, depending on the value of trans:\n\n\\f[\n\\begin{array}{cl}\nA_i X_i = B_i & \\: \\text{not transposed,}\\\\\nA_i^T X_i = B_i & \\: \\text{transposed, or}\\\\\nA_i^H X_i = B_i & \\: \\text{conjugate transposed.}\n\\end{array}\n\\f]\n\nMatrix \\f$A_i\\f$ is defined by its triangular factors as returned by \\ref hipblasSgetrfStridedBatched \"getrfStridedBatched\".\n\n- Supported precisions in rocSOLVER : s,d,c,z\n- Supported precisions in cuBLAS    : No support\n\n@param[in]\nhandle      hipblasHandle_t.\n@param[in]\ntrans       hipblasOperation_t.\\n\nSpecifies the form of the system of equations of each instance in the batch.\n@param[in]\nn           int. n >= 0.\\n\nThe order of the system, i.e. the number of columns and rows of all A_i matrices.\n@param[in]\nnrhs        int. nrhs >= 0.\\n\nThe number of right hand sides, i.e., the number of columns\nof all the matrices B_i.\n@param[in]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\\n\nThe factors L_i and U_i of the factorization A_i = P_i*L_i*U_i returned by \\ref hipblasSgetrfStridedBatched \"getrfStridedBatched\".\n@param[in]\nlda         int. lda >= n.\\n\nThe leading dimension of matrices A_i.\n@param[in]\nstrideA     hipblasStride.\\n\nStride from the start of one matrix A_i to the next one A_(i+1).\nThere is no restriction for the value of strideA. Normal use case is strideA >= lda*n.\n@param[in]\nipiv        pointer to int. Array on the GPU (the size depends on the value of strideP).\\n\nContains the vectors ipiv_i of pivot indices returned by \\ref hipblasSgetrfStridedBatched \"getrfStridedBatched\".\n@param[in]\nstrideP     hipblasStride.\\n\nStride from the start of one vector ipiv_i to the next one ipiv_(i+1).\nThere is no restriction for the value of strideP. Normal use case is strideP >= n.\n@param[in,out]\nB           pointer to type. Array on the GPU (size depends on the value of strideB).\\n\nOn entry, the right hand side matrices B_i.\nOn exit, the solution matrix X_i of each system in the batch.\n@param[in]\nldb         int. ldb >= n.\\n\nThe leading dimension of matrices B_i.\n@param[in]\nstrideB     hipblasStride.\\n\nStride from the start of one matrix B_i to the next one B_(i+1).\nThere is no restriction for the value of strideB. Normal use case is strideB >= ldb*nrhs.\n@param[out]\ninfo      pointer to a int on the host.\\n\nIf info = 0, successful exit.\nIf info = j < 0, the argument at position -j is invalid.\n@param[in]\nbatchCount int. batchCount >= 0.\\n\nNumber of instances (systems) in the batch.\n"]
    pub fn hipblasSgetrsStridedBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        n: ::core::ffi::c_int,
        nrhs: ::core::ffi::c_int,
        A: *mut f32,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        ipiv: *const ::core::ffi::c_int,
        strideP: hipblasStride,
        B: *mut f32,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        info: *mut ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgetrsStridedBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        n: ::core::ffi::c_int,
        nrhs: ::core::ffi::c_int,
        A: *mut f64,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        ipiv: *const ::core::ffi::c_int,
        strideP: hipblasStride,
        B: *mut f64,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        info: *mut ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgetrsStridedBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        n: ::core::ffi::c_int,
        nrhs: ::core::ffi::c_int,
        A: *mut hipblasComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        ipiv: *const ::core::ffi::c_int,
        strideP: hipblasStride,
        B: *mut hipblasComplex,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        info: *mut ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgetrsStridedBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        n: ::core::ffi::c_int,
        nrhs: ::core::ffi::c_int,
        A: *mut hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        ipiv: *const ::core::ffi::c_int,
        strideP: hipblasStride,
        B: *mut hipblasDoubleComplex,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        info: *mut ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgetrsStridedBatched_v2(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        n: ::core::ffi::c_int,
        nrhs: ::core::ffi::c_int,
        A: *mut hipComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        ipiv: *const ::core::ffi::c_int,
        strideP: hipblasStride,
        B: *mut hipComplex,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        info: *mut ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgetrsStridedBatched_v2(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        n: ::core::ffi::c_int,
        nrhs: ::core::ffi::c_int,
        A: *mut hipDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        ipiv: *const ::core::ffi::c_int,
        strideP: hipblasStride,
        B: *mut hipDoubleComplex,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        info: *mut ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief SOLVER API\n\n\\details\ngetriBatched computes the inverse \\f$C_i = A_i^{-1}\\f$ of a batch of general n-by-n matrices \\f$A_i\\f$.\n\nThe inverse is computed by solving the linear system\n\n\\f[\nA_i C_i = I\n\\f]\n\nwhere I is the identity matrix, and \\f$A_i\\f$ is factorized as \\f$A_i = P_i  L_i  U_i\\f$ as given by \\ref hipblasSgetrfBatched \"getrfBatched\".\n\n- Supported precisions in rocSOLVER : s,d,c,z\n- Supported precisions in cuBLAS    : s,d,c,z\n\n@param[in]\nhandle    hipblasHandle_t.\n@param[in]\nn         int. n >= 0.\\n\nThe number of rows and columns of all matrices A_i in the batch.\n@param[in]\nA         array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\\n\nThe factors L_i and U_i of the factorization A_i = P_i*L_i*U_i returned by \\ref hipblasSgetrfBatched \"getrfBatched\".\n@param[in]\nlda       int. lda >= n.\\n\nSpecifies the leading dimension of matrices A_i.\n@param[in]\nipiv      pointer to int. Array on the GPU (the size depends on the value of strideP).\\n\nThe pivot indices returned by \\ref hipblasSgetrfBatched \"getrfBatched\".\nipiv can be passed in as a nullptr, this will assume that getrfBatched was called without partial pivoting.\n@param[out]\nC         array of pointers to type. Each pointer points to an array on the GPU of dimension ldc*n.\\n\nIf info[i] = 0, the inverse of matrices A_i. Otherwise, undefined.\n@param[in]\nldc       int. ldc >= n.\\n\nSpecifies the leading dimension of C_i.\n@param[out]\ninfo      pointer to int. Array of batchCount integers on the GPU.\\n\nIf info[i] = 0, successful exit for inversion of A_i.\nIf info[i] = j > 0, U_i is singular. U_i[j,j] is the first zero pivot.\n@param[in]\nbatchCount int. batchCount >= 0.\\n\nNumber of matrices in the batch.\n"]
    pub fn hipblasSgetriBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        A: *const *mut f32,
        lda: ::core::ffi::c_int,
        ipiv: *mut ::core::ffi::c_int,
        C: *const *mut f32,
        ldc: ::core::ffi::c_int,
        info: *mut ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgetriBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        A: *const *mut f64,
        lda: ::core::ffi::c_int,
        ipiv: *mut ::core::ffi::c_int,
        C: *const *mut f64,
        ldc: ::core::ffi::c_int,
        info: *mut ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgetriBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        A: *const *mut hipblasComplex,
        lda: ::core::ffi::c_int,
        ipiv: *mut ::core::ffi::c_int,
        C: *const *mut hipblasComplex,
        ldc: ::core::ffi::c_int,
        info: *mut ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgetriBatched(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        A: *const *mut hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        ipiv: *mut ::core::ffi::c_int,
        C: *const *mut hipblasDoubleComplex,
        ldc: ::core::ffi::c_int,
        info: *mut ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgetriBatched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        A: *const *mut hipComplex,
        lda: ::core::ffi::c_int,
        ipiv: *mut ::core::ffi::c_int,
        C: *const *mut hipComplex,
        ldc: ::core::ffi::c_int,
        info: *mut ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgetriBatched_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        A: *const *mut hipDoubleComplex,
        lda: ::core::ffi::c_int,
        ipiv: *mut ::core::ffi::c_int,
        C: *const *mut hipDoubleComplex,
        ldc: ::core::ffi::c_int,
        info: *mut ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief GELS solves an overdetermined (or underdetermined) linear system defined by an m-by-n\nmatrix A, and a corresponding matrix B, using the QR factorization computed by \\ref hipblasSgeqrf \"GEQRF\" (or the LQ\nfactorization computed by \"GELQF\").\n\n\\details\nDepending on the value of trans, the problem solved by this function is either of the form\n\n\\f[\n\\begin{array}{cl}\nA X = B & \\: \\text{not transposed, or}\\\\\nA' X = B & \\: \\text{transposed if real, or conjugate transposed if complex}\n\\end{array}\n\\f]\n\nIf m >= n (or m < n in the case of transpose/conjugate transpose), the system is overdetermined\nand a least-squares solution approximating X is found by minimizing\n\n\\f[\n|| B - A  X || \\quad \\text{(or} \\: || B - A' X ||\\text{)}\n\\f]\n\nIf m < n (or m >= n in the case of transpose/conjugate transpose), the system is underdetermined\nand a unique solution for X is chosen such that \\f$|| X ||\\f$ is minimal.\n\n- Supported precisions in rocSOLVER : s,d,c,z\n- Supported precisions in cuBLAS    : currently unsupported\n\n@param[in]\nhandle      hipblasHandle_t.\n@param[in]\ntrans       hipblasOperation_t.\\n\nSpecifies the form of the system of equations.\n@param[in]\nm           int. m >= 0.\\n\nThe number of rows of matrix A.\n@param[in]\nn           int. n >= 0.\\n\nThe number of columns of matrix A.\n@param[in]\nnrhs        int. nrhs >= 0.\\n\nThe number of columns of matrices B and X;\ni.e., the columns on the right hand side.\n@param[inout]\nA           pointer to type. Array on the GPU of dimension lda*n.\\n\nOn entry, the matrix A.\nOn exit, the QR (or LQ) factorization of A as returned by \"GEQRF\" (or \"GELQF\").\n@param[in]\nlda         int. lda >= m.\\n\nSpecifies the leading dimension of matrix A.\n@param[inout]\nB           pointer to type. Array on the GPU of dimension ldb*nrhs.\\n\nOn entry, the matrix B.\nOn exit, when info = 0, B is overwritten by the solution vectors (and the residuals in\nthe overdetermined cases) stored as columns.\n@param[in]\nldb         int. ldb >= max(m,n).\\n\nSpecifies the leading dimension of matrix B.\n@param[out]\ninfo        pointer to an int on the host.\\n\nIf info = 0, successful exit.\nIf info = j < 0, the argument at position -j is invalid.\n@param[out]\ndeviceInfo  pointer to int on the GPU.\\n\nIf info = 0, successful exit.\nIf info = i > 0, the solution could not be computed because input matrix A is\nrank deficient; the i-th diagonal element of its triangular factor is zero."]
    pub fn hipblasSgels(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        nrhs: ::core::ffi::c_int,
        A: *mut f32,
        lda: ::core::ffi::c_int,
        B: *mut f32,
        ldb: ::core::ffi::c_int,
        info: *mut ::core::ffi::c_int,
        deviceInfo: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgels(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        nrhs: ::core::ffi::c_int,
        A: *mut f64,
        lda: ::core::ffi::c_int,
        B: *mut f64,
        ldb: ::core::ffi::c_int,
        info: *mut ::core::ffi::c_int,
        deviceInfo: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgels(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        nrhs: ::core::ffi::c_int,
        A: *mut hipblasComplex,
        lda: ::core::ffi::c_int,
        B: *mut hipblasComplex,
        ldb: ::core::ffi::c_int,
        info: *mut ::core::ffi::c_int,
        deviceInfo: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgels(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        nrhs: ::core::ffi::c_int,
        A: *mut hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        B: *mut hipblasDoubleComplex,
        ldb: ::core::ffi::c_int,
        info: *mut ::core::ffi::c_int,
        deviceInfo: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgels_v2(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        nrhs: ::core::ffi::c_int,
        A: *mut hipComplex,
        lda: ::core::ffi::c_int,
        B: *mut hipComplex,
        ldb: ::core::ffi::c_int,
        info: *mut ::core::ffi::c_int,
        deviceInfo: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgels_v2(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        nrhs: ::core::ffi::c_int,
        A: *mut hipDoubleComplex,
        lda: ::core::ffi::c_int,
        B: *mut hipDoubleComplex,
        ldb: ::core::ffi::c_int,
        info: *mut ::core::ffi::c_int,
        deviceInfo: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief gelsBatched solves a batch of overdetermined (or underdetermined) linear systems\ndefined by a set of m-by-n matrices \\f$A_j\\f$, and corresponding matrices \\f$B_j\\f$, using the\nQR factorizations computed by \"GEQRF_BATCHED\" (or the LQ factorizations computed by \"GELQF_BATCHED\").\n\n\\details\nFor each instance in the batch, depending on the value of trans, the problem solved by this function is either of the form\n\n\\f[\n\\begin{array}{cl}\nA_j X_j = B_j & \\: \\text{not transposed, or}\\\\\nA_j' X_j = B_j & \\: \\text{transposed if real, or conjugate transposed if complex}\n\\end{array}\n\\f]\n\nIf m >= n (or m < n in the case of transpose/conjugate transpose), the system is overdetermined\nand a least-squares solution approximating X_j is found by minimizing\n\n\\f[\n|| B_j - A_j  X_j || \\quad \\text{(or} \\: || B_j - A_j' X_j ||\\text{)}\n\\f]\n\nIf m < n (or m >= n in the case of transpose/conjugate transpose), the system is underdetermined\nand a unique solution for X_j is chosen such that \\f$|| X_j ||\\f$ is minimal.\n\n- Supported precisions in rocSOLVER : s,d,c,z\n- Supported precisions in cuBLAS    : s,d,c,z\nNote that cuBLAS backend supports only the non-transpose operation and only solves over-determined systems (m >= n).\n\n@param[in]\nhandle      hipblasHandle_t.\n@param[in]\ntrans       hipblasOperation_t.\\n\nSpecifies the form of the system of equations.\n@param[in]\nm           int. m >= 0.\\n\nThe number of rows of all matrices A_j in the batch.\n@param[in]\nn           int. n >= 0.\\n\nThe number of columns of all matrices A_j in the batch.\n@param[in]\nnrhs        int. nrhs >= 0.\\n\nThe number of columns of all matrices B_j and X_j in the batch;\ni.e., the columns on the right hand side.\n@param[inout]\nA           array of pointer to type. Each pointer points to an array on the GPU of dimension lda*n.\\n\nOn entry, the matrices A_j.\nOn exit, the QR (or LQ) factorizations of A_j as returned by \"GEQRF_BATCHED\"\n(or \"GELQF_BATCHED\").\n@param[in]\nlda         int. lda >= m.\\n\nSpecifies the leading dimension of matrices A_j.\n@param[inout]\nB           array of pointer to type. Each pointer points to an array on the GPU of dimension ldb*nrhs.\\n\nOn entry, the matrices B_j.\nOn exit, when info[j] = 0, B_j is overwritten by the solution vectors (and the residuals in\nthe overdetermined cases) stored as columns.\n@param[in]\nldb         int. ldb >= max(m,n).\\n\nSpecifies the leading dimension of matrices B_j.\n@param[out]\ninfo        pointer to an int on the host.\\n\nIf info = 0, successful exit.\nIf info = j < 0, the argument at position -j is invalid.\n@param[out]\ndeviceInfo  pointer to int. Array of batchCount integers on the GPU.\\n\nIf deviceInfo[j] = 0, successful exit for solution of A_j.\nIf deviceInfo[j] = i > 0, the solution of A_j could not be computed because input\nmatrix A_j is rank deficient; the i-th diagonal element of its triangular factor is zero.\n@param[in]\nbatchCount  int. batchCount >= 0.\\n\nNumber of matrices in the batch."]
    pub fn hipblasSgelsBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        nrhs: ::core::ffi::c_int,
        A: *const *mut f32,
        lda: ::core::ffi::c_int,
        B: *const *mut f32,
        ldb: ::core::ffi::c_int,
        info: *mut ::core::ffi::c_int,
        deviceInfo: *mut ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgelsBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        nrhs: ::core::ffi::c_int,
        A: *const *mut f64,
        lda: ::core::ffi::c_int,
        B: *const *mut f64,
        ldb: ::core::ffi::c_int,
        info: *mut ::core::ffi::c_int,
        deviceInfo: *mut ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgelsBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        nrhs: ::core::ffi::c_int,
        A: *const *mut hipblasComplex,
        lda: ::core::ffi::c_int,
        B: *const *mut hipblasComplex,
        ldb: ::core::ffi::c_int,
        info: *mut ::core::ffi::c_int,
        deviceInfo: *mut ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgelsBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        nrhs: ::core::ffi::c_int,
        A: *const *mut hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        B: *const *mut hipblasDoubleComplex,
        ldb: ::core::ffi::c_int,
        info: *mut ::core::ffi::c_int,
        deviceInfo: *mut ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgelsBatched_v2(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        nrhs: ::core::ffi::c_int,
        A: *const *mut hipComplex,
        lda: ::core::ffi::c_int,
        B: *const *mut hipComplex,
        ldb: ::core::ffi::c_int,
        info: *mut ::core::ffi::c_int,
        deviceInfo: *mut ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgelsBatched_v2(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        nrhs: ::core::ffi::c_int,
        A: *const *mut hipDoubleComplex,
        lda: ::core::ffi::c_int,
        B: *const *mut hipDoubleComplex,
        ldb: ::core::ffi::c_int,
        info: *mut ::core::ffi::c_int,
        deviceInfo: *mut ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief gelsStridedBatched solves a batch of overdetermined (or underdetermined) linear\nsystems defined by a set of m-by-n matrices \\f$A_j\\f$, and corresponding matrices \\f$B_j\\f$,\nusing the QR factorizations computed by \"GEQRF_STRIDED_BATCHED\"\n(or the LQ factorizations computed by \"GELQF_STRIDED_BATCHED\").\n\n\\details\nFor each instance in the batch, depending on the value of trans, the problem solved by this function is either of the form\n\n\\f[\n\\begin{array}{cl}\nA_j X_j = B_j & \\: \\text{not transposed, or}\\\\\nA_j' X_j = B_j & \\: \\text{transposed if real, or conjugate transposed if complex}\n\\end{array}\n\\f]\n\nIf m >= n (or m < n in the case of transpose/conjugate transpose), the system is overdetermined\nand a least-squares solution approximating X_j is found by minimizing\n\n\\f[\n|| B_j - A_j  X_j || \\quad \\text{(or} \\: || B_j - A_j' X_j ||\\text{)}\n\\f]\n\nIf m < n (or m >= n in the case of transpose/conjugate transpose), the system is underdetermined\nand a unique solution for X_j is chosen such that \\f$|| X_j ||\\f$ is minimal.\n\n- Supported precisions in rocSOLVER : s,d,c,z\n- Supported precisions in cuBLAS    : currently unsupported\n\n@param[in]\nhandle      hipblasHandle_t.\n@param[in]\ntrans       hipblasOperation_t.\\n\nSpecifies the form of the system of equations.\n@param[in]\nm           int. m >= 0.\\n\nThe number of rows of all matrices A_j in the batch.\n@param[in]\nn           int. n >= 0.\\n\nThe number of columns of all matrices A_j in the batch.\n@param[in]\nnrhs        int. nrhs >= 0.\\n\nThe number of columns of all matrices B_j and X_j in the batch;\ni.e., the columns on the right hand side.\n@param[inout]\nA           pointer to type. Array on the GPU (the size depends on the value of strideA).\\n\nOn entry, the matrices A_j.\nOn exit, the QR (or LQ) factorizations of A_j as returned by \"GEQRF_STRIDED_BATCHED\"\n(or \"GELQF_STRIDED_BATCHED\").\n@param[in]\nlda         int. lda >= m.\\n\nSpecifies the leading dimension of matrices A_j.\n@param[in]\nstrideA     hipblasStride.\\n\nStride from the start of one matrix A_j to the next one A_(j+1).\nThere is no restriction for the value of strideA. Normal use case is strideA >= lda*n\n@param[inout]\nB           pointer to type. Array on the GPU (the size depends on the value of strideB).\\n\nOn entry, the matrices B_j.\nOn exit, when info[j] = 0, each B_j is overwritten by the solution vectors (and the residuals in\nthe overdetermined cases) stored as columns.\n@param[in]\nldb         int. ldb >= max(m,n).\\n\nSpecifies the leading dimension of matrices B_j.\n@param[in]\nstrideB     hipblasStride.\\n\nStride from the start of one matrix B_j to the next one B_(j+1).\nThere is no restriction for the value of strideB. Normal use case is strideB >= ldb*nrhs\n@param[out]\ninfo        pointer to an int on the host.\\n\nIf info = 0, successful exit.\nIf info = j < 0, the argument at position -j is invalid.\n@param[out]\ndeviceInfo  pointer to int. Array of batchCount integers on the GPU.\\n\nIf deviceInfo[j] = 0, successful exit for solution of A_j.\nIf deviceInfo[j] = i > 0, the solution of A_j could not be computed because input\nmatrix A_j is rank deficient; the i-th diagonal element of its triangular factor is zero.\n@param[in]\nbatchCount  int. batchCount >= 0.\\n\nNumber of matrices in the batch."]
    pub fn hipblasSgelsStridedBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        nrhs: ::core::ffi::c_int,
        A: *mut f32,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        B: *mut f32,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        info: *mut ::core::ffi::c_int,
        deviceInfo: *mut ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgelsStridedBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        nrhs: ::core::ffi::c_int,
        A: *mut f64,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        B: *mut f64,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        info: *mut ::core::ffi::c_int,
        deviceInfo: *mut ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgelsStridedBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        nrhs: ::core::ffi::c_int,
        A: *mut hipblasComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        B: *mut hipblasComplex,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        info: *mut ::core::ffi::c_int,
        deviceInfo: *mut ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgelsStridedBatched(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        nrhs: ::core::ffi::c_int,
        A: *mut hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        B: *mut hipblasDoubleComplex,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        info: *mut ::core::ffi::c_int,
        deviceInfo: *mut ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgelsStridedBatched_v2(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        nrhs: ::core::ffi::c_int,
        A: *mut hipComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        B: *mut hipComplex,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        info: *mut ::core::ffi::c_int,
        deviceInfo: *mut ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgelsStridedBatched_v2(
        handle: hipblasHandle_t,
        trans: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        nrhs: ::core::ffi::c_int,
        A: *mut hipDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        B: *mut hipDoubleComplex,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        info: *mut ::core::ffi::c_int,
        deviceInfo: *mut ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief SOLVER API\n\n\\details\ngeqrf computes a QR factorization of a general m-by-n matrix A.\n\nThe factorization has the form\n\n\\f[\nA = Q\\left[\\begin{array}{c}\nR\\\\\n0\n\\end{array}\\right]\n\\f]\n\nwhere R is upper triangular (upper trapezoidal if m < n), and Q is\na m-by-m orthogonal/unitary matrix represented as the product of Householder matrices\n\n\\f[\nQ = H_1H_2\\cdots H_k, \\quad \\text{with} \\: k = \\text{min}(m,n)\n\\f]\n\nEach Householder matrix \\f$H_i\\f$ is given by\n\n\\f[\nH_i = I - \\text{ipiv}[i] \\cdot v_i v_i'\n\\f]\n\nwhere the first i-1 elements of the Householder vector \\f$v_i\\f$ are zero, and \\f$v_i[i] = 1\\f$.\n\n- Supported precisions in rocSOLVER : s,d,c,z\n- Supported precisions in cuBLAS    : s,d,c,z\n\n@param[in]\nhandle    hipblasHandle_t.\n@param[in]\nm         int. m >= 0.\\n\nThe number of rows of the matrix A.\n@param[in]\nn         int. n >= 0.\\n\nThe number of columns of the matrix A.\n@param[inout]\nA         pointer to type. Array on the GPU of dimension lda*n.\\n\nOn entry, the m-by-n matrix to be factored.\nOn exit, the elements on and above the diagonal contain the\nfactor R; the elements below the diagonal are the last m - i elements\nof Householder vector v_i.\n@param[in]\nlda       int. lda >= m.\\n\nSpecifies the leading dimension of A.\n@param[out]\nipiv      pointer to type. Array on the GPU of dimension min(m,n).\\n\nThe Householder scalars.\n@param[out]\ninfo      pointer to a int on the host.\\n\nIf info = 0, successful exit.\nIf info = j < 0, the argument at position -j is invalid.\n"]
    pub fn hipblasSgeqrf(
        handle: hipblasHandle_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        A: *mut f32,
        lda: ::core::ffi::c_int,
        ipiv: *mut f32,
        info: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgeqrf(
        handle: hipblasHandle_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        A: *mut f64,
        lda: ::core::ffi::c_int,
        ipiv: *mut f64,
        info: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgeqrf(
        handle: hipblasHandle_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        A: *mut hipblasComplex,
        lda: ::core::ffi::c_int,
        ipiv: *mut hipblasComplex,
        info: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgeqrf(
        handle: hipblasHandle_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        A: *mut hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        ipiv: *mut hipblasDoubleComplex,
        info: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgeqrf_v2(
        handle: hipblasHandle_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        A: *mut hipComplex,
        lda: ::core::ffi::c_int,
        ipiv: *mut hipComplex,
        info: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgeqrf_v2(
        handle: hipblasHandle_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        A: *mut hipDoubleComplex,
        lda: ::core::ffi::c_int,
        ipiv: *mut hipDoubleComplex,
        info: *mut ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief SOLVER API\n\n\\details\ngeqrfBatched computes the QR factorization of a batch of general\nm-by-n matrices.\n\nThe factorization of matrix \\f$A_i\\f$ in the batch has the form\n\n\\f[\nA_i = Q_i\\left[\\begin{array}{c}\nR_i\\\\\n0\n\\end{array}\\right]\n\\f]\n\nwhere \\f$R_i\\f$ is upper triangular (upper trapezoidal if m < n), and \\f$Q_i\\f$ is\na m-by-m orthogonal/unitary matrix represented as the product of Householder matrices\n\n\\f[\nQ_i = H_{i_1}H_{i_2}\\cdots H_{i_k}, \\quad \\text{with} \\: k = \\text{min}(m,n)\n\\f]\n\nEach Householder matrix \\f$H_{i_j}\\f$ is given by\n\n\\f[\nH_{i_j} = I - \\text{ipiv}_i[j] \\cdot v_{i_j} v_{i_j}'\n\\f]\n\nwhere the first j-1 elements of Householder vector \\f$v_{i_j}\\f$ are zero, and \\f$v_{i_j}[j] = 1\\f$.\n\n- Supported precisions in rocSOLVER : s,d,c,z\n- Supported precisions in cuBLAS    : s,d,c,z\n\n@param[in]\nhandle    hipblasHandle_t.\n@param[in]\nm         int. m >= 0.\\n\nThe number of rows of all the matrices A_i in the batch.\n@param[in]\nn         int. n >= 0.\\n\nThe number of columns of all the matrices A_i in the batch.\n@param[inout]\nA         Array of pointers to type. Each pointer points to an array on the GPU of dimension lda*n.\\n\nOn entry, the m-by-n matrices A_i to be factored.\nOn exit, the elements on and above the diagonal contain the\nfactor R_i. The elements below the diagonal are the last m - j elements\nof Householder vector v_(i_j).\n@param[in]\nlda       int. lda >= m.\\n\nSpecifies the leading dimension of matrices A_i.\n@param[out]\nipiv      array of pointers to type. Each pointer points to an array on the GPU\nof dimension min(m, n).\\n\nContains the vectors ipiv_i of corresponding Householder scalars.\n@param[out]\ninfo      pointer to a int on the host.\\n\nIf info = 0, successful exit.\nIf info = j < 0, the argument at position -j is invalid.\n@param[in]\nbatchCount  int. batchCount >= 0.\\n\nNumber of matrices in the batch."]
    pub fn hipblasSgeqrfBatched(
        handle: hipblasHandle_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        A: *const *mut f32,
        lda: ::core::ffi::c_int,
        ipiv: *const *mut f32,
        info: *mut ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgeqrfBatched(
        handle: hipblasHandle_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        A: *const *mut f64,
        lda: ::core::ffi::c_int,
        ipiv: *const *mut f64,
        info: *mut ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgeqrfBatched(
        handle: hipblasHandle_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        A: *const *mut hipblasComplex,
        lda: ::core::ffi::c_int,
        ipiv: *const *mut hipblasComplex,
        info: *mut ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgeqrfBatched(
        handle: hipblasHandle_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        A: *const *mut hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        ipiv: *const *mut hipblasDoubleComplex,
        info: *mut ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgeqrfBatched_v2(
        handle: hipblasHandle_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        A: *const *mut hipComplex,
        lda: ::core::ffi::c_int,
        ipiv: *const *mut hipComplex,
        info: *mut ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgeqrfBatched_v2(
        handle: hipblasHandle_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        A: *const *mut hipDoubleComplex,
        lda: ::core::ffi::c_int,
        ipiv: *const *mut hipDoubleComplex,
        info: *mut ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief SOLVER API\n\n\\details\ngeqrfStridedBatched computes the QR factorization of a batch of\ngeneral m-by-n matrices.\n\nThe factorization of matrix \\f$A_i\\f$ in the batch has the form\n\n\\f[\nA_i = Q_i\\left[\\begin{array}{c}\nR_i\\\\\n0\n\\end{array}\\right]\n\\f]\n\nwhere \\f$R_i\\f$ is upper triangular (upper trapezoidal if m < n), and \\f$Q_i\\f$ is\na m-by-m orthogonal/unitary matrix represented as the product of Householder matrices\n\n\\f[\nQ_i = H_{i_1}H_{i_2}\\cdots H_{i_k}, \\quad \\text{with} \\: k = \\text{min}(m,n)\n\\f]\n\nEach Householder matrix \\f$H_{i_j}\\f$ is given by\n\n\\f[\nH_{i_j} = I - \\text{ipiv}_j[j] \\cdot v_{i_j} v_{i_j}'\n\\f]\n\nwhere the first j-1 elements of Householder vector \\f$v_{i_j}\\f$ are zero, and \\f$v_{i_j}[j] = 1\\f$.\n\n- Supported precisions in rocSOLVER : s,d,c,z\n- Supported precisions in cuBLAS    : No support\n\n@param[in]\nhandle    hipblasHandle_t.\n@param[in]\nm         int. m >= 0.\\n\nThe number of rows of all the matrices A_i in the batch.\n@param[in]\nn         int. n >= 0.\\n\nThe number of columns of all the matrices A_i in the batch.\n@param[inout]\nA         pointer to type. Array on the GPU (the size depends on the value of strideA).\\n\nOn entry, the m-by-n matrices A_i to be factored.\nOn exit, the elements on and above the diagonal contain the\nfactor R_i. The elements below the diagonal are the last m - j elements\nof Householder vector v_(i_j).\n@param[in]\nlda       int. lda >= m.\\n\nSpecifies the leading dimension of matrices A_i.\n@param[in]\nstrideA   hipblasStride.\\n\nStride from the start of one matrix A_i to the next one A_(i+1).\nThere is no restriction for the value of strideA. Normal use case is strideA >= lda*n.\n@param[out]\nipiv      pointer to type. Array on the GPU (the size depends on the value of strideP).\\n\nContains the vectors ipiv_i of corresponding Householder scalars.\n@param[in]\nstrideP   hipblasStride.\\n\nStride from the start of one vector ipiv_i to the next one ipiv_(i+1).\nThere is no restriction for the value\nof strideP. Normal use is strideP >= min(m,n).\n@param[out]\ninfo      pointer to a int on the host.\\n\nIf info = 0, successful exit.\nIf info = j < 0, the argument at position -j is invalid.\n@param[in]\nbatchCount  int. batchCount >= 0.\\n\nNumber of matrices in the batch."]
    pub fn hipblasSgeqrfStridedBatched(
        handle: hipblasHandle_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        A: *mut f32,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        ipiv: *mut f32,
        strideP: hipblasStride,
        info: *mut ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDgeqrfStridedBatched(
        handle: hipblasHandle_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        A: *mut f64,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        ipiv: *mut f64,
        strideP: hipblasStride,
        info: *mut ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgeqrfStridedBatched(
        handle: hipblasHandle_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        A: *mut hipblasComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        ipiv: *mut hipblasComplex,
        strideP: hipblasStride,
        info: *mut ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgeqrfStridedBatched(
        handle: hipblasHandle_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        A: *mut hipblasDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        ipiv: *mut hipblasDoubleComplex,
        strideP: hipblasStride,
        info: *mut ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasCgeqrfStridedBatched_v2(
        handle: hipblasHandle_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        A: *mut hipComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        ipiv: *mut hipComplex,
        strideP: hipblasStride,
        info: *mut ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasZgeqrfStridedBatched_v2(
        handle: hipblasHandle_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        A: *mut hipDoubleComplex,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        ipiv: *mut hipDoubleComplex,
        strideP: hipblasStride,
        info: *mut ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " \\brief BLAS EX API\n\n\\details\ngemmEx performs one of the matrix-matrix operations\n\nC = alpha*op( A )*op( B ) + beta*C,\n\nwhere op( X ) is one of\n\nop( X ) = X      or\nop( X ) = X**T   or\nop( X ) = X**H,\n\nalpha and beta are scalars, and A, B, and C are matrices, with\nop( A ) an m by k matrix, op( B ) a k by n matrix and C is a m by n matrix.\n\n- Supported types are determined by the backend. See cuBLAS documentation for cuBLAS backend.\nFor rocBLAS backend, conversion from hipblasComputeType_t to rocblas_datatype_t happens within hipBLAS.\nSupported types are as follows:\n\n|   aType    |   bType    |   cType    |     computeType     |\n| ---------- | ---------- | ---------- | ------------------- |\n| HIP_R_16F  | HIP_R_16F  | HIP_R_16F  | HIPBLAS_COMPUTE_16F |\n| HIP_R_16F  | HIP_R_16F  | HIP_R_16F  | HIPBLAS_COMPUTE_32F |\n| HIP_R_16F  | HIP_R_16F  | HIP_R_32F  | HIPBLAS_COMPUTE_32F |\n| HIP_R_16BF | HIP_R_16BF | HIP_R_16BF | HIPBLAS_COMPUTE_32F |\n| HIP_R_16BF | HIP_R_16BF | HIP_R_32F  | HIPBLAS_COMPUTE_32F |\n| HIP_R_32F  | HIP_R_32F  | HIP_R_32F  | HIPBLAS_COMPUTE_32F |\n| HIP_R_64F  | HIP_R_64F  | HIP_R_64F  | HIPBLAS_COMPUTE_64F |\n| HIP_R_8I   | HIP_R_8I   | HIP_R_32I  | HIPBLAS_COMPUTE_32I |\n| HIP_C_32F  | HIP_C_32F  | HIP_C_32F  | HIPBLAS_COMPUTE_32F |\n| HIP_C_64F  | HIP_C_64F  | HIP_C_64F  | HIPBLAS_COMPUTE_64F |\n\nhipblasGemmExWithFlags is also available which is identical to hipblasGemmEx\nwith the addition of a \"flags\" parameter which controls flags used in Tensile to control gemm algorithms with the\nrocBLAS backend. When using a cuBLAS backend this parameter is ignored.\n\nWith HIPBLAS_V2 define, hipblasGemmEx accepts hipDataType for aType, bType, and cType.\nIt also accepts hipblasComputeType_t for computeType. hipblasGemmEx will no\nlonger support hipblasDataType_t for these parameters in a future release. hipblasGemmEx follows\nthe same convention.\n\n#ifdef HIPBLAS_V2 // available in hipBLAS version 2.0.0 and later with -DHIPBLAS_V2\n\nhipblasStatus_t hipblasGemmEx(hipblasHandle_t      handle,\nhipblasOperation_t   transA,\nhipblasOperation_t   transB,\nint                  m,\nint                  n,\nint                  k,\nconst void*          alpha,\nconst void*          A,\nhipDataType          aType,\nint                  lda,\nconst void*          B,\nhipDataType          bType,\nint                  ldb,\nconst void*          beta,\nvoid*                C,\nhipDataType          cType,\nint                  ldc,\nhipblasComputeType_t computeType,\nhipblasGemmAlgo_t    algo)\n\nhipblasStatus_t hipblasGemmExWithFlags(hipblasHandle_t      handle,\nhipblasOperation_t   transA,\nhipblasOperation_t   transB,\nint                  m,\nint                  n,\nint                  k,\nconst void*          alpha,\nconst void*          A,\nhipDataType          aType,\nint                  lda,\nconst void*          B,\nhipDataType          bType,\nint                  ldb,\nconst void*          beta,\nvoid*                C,\nhipDataType          cType,\nint                  ldc,\nhipblasComputeType_t computeType,\nhipblasGemmAlgo_t    algo,\nhipblasGemmFlags_t   flags)\n\n#else // [DEPRECATED]\n\nhipblasStatus_t hipblasGemmEx(hipblasHandle_t    handle,\nhipblasOperation_t transA,\nhipblasOperation_t transB,\nint                m,\nint                n,\nint                k,\nconst void*        alpha,\nconst void*        A,\nhipblasDatatype_t  aType,\nint                lda,\nconst void*        B,\nhipblasDatatype_t  bType,\nint                ldb,\nconst void*        beta,\nvoid*              C,\nhipblasDatatype_t  cType,\nint                ldc,\nhipblasDatatype_t  computeType,\nhipblasGemmAlgo_t  algo)\n\nhipblasStatus_t hipblasGemmExWithFlags(hipblasHandle_t      handle,\nhipblasOperation_t   transA,\nhipblasOperation_t   transB,\nint                  m,\nint                  n,\nint                  k,\nconst void*          alpha,\nconst void*          A,\nhipblasDatatype_t    aType,\nint                  lda,\nconst void*          B,\nhipblasDatatype_t    bType,\nint                  ldb,\nconst void*          beta,\nvoid*                C,\nhipblasDatatype_t    cType,\nint                  ldc,\nhipblasDatatype_t    computeType,\nhipblasGemmAlgo_t    algo,\nhipblasGemmFlags_t   flags)\n\n#endif\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\ntransA    [hipblasOperation_t]\nspecifies the form of op( A ).\n@param[in]\ntransB    [hipblasOperation_t]\nspecifies the form of op( B ).\n@param[in]\nm         [int]\nmatrix dimension m.\n@param[in]\nn         [int]\nmatrix dimension n.\n@param[in]\nk         [int]\nmatrix dimension k.\n@param[in]\nalpha     [const void *]\ndevice pointer or host pointer specifying the scalar alpha. Same datatype as computeType.\n@param[in]\nA         [void *]\ndevice pointer storing matrix A.\n@param[in]\naType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of matrix A.\\n\n[hipDataType]\nspecifies the datatype of matrix A.\n@param[in]\nlda       [int]\nspecifies the leading dimension of A.\n@param[in]\nB         [void *]\ndevice pointer storing matrix B.\n@param[in]\nbType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of matrix B.\\n\n[hipDataType]\nspecifies the datatype of matrix B.\n@param[in]\nldb       [int]\nspecifies the leading dimension of B.\n@param[in]\nbeta      [const void *]\ndevice pointer or host pointer specifying the scalar beta. Same datatype as computeType.\n@param[in]\nC         [void *]\ndevice pointer storing matrix C.\n@param[in]\ncType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of matrix C.\\n\n[hipDataType]\nspecifies the datatype of matrix C.\n@param[in]\nldc       [int]\nspecifies the leading dimension of C.\n@param[in]\ncomputeType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of computation.\\n\n[hipblasComputeType_t]\nspecifies the datatype of computation.\n@param[in]\nalgo      [hipblasGemmAlgo_t]\nenumerant specifying the algorithm type.\n"]
    pub fn hipblasGemmEx(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const ::core::ffi::c_void,
        A: *const ::core::ffi::c_void,
        aType: hipblasDatatype_t,
        lda: ::core::ffi::c_int,
        B: *const ::core::ffi::c_void,
        bType: hipblasDatatype_t,
        ldb: ::core::ffi::c_int,
        beta: *const ::core::ffi::c_void,
        C: *mut ::core::ffi::c_void,
        cType: hipblasDatatype_t,
        ldc: ::core::ffi::c_int,
        computeType: hipblasDatatype_t,
        algo: hipblasGemmAlgo_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasGemmEx_v2(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const ::core::ffi::c_void,
        A: *const ::core::ffi::c_void,
        aType: hipDataType,
        lda: ::core::ffi::c_int,
        B: *const ::core::ffi::c_void,
        bType: hipDataType,
        ldb: ::core::ffi::c_int,
        beta: *const ::core::ffi::c_void,
        C: *mut ::core::ffi::c_void,
        cType: hipDataType,
        ldc: ::core::ffi::c_int,
        computeType: hipblasComputeType_t,
        algo: hipblasGemmAlgo_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasGemmExWithFlags(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const ::core::ffi::c_void,
        A: *const ::core::ffi::c_void,
        aType: hipblasDatatype_t,
        lda: ::core::ffi::c_int,
        B: *const ::core::ffi::c_void,
        bType: hipblasDatatype_t,
        ldb: ::core::ffi::c_int,
        beta: *const ::core::ffi::c_void,
        C: *mut ::core::ffi::c_void,
        cType: hipblasDatatype_t,
        ldc: ::core::ffi::c_int,
        computeType: hipblasDatatype_t,
        algo: hipblasGemmAlgo_t,
        flags: hipblasGemmFlags_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasGemmExWithFlags_v2(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const ::core::ffi::c_void,
        A: *const ::core::ffi::c_void,
        aType: hipDataType,
        lda: ::core::ffi::c_int,
        B: *const ::core::ffi::c_void,
        bType: hipDataType,
        ldb: ::core::ffi::c_int,
        beta: *const ::core::ffi::c_void,
        C: *mut ::core::ffi::c_void,
        cType: hipDataType,
        ldc: ::core::ffi::c_int,
        computeType: hipblasComputeType_t,
        algo: hipblasGemmAlgo_t,
        flags: hipblasGemmFlags_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " \\brief BLAS EX API\n\\details\ngemmBatchedEx performs one of the batched matrix-matrix operations\nC_i = alpha*op(A_i)*op(B_i) + beta*C_i, for i = 1, ..., batchCount.\nwhere op( X ) is one of\nop( X ) = X      or\nop( X ) = X**T   or\nop( X ) = X**H,\nalpha and beta are scalars, and A, B, and C are batched pointers to matrices, with\nop( A ) an m by k by batchCount batched matrix,\nop( B ) a k by n by batchCount batched matrix and\nC a m by n by batchCount batched matrix.\nThe batched matrices are an array of pointers to matrices.\nThe number of pointers to matrices is batchCount.\n\n- Supported types are determined by the backend. See rocBLAS/cuBLAS documentation.\n\nhipblasGemmBatchedExWithFlags is also available which is identical to hipblasGemmBatchedEx\nwith the addition of a \"flags\" parameter which controls flags used in Tensile to control gemm algorithms with the\nrocBLAS backend. When using a cuBLAS backend this parameter is ignored.\n\nWith HIPBLAS_V2 define, hipblasGemmBatchedEx accepts hipDataType for aType, bType, and cType.\nIt also accepts hipblasComputeType_t for computeType. hipblasGemmBatchedEx will no\nlonger support hipblasDataType_t for these parameters in a future release. hipblasGemmBatchedExWithFlags\nfollows the same convention.\n\n#ifdef HIPBLAS_V2 // available in hipBLAS version 2.0.0 and later with -DHIPBLAS_V2\n\nhipblasStatus_t hipblasGemmBatchedEx(hipblasHandle_t      handle,\nhipblasOperation_t   transA,\nhipblasOperation_t   transB,\nint                  m,\nint                  n,\nint                  k,\nconst void*          alpha,\nconst void*          A[],\nhipDataType          aType,\nint                  lda,\nconst void*          B[],\nhipDataType          bType,\nint                  ldb,\nconst void*          beta,\nvoid*                C[],\nhipDataType          cType,\nint                  ldc,\nint                  batchCount,\nhipblasComputeType_t computeType,\nhipblasGemmAlgo_t    algo)\n\nhipblasStatus_t hipblasGemmBatchedExWithFlags(hipblasHandle_t      handle,\nhipblasOperation_t   transA,\nhipblasOperation_t   transB,\nint                  m,\nint                  n,\nint                  k,\nconst void*          alpha,\nconst void*          A[],\nhipDataType          aType,\nint                  lda,\nconst void*          B[],\nhipDataType          bType,\nint                  ldb,\nconst void*          beta,\nvoid*                C[],\nhipDataType          cType,\nint                  ldc,\nint                  batchCount,\nhipblasComputeType_t computeType,\nhipblasGemmAlgo_t    algo,\nhipblasGemmFlags_t   flags)\n\n#else // [DEPRECATED]\n\nhipblasStatus_t hipblasGemmBatchedEx(hipblasHandle_t    handle,\nhipblasOperation_t transA,\nhipblasOperation_t transB,\nint                m,\nint                n,\nint                k,\nconst void*        alpha,\nconst void*        A[],\nhipblasDatatype_t  aType,\nint                lda,\nconst void*        B[],\nhipblasDatatype_t  bType,\nint                ldb,\nconst void*        beta,\nvoid*              C[],\nhipblasDatatype_t  cType,\nint                ldc,\nint                batchCount,\nhipblasDatatype_t  computeType,\nhipblasGemmAlgo_t  algo)\n\nhipblasStatus_t hipblasGemmBatchedExWithFlags(hipblasHandle_t      handle,\nhipblasOperation_t   transA,\nhipblasOperation_t   transB,\nint                  m,\nint                  n,\nint                  k,\nconst void*          alpha,\nconst void*          A[],\nhipblasDatatype_t    aType,\nint                  lda,\nconst void*          B[],\nhipblasDatatype_t    bType,\nint                  ldb,\nconst void*          beta,\nvoid*                C[],\nhipblasDatatype_t    cType,\nint                  ldc,\nint                  batchCount,\nhipblasDatatype_t    computeType,\nhipblasGemmAlgo_t    algo,\nhipblasGemmFlags_t   flags)\n\n#endif\n\n\n\n\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\ntransA    [hipblasOperation_t]\nspecifies the form of op( A ).\n@param[in]\ntransB    [hipblasOperation_t]\nspecifies the form of op( B ).\n@param[in]\nm         [int]\nmatrix dimension m.\n@param[in]\nn         [int]\nmatrix dimension n.\n@param[in]\nk         [int]\nmatrix dimension k.\n@param[in]\nalpha     [const void *]\ndevice pointer or host pointer specifying the scalar alpha. Same datatype as computeType.\n@param[in]\nA         [void *]\ndevice pointer storing array of pointers to each matrix A_i.\n@param[in]\naType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of each matrix A_i.\\n\n[hipDataType]\nspecifies the datatype of each matrix A_i.\n@param[in]\nlda       [int]\nspecifies the leading dimension of each A_i.\n@param[in]\nB         [void *]\ndevice pointer storing array of pointers to each matrix B_i.\n@param[in]\nbType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of each matrix B_i.\\n\n[hipDataType]\nspecifies the datatype of each matrix B_i.\n@param[in]\nldb       [int]\nspecifies the leading dimension of each B_i.\n@param[in]\nbeta      [const void *]\ndevice pointer or host pointer specifying the scalar beta. Same datatype as computeType.\n@param[in]\nC         [void *]\ndevice array of device pointers to each matrix C_i.\n@param[in]\ncType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of each matrix C_i.\\n\n[hipDataType]\nspecifies the datatype of each matrix C_i.\n@param[in]\nldc       [int]\nspecifies the leading dimension of each C_i.\n@param[in]\nbatchCount\n[int]\nnumber of gemm operations in the batch.\n@param[in]\ncomputeType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of computation.\\n\n[hipblasComputeType_t]\nspecifies the datatype of computation.\n@param[in]\nalgo      [hipblasGemmAlgo_t]\nenumerant specifying the algorithm type.\n"]
    pub fn hipblasGemmBatchedEx(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const ::core::ffi::c_void,
        A: *mut *const ::core::ffi::c_void,
        aType: hipblasDatatype_t,
        lda: ::core::ffi::c_int,
        B: *mut *const ::core::ffi::c_void,
        bType: hipblasDatatype_t,
        ldb: ::core::ffi::c_int,
        beta: *const ::core::ffi::c_void,
        C: *mut *mut ::core::ffi::c_void,
        cType: hipblasDatatype_t,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
        computeType: hipblasDatatype_t,
        algo: hipblasGemmAlgo_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasGemmBatchedEx_v2(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const ::core::ffi::c_void,
        A: *mut *const ::core::ffi::c_void,
        aType: hipDataType,
        lda: ::core::ffi::c_int,
        B: *mut *const ::core::ffi::c_void,
        bType: hipDataType,
        ldb: ::core::ffi::c_int,
        beta: *const ::core::ffi::c_void,
        C: *mut *mut ::core::ffi::c_void,
        cType: hipDataType,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
        computeType: hipblasComputeType_t,
        algo: hipblasGemmAlgo_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasGemmBatchedExWithFlags(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const ::core::ffi::c_void,
        A: *mut *const ::core::ffi::c_void,
        aType: hipblasDatatype_t,
        lda: ::core::ffi::c_int,
        B: *mut *const ::core::ffi::c_void,
        bType: hipblasDatatype_t,
        ldb: ::core::ffi::c_int,
        beta: *const ::core::ffi::c_void,
        C: *mut *mut ::core::ffi::c_void,
        cType: hipblasDatatype_t,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
        computeType: hipblasDatatype_t,
        algo: hipblasGemmAlgo_t,
        flags: hipblasGemmFlags_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasGemmBatchedExWithFlags_v2(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const ::core::ffi::c_void,
        A: *mut *const ::core::ffi::c_void,
        aType: hipDataType,
        lda: ::core::ffi::c_int,
        B: *mut *const ::core::ffi::c_void,
        bType: hipDataType,
        ldb: ::core::ffi::c_int,
        beta: *const ::core::ffi::c_void,
        C: *mut *mut ::core::ffi::c_void,
        cType: hipDataType,
        ldc: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
        computeType: hipblasComputeType_t,
        algo: hipblasGemmAlgo_t,
        flags: hipblasGemmFlags_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " \\brief BLAS EX API\n\n\\details\ngemmStridedBatchedEx performs one of the strided_batched matrix-matrix operations\n\nC_i = alpha*op(A_i)*op(B_i) + beta*C_i, for i = 1, ..., batchCount\n\nwhere op( X ) is one of\n\nop( X ) = X      or\nop( X ) = X**T   or\nop( X ) = X**H,\n\nalpha and beta are scalars, and A, B, and C are strided_batched matrices, with\nop( A ) an m by k by batchCount strided_batched matrix,\nop( B ) a k by n by batchCount strided_batched matrix and\nC a m by n by batchCount strided_batched matrix.\n\nThe strided_batched matrices are multiple matrices separated by a constant stride.\nThe number of matrices is batchCount.\n\n- Supported types are determined by the backend. See rocBLAS/cuBLAS documentation.\n\nhipblasGemmStridedBatchedExWithFlags is also available which is identical to hipblasStridedBatchedGemmEx\nwith the addition of a \"flags\" parameter which controls flags used in Tensile to control gemm algorithms with the\nrocBLAS backend. When using a cuBLAS backend this parameter is ignored.\n\nWith HIPBLAS_V2 define, hipblasGemmStridedBatchedEx accepts hipDataType for aType, bType, and cType.\nIt also accepts hipblasComputeType_t for computeType. hipblasGemmStridedBatchedEx will no\nlonger support hipblasDataType_t for these parameters in a future release. hipblasGemmStridedBatchedExWithFlags\nfollows the same convention.\n\n#ifdef HIPBLAS_V2 // available in hipBLAS version 2.0.0 and later with -DHIPBLAS_V2\n\nhipblasStatus_t hipblasGemmStridedBatchedEx(hipblasHandle_t      handle,\nhipblasOperation_t   transA,\nhipblasOperation_t   transB,\nint                  m,\nint                  n,\nint                  k,\nconst void*          alpha,\nconst void*          A,\nhipDataType          aType,\nint                  lda,\nhipblasStride        strideA,\nconst void*          B,\nhipDataType          bType,\nint                  ldb,\nhipblasStride        strideB,\nconst void*          beta,\nvoid*                C,\nhipDataType          cType,\nint                  ldc,\nhipblasStride        strideC,\nint                  batchCount,\nhipblasComputeType_t computeType,\nhipblasGemmAlgo_t    algo)\n\nhipblasStatus_t hipblasGemmStridedBatchedExWithFlags(hipblasHandle_t      handle,\nhipblasOperation_t   transA,\nhipblasOperation_t   transB,\nint                  m,\nint                  n,\nint                  k,\nconst void*          alpha,\nconst void*          A,\nhipDataType          aType,\nint                  lda,\nhipblasStride        strideA,\nconst void*          B,\nhipDataType          bType,\nint                  ldb,\nhipblasStride        strideB,\nconst void*          beta,\nvoid*                C,\nhipDataType          cType,\nint                  ldc,\nhipblasStride        strideC,\nint                  batchCount,\nhipblasComputeType_t computeType,\nhipblasGemmAlgo_t    algo,\nhipblasGemmFlags_t   flags)\n\n#else // [DEPRECATED]\n\nhipblasStatus_t hipblasGemmStridedBatchedEx(hipblasHandle_t    handle,\nhipblasOperation_t transA,\nhipblasOperation_t transB,\nint                m,\nint                n,\nint                k,\nconst void*        alpha,\nconst void*        A,\nhipblasDatatype_t  aType,\nint                lda,\nhipblasStride      strideA,\nconst void*        B,\nhipblasDatatype_t  bType,\nint                ldb,\nhipblasStride      strideB,\nconst void*        beta,\nvoid*              C,\nhipblasDatatype_t  cType,\nint                ldc,\nhipblasStride      strideC,\nint                batchCount,\nhipblasDatatype_t  computeType,\nhipblasGemmAlgo_t  algo)\n\nhipblasStatus_t hipblasGemmStridedBatchedExWithFlags(hipblasHandle_t      handle,\nhipblasOperation_t   transA,\nhipblasOperation_t   transB,\nint                  m,\nint                  n,\nint                  k,\nconst void*          alpha,\nconst void*          A,\nhipblasDatatype_t    aType,\nint                  lda,\nhipblasStride        strideA,\nconst void*          B,\nhipblasDatatype_t    bType,\nint                  ldb,\nhipblasStride        strideB,\nconst void*          beta,\nvoid*                C,\nhipblasDatatype_t    cType,\nint                  ldc,\nhipblasStride        strideC,\nint                  batchCount,\nhipblasDatatype_t    computeType,\nhipblasGemmAlgo_t    algo,\nhipblasGemmFlags_t   flags)\n\n#endif\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\ntransA    [hipblasOperation_t]\nspecifies the form of op( A ).\n@param[in]\ntransB    [hipblasOperation_t]\nspecifies the form of op( B ).\n@param[in]\nm         [int]\nmatrix dimension m.\n@param[in]\nn         [int]\nmatrix dimension n.\n@param[in]\nk         [int]\nmatrix dimension k.\n@param[in]\nalpha     [const void *]\ndevice pointer or host pointer specifying the scalar alpha. Same datatype as computeType.\n@param[in]\nA         [void *]\ndevice pointer pointing to first matrix A_1.\n@param[in]\naType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of each matrix A_i.\\n\n[hipDataType]\nspecifies the datatype of each matrix A_i.\n@param[in]\nlda       [int]\nspecifies the leading dimension of each A_i.\n@param[in]\nstrideA  [hipblasStride]\nspecifies stride from start of one A_i matrix to the next A_(i + 1).\n@param[in]\nB         [void *]\ndevice pointer pointing to first matrix B_1.\n@param[in]\nbType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of each matrix B_i.\\n\n[hipDataType]\nspecifies the datatype of each matrix B_i.\n@param[in]\nldb       [int]\nspecifies the leading dimension of each B_i.\n@param[in]\nstrideB  [hipblasStride]\nspecifies stride from start of one B_i matrix to the next B_(i + 1).\n@param[in]\nbeta      [const void *]\ndevice pointer or host pointer specifying the scalar beta. Same datatype as computeType.\n@param[in]\nC         [void *]\ndevice pointer pointing to first matrix C_1.\n@param[in]\ncType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of each matrix C_i.\\n\n[hipDataType]\nspecifies the datatype of each matrix C_i.\n@param[in]\nldc       [int]\nspecifies the leading dimension of each C_i.\n@param[in]\nstrideC  [hipblasStride]\nspecifies stride from start of one C_i matrix to the next C_(i + 1).\n@param[in]\nbatchCount\n[int]\nnumber of gemm operations in the batch.\n@param[in]\ncomputeType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of computation.\\n\n[hipblasComputeType_t]\nspecifies the datatype of computation.\n@param[in]\nalgo      [hipblasGemmAlgo_t]\nenumerant specifying the algorithm type.\n"]
    pub fn hipblasGemmStridedBatchedEx(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const ::core::ffi::c_void,
        A: *const ::core::ffi::c_void,
        aType: hipblasDatatype_t,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        B: *const ::core::ffi::c_void,
        bType: hipblasDatatype_t,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        beta: *const ::core::ffi::c_void,
        C: *mut ::core::ffi::c_void,
        cType: hipblasDatatype_t,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
        computeType: hipblasDatatype_t,
        algo: hipblasGemmAlgo_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasGemmStridedBatchedEx_v2(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const ::core::ffi::c_void,
        A: *const ::core::ffi::c_void,
        aType: hipDataType,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        B: *const ::core::ffi::c_void,
        bType: hipDataType,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        beta: *const ::core::ffi::c_void,
        C: *mut ::core::ffi::c_void,
        cType: hipDataType,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
        computeType: hipblasComputeType_t,
        algo: hipblasGemmAlgo_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasGemmStridedBatchedExWithFlags(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const ::core::ffi::c_void,
        A: *const ::core::ffi::c_void,
        aType: hipblasDatatype_t,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        B: *const ::core::ffi::c_void,
        bType: hipblasDatatype_t,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        beta: *const ::core::ffi::c_void,
        C: *mut ::core::ffi::c_void,
        cType: hipblasDatatype_t,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
        computeType: hipblasDatatype_t,
        algo: hipblasGemmAlgo_t,
        flags: hipblasGemmFlags_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasGemmStridedBatchedExWithFlags_v2(
        handle: hipblasHandle_t,
        transA: hipblasOperation_t,
        transB: hipblasOperation_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        k: ::core::ffi::c_int,
        alpha: *const ::core::ffi::c_void,
        A: *const ::core::ffi::c_void,
        aType: hipDataType,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        B: *const ::core::ffi::c_void,
        bType: hipDataType,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        beta: *const ::core::ffi::c_void,
        C: *mut ::core::ffi::c_void,
        cType: hipDataType,
        ldc: ::core::ffi::c_int,
        strideC: hipblasStride,
        batchCount: ::core::ffi::c_int,
        computeType: hipblasComputeType_t,
        algo: hipblasGemmAlgo_t,
        flags: hipblasGemmFlags_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " BLAS EX API\n\n\\details\ntrsmEx solves\n\nop(A)*X = alpha*B or X*op(A) = alpha*B,\n\nwhere alpha is a scalar, X and B are m by n matrices,\nA is triangular matrix and op(A) is one of\n\nop( A ) = A   or   op( A ) = A^T   or   op( A ) = A^H.\n\nThe matrix X is overwritten on B.\n\nThis function gives the user the ability to reuse the invA matrix between runs.\nIf invA == NULL, hipblasTrsmEx will automatically calculate invA on every run.\n\nSetting up invA:\nThe accepted invA matrix consists of the packed 128x128 inverses of the diagonal blocks of\nmatrix A, followed by any smaller diagonal block that remains.\nTo set up invA it is recommended that hipblasTrtriBatched be used with matrix A as the input.\n\nDevice memory of size 128 x k should be allocated for invA ahead of time, where k is m when\nHIPBLAS_SIDE_LEFT and is n when HIPBLAS_SIDE_RIGHT. The actual number of elements in invA\nshould be passed as invAsize.\n\nTo begin, hipblasTrtriBatched must be called on the full 128x128 sized diagonal blocks of\nmatrix A. Below are the restricted parameters:\n- n = 128\n- ldinvA = 128\n- stride_invA = 128x128\n- batchCount = k / 128,\n\nThen any remaining block may be added:\n- n = k % 128\n- invA = invA + stride_invA * previousBatchCount\n- ldinvA = 128\n- batchCount = 1\n\nWith HIPBLAS_V2 define, hipblasTrsmEx accepts hipDataType for computeType rather than\nhipblasDatatype_t. hipblasTrsmEx will only accept hipDataType in a future release.\n\n#ifdef HIPBLAS_V2 // available in hipBLAS version 2.0.0 and later with -DHIPBLAS_V2\n\nhipblasStatus_t hipblasTrsmEx(hipblasHandle_t    handle,\nhipblasSideMode_t  side,\nhipblasFillMode_t  uplo,\nhipblasOperation_t transA,\nhipblasDiagType_t  diag,\nint                m,\nint                n,\nconst void*        alpha,\nvoid*              A,\nint                lda,\nvoid*              B,\nint                ldb,\nconst void*        invA,\nint                invAsize,\nhipDataType        computeType)\n\n#else // [DEPRECATED]\n\nhipblasStatus_t hipblasTrsmEx(hipblasHandle_t    handle,\nhipblasSideMode_t  side,\nhipblasFillMode_t  uplo,\nhipblasOperation_t transA,\nhipblasDiagType_t  diag,\nint                m,\nint                n,\nconst void*        alpha,\nvoid*              A,\nint                lda,\nvoid*              B,\nint                ldb,\nconst void*        invA,\nint                invAsize,\nhipblasDatatype_t  computeType)\n\n#endif\n\n@param[in]\nhandle  [hipblasHandle_t]\nhandle to the hipblas library context queue.\n\n@param[in]\nside    [hipblasSideMode_t]\nHIPBLAS_SIDE_LEFT:       op(A)*X = alpha*B.\nHIPBLAS_SIDE_RIGHT:      X*op(A) = alpha*B.\n\n@param[in]\nuplo    [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER:  A is an upper triangular matrix.\nHIPBLAS_FILL_MODE_LOWER:  A is a lower triangular matrix.\n\n@param[in]\ntransA  [hipblasOperation_t]\nHIPBLAS_OP_N: op(A) = A.\nHIPBLAS_OP_T: op(A) = A^T.\nHIPBLAS_ON_C: op(A) = A^H.\n\n@param[in]\ndiag    [hipblasDiagType_t]\nHIPBLAS_DIAG_UNIT:     A is assumed to be unit triangular.\nHIPBLAS_DIAG_NON_UNIT:  A is not assumed to be unit triangular.\n\n@param[in]\nm       [int]\nm specifies the number of rows of B. m >= 0.\n\n@param[in]\nn       [int]\nn specifies the number of columns of B. n >= 0.\n\n@param[in]\nalpha   [void *]\ndevice pointer or host pointer specifying the scalar alpha. When alpha is\n&zero then A is not referenced, and B need not be set before\nentry.\n\n@param[in]\nA       [void *]\ndevice pointer storing matrix A.\nof dimension ( lda, k ), where k is m\nwhen HIPBLAS_SIDE_LEFT and\nis n when HIPBLAS_SIDE_RIGHT\nonly the upper/lower triangular part is accessed.\n\n@param[in]\nlda     [int]\nlda specifies the first dimension of A.\nif side = HIPBLAS_SIDE_LEFT,  lda >= max( 1, m ),\nif side = HIPBLAS_SIDE_RIGHT, lda >= max( 1, n ).\n\n@param[in, out]\nB       [void *]\ndevice pointer storing matrix B.\nB is of dimension ( ldb, n ).\nBefore entry, the leading m by n part of the array B must\ncontain the right-hand side matrix B, and on exit is\noverwritten by the solution matrix X.\n\n@param[in]\nldb    [int]\nldb specifies the first dimension of B. ldb >= max( 1, m ).\n\n@param[in]\ninvA    [void *]\ndevice pointer storing the inverse diagonal blocks of A.\ninvA is of dimension ( ld_invA, k ), where k is m\nwhen HIPBLAS_SIDE_LEFT and\nis n when HIPBLAS_SIDE_RIGHT.\nld_invA must be equal to 128.\n\n@param[in]\ninvAsize [int]\ninvAsize specifies the number of elements of device memory in invA.\n\n@param[in]\ncomputeType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of computation.\\n\n[hipDataType]\nspecifies the datatype of computation.\n"]
    pub fn hipblasTrsmEx(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const ::core::ffi::c_void,
        A: *mut ::core::ffi::c_void,
        lda: ::core::ffi::c_int,
        B: *mut ::core::ffi::c_void,
        ldb: ::core::ffi::c_int,
        invA: *const ::core::ffi::c_void,
        invAsize: ::core::ffi::c_int,
        computeType: hipblasDatatype_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasTrsmEx_v2(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const ::core::ffi::c_void,
        A: *mut ::core::ffi::c_void,
        lda: ::core::ffi::c_int,
        B: *mut ::core::ffi::c_void,
        ldb: ::core::ffi::c_int,
        invA: *const ::core::ffi::c_void,
        invAsize: ::core::ffi::c_int,
        computeType: hipDataType,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " BLAS EX API\n\n\\details\ntrsmBatchedEx solves\n\nop(A_i)*X_i = alpha*B_i or X_i*op(A_i) = alpha*B_i,\n\nfor i = 1, ..., batchCount; and where alpha is a scalar, X and B are arrays of m by n matrices,\nA is an array of triangular matrix and each op(A_i) is one of\n\nop( A_i ) = A_i   or   op( A_i ) = A_i^T   or   op( A_i ) = A_i^H.\n\nEach matrix X_i is overwritten on B_i.\n\nThis function gives the user the ability to reuse the invA matrix between runs.\nIf invA == NULL, hipblasTrsmBatchedEx will automatically calculate each invA_i on every run.\n\nSetting up invA:\nEach accepted invA_i matrix consists of the packed 128x128 inverses of the diagonal blocks of\nmatrix A_i, followed by any smaller diagonal block that remains.\nTo set up each invA_i it is recommended that hipblasTrtriBatched be used with matrix A_i as the input.\ninvA is an array of pointers of batchCount length holding each invA_i.\n\nDevice memory of size 128 x k should be allocated for each invA_i ahead of time, where k is m when\nHIPBLAS_SIDE_LEFT and is n when HIPBLAS_SIDE_RIGHT. The actual number of elements in each invA_i\nshould be passed as invAsize.\n\nTo begin, hipblasTrtriBatched must be called on the full 128x128 sized diagonal blocks of each\nmatrix A_i. Below are the restricted parameters:\n- n = 128\n- ldinvA = 128\n- stride_invA = 128x128\n- batchCount = k / 128,\n\nThen any remaining block may be added:\n- n = k % 128\n- invA = invA + stride_invA * previousBatchCount\n- ldinvA = 128\n- batchCount = 1\n\nWith HIPBLAS_V2 define, hipblasTrsmBatchedEx accepts hipDataType for computeType rather than\nhipblasDatatype_t. hipblasTrsmBatchedEx will only accept hipDataType in a future release.\n\n#ifdef HIPBLAS_V2 // available in hipBLAS version 2.0.0 and later with -DHIPBLAS_V2\n\nhipblasStatus_t hipblasTrsmBatchedEx(hipblasHandle_t    handle,\nhipblasSideMode_t  side,\nhipblasFillMode_t  uplo,\nhipblasOperation_t transA,\nhipblasDiagType_t  diag,\nint                m,\nint                n,\nconst void*        alpha,\nvoid*              A,\nint                lda,\nvoid*              B,\nint                ldb,\nint                batchCount,\nconst void*        invA,\nint                invAsize,\nhipDataType        computeType)\n\n#else // [DEPRECATED]\n\nhipblasStatus_t hipblasTrsmBatchedEx(hipblasHandle_t    handle,\nhipblasSideMode_t  side,\nhipblasFillMode_t  uplo,\nhipblasOperation_t transA,\nhipblasDiagType_t  diag,\nint                m,\nint                n,\nconst void*        alpha,\nvoid*              A,\nint                lda,\nvoid*              B,\nint                ldb,\nint                batchCount,\nconst void*        invA,\nint                invAsize,\nhipblasDatatype_t  computeType)\n\n#endif\n\n@param[in]\nhandle  [hipblasHandle_t]\nhandle to the hipblas library context queue.\n\n@param[in]\nside    [hipblasSideMode_t]\nHIPBLAS_SIDE_LEFT:       op(A)*X = alpha*B.\nHIPBLAS_SIDE_RIGHT:      X*op(A) = alpha*B.\n\n@param[in]\nuplo    [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER:  each A_i is an upper triangular matrix.\nHIPBLAS_FILL_MODE_LOWER:  each A_i is a lower triangular matrix.\n\n@param[in]\ntransA  [hipblasOperation_t]\nHIPBLAS_OP_N: op(A) = A.\nHIPBLAS_OP_T: op(A) = A^T.\nHIPBLAS_OP_C: op(A) = A^H.\n\n@param[in]\ndiag    [hipblasDiagType_t]\nHIPBLAS_DIAG_UNIT:     each A_i is assumed to be unit triangular.\nHIPBLAS_DIAG_NON_UNIT:  each A_i is not assumed to be unit triangular.\n\n@param[in]\nm       [int]\nm specifies the number of rows of each B_i. m >= 0.\n\n@param[in]\nn       [int]\nn specifies the number of columns of each B_i. n >= 0.\n\n@param[in]\nalpha   [void *]\ndevice pointer or host pointer alpha specifying the scalar alpha. When alpha is\n&zero then A is not referenced, and B need not be set before\nentry.\n\n@param[in]\nA       [void *]\ndevice array of device pointers storing each matrix A_i.\neach A_i is of dimension ( lda, k ), where k is m\nwhen HIPBLAS_SIDE_LEFT and\nis n when HIPBLAS_SIDE_RIGHT\nonly the upper/lower triangular part is accessed.\n\n@param[in]\nlda     [int]\nlda specifies the first dimension of each A_i.\nif side = HIPBLAS_SIDE_LEFT,  lda >= max( 1, m ),\nif side = HIPBLAS_SIDE_RIGHT, lda >= max( 1, n ).\n\n@param[in, out]\nB       [void *]\ndevice array of device pointers storing each matrix B_i.\neach B_i is of dimension ( ldb, n ).\nBefore entry, the leading m by n part of the array B_i must\ncontain the right-hand side matrix B_i, and on exit is\noverwritten by the solution matrix X_i\n\n@param[in]\nldb    [int]\nldb specifies the first dimension of each B_i. ldb >= max( 1, m ).\n\n@param[in]\nbatchCount [int]\nspecifies how many batches.\n\n@param[in]\ninvA    [void *]\ndevice array of device pointers storing the inverse diagonal blocks of each A_i.\neach invA_i is of dimension ( ld_invA, k ), where k is m\nwhen HIPBLAS_SIDE_LEFT and\nis n when HIPBLAS_SIDE_RIGHT.\nld_invA must be equal to 128.\n\n@param[in]\ninvAsize [int]\ninvAsize specifies the number of elements of device memory in each invA_i.\n\n@param[in]\ncomputeType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of computation.\\n\n[hipDataType]\nspecifies the datatype of computation.\n"]
    pub fn hipblasTrsmBatchedEx(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const ::core::ffi::c_void,
        A: *mut ::core::ffi::c_void,
        lda: ::core::ffi::c_int,
        B: *mut ::core::ffi::c_void,
        ldb: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
        invA: *const ::core::ffi::c_void,
        invAsize: ::core::ffi::c_int,
        computeType: hipblasDatatype_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasTrsmBatchedEx_v2(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const ::core::ffi::c_void,
        A: *mut ::core::ffi::c_void,
        lda: ::core::ffi::c_int,
        B: *mut ::core::ffi::c_void,
        ldb: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
        invA: *const ::core::ffi::c_void,
        invAsize: ::core::ffi::c_int,
        computeType: hipDataType,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " BLAS EX API\n\n\\details\ntrsmStridedBatchedEx solves\n\nop(A_i)*X_i = alpha*B_i or X_i*op(A_i) = alpha*B_i,\n\nfor i = 1, ..., batchCount; and where alpha is a scalar, X and B are strided batched m by n matrices,\nA is a strided batched triangular matrix and op(A_i) is one of\n\nop( A_i ) = A_i   or   op( A_i ) = A_i^T   or   op( A_i ) = A_i^H.\n\nEach matrix X_i is overwritten on B_i.\n\nThis function gives the user the ability to reuse each invA_i matrix between runs.\nIf invA == NULL, hipblasTrsmStridedBatchedEx will automatically calculate each invA_i on every run.\n\nSetting up invA:\nEach accepted invA_i matrix consists of the packed 128x128 inverses of the diagonal blocks of\nmatrix A_i, followed by any smaller diagonal block that remains.\nTo set up invA_i it is recommended that hipblasTrtriBatched be used with matrix A_i as the input.\ninvA is a contiguous piece of memory holding each invA_i.\n\nDevice memory of size 128 x k should be allocated for each invA_i ahead of time, where k is m when\nHIPBLAS_SIDE_LEFT and is n when HIPBLAS_SIDE_RIGHT. The actual number of elements in each invA_i\nshould be passed as invAsize.\n\nTo begin, hipblasTrtriBatched must be called on the full 128x128 sized diagonal blocks of each\nmatrix A_i. Below are the restricted parameters:\n- n = 128\n- ldinvA = 128\n- stride_invA = 128x128\n- batchCount = k / 128,\n\nThen any remaining block may be added:\n- n = k % 128\n- invA = invA + stride_invA * previousBatchCount\n- ldinvA = 128\n- batchCount = 1\n\nWith HIPBLAS_V2 define, hipblasStridedBatchedTrsmEx accepts hipDataType for computeType rather than\nhipblasDatatype_t. hipblasTrsmStridedBatchedEx will only accept hipDataType in a future release.\n\n#ifdef HIPBLAS_V2 // available in hipBLAS version 2.0.0 and later with -DHIPBLAS_V2\n\nhipblasStatus_t hipblasTrsmStridedBatchedEx(hipblasHandle_t    handle,\nhipblasSideMode_t  side,\nhipblasFillMode_t  uplo,\nhipblasOperation_t transA,\nhipblasDiagType_t  diag,\nint                m,\nint                n,\nconst void*        alpha,\nvoid*              A,\nint                lda,\nhipblasStride      strideA,\nvoid*              B,\nint                ldb,\nhipblasStride      strideB,\nint                batchCount,\nconst void*        invA,\nint                invAsize,\nhipblasStride      strideInvA,\nhipDataType        computeType);\n\n#else // [DEPRECATED]\n\nhipblasStatus_t hipblasTrsmStridedBatchedEx(hipblasHandle_t    handle,\nhipblasSideMode_t  side,\nhipblasFillMode_t  uplo,\nhipblasOperation_t transA,\nhipblasDiagType_t  diag,\nint                m,\nint                n,\nconst void*        alpha,\nvoid*              A,\nint                lda,\nhipblasStride      strideA,\nvoid*              B,\nint                ldb,\nhipblasStride      strideB,\nint                batchCount,\nconst void*        invA,\nint                invAsize,\nhipblasStride      strideInvA,\nhipblasDatatype_t  computeType)\n\n#endif\n\n@param[in]\nhandle  [hipblasHandle_t]\nhandle to the hipblas library context queue.\n\n@param[in]\nside    [hipblasSideMode_t]\nHIPBLAS_SIDE_LEFT:       op(A)*X = alpha*B.\nHIPBLAS_SIDE_RIGHT:      X*op(A) = alpha*B.\n\n@param[in]\nuplo    [hipblasFillMode_t]\nHIPBLAS_FILL_MODE_UPPER:  each A_i is an upper triangular matrix.\nHIPBLAS_FILL_MODE_LOWER:  each A_i is a lower triangular matrix.\n\n@param[in]\ntransA  [hipblasOperation_t]\nHIPBLAS_OP_N: op(A) = A.\nHIPBLAS_OP_T: op(A) = A^T.\nHIPBLAS_OP_C: op(A) = A^H.\n\n@param[in]\ndiag    [hipblasDiagType_t]\nHIPBLAS_DIAG_UNIT:     each A_i is assumed to be unit triangular.\nHIPBLAS_DIAG_NON_UNIT:  each A_i is not assumed to be unit triangular.\n\n@param[in]\nm       [int]\nm specifies the number of rows of each B_i. m >= 0.\n\n@param[in]\nn       [int]\nn specifies the number of columns of each B_i. n >= 0.\n\n@param[in]\nalpha   [void *]\ndevice pointer or host pointer specifying the scalar alpha. When alpha is\n&zero then A is not referenced, and B need not be set before\nentry.\n\n@param[in]\nA       [void *]\ndevice pointer storing matrix A.\nof dimension ( lda, k ), where k is m\nwhen HIPBLAS_SIDE_LEFT and\nis n when HIPBLAS_SIDE_RIGHT\nonly the upper/lower triangular part is accessed.\n\n@param[in]\nlda     [int]\nlda specifies the first dimension of A.\nif side = HIPBLAS_SIDE_LEFT,  lda >= max( 1, m ),\nif side = HIPBLAS_SIDE_RIGHT, lda >= max( 1, n ).\n\n@param[in]\nstrideA [hipblasStride]\nThe stride between each A matrix.\n\n@param[in, out]\nB       [void *]\ndevice pointer pointing to first matrix B_i.\neach B_i is of dimension ( ldb, n ).\nBefore entry, the leading m by n part of each array B_i must\ncontain the right-hand side of matrix B_i, and on exit is\noverwritten by the solution matrix X_i.\n\n@param[in]\nldb    [int]\nldb specifies the first dimension of each B_i. ldb >= max( 1, m ).\n\n@param[in]\nstrideB [hipblasStride]\nThe stride between each B_i matrix.\n\n@param[in]\nbatchCount [int]\nspecifies how many batches.\n\n@param[in]\ninvA    [void *]\ndevice pointer storing the inverse diagonal blocks of each A_i.\ninvA points to the first invA_1.\neach invA_i is of dimension ( ld_invA, k ), where k is m\nwhen HIPBLAS_SIDE_LEFT and\nis n when HIPBLAS_SIDE_RIGHT.\nld_invA must be equal to 128.\n\n@param[in]\ninvAsize [int]\ninvAsize specifies the number of elements of device memory in each invA_i.\n\n@param[in]\nstrideInvA [hipblasStride]\nThe stride between each invA matrix.\n\n@param[in]\ncomputeType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of computation.\\n\n[hipDataType]\nspecifies the datatype of computation.\n"]
    pub fn hipblasTrsmStridedBatchedEx(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const ::core::ffi::c_void,
        A: *mut ::core::ffi::c_void,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        B: *mut ::core::ffi::c_void,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        batchCount: ::core::ffi::c_int,
        invA: *const ::core::ffi::c_void,
        invAsize: ::core::ffi::c_int,
        strideInvA: hipblasStride,
        computeType: hipblasDatatype_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasTrsmStridedBatchedEx_v2(
        handle: hipblasHandle_t,
        side: hipblasSideMode_t,
        uplo: hipblasFillMode_t,
        transA: hipblasOperation_t,
        diag: hipblasDiagType_t,
        m: ::core::ffi::c_int,
        n: ::core::ffi::c_int,
        alpha: *const ::core::ffi::c_void,
        A: *mut ::core::ffi::c_void,
        lda: ::core::ffi::c_int,
        strideA: hipblasStride,
        B: *mut ::core::ffi::c_void,
        ldb: ::core::ffi::c_int,
        strideB: hipblasStride,
        batchCount: ::core::ffi::c_int,
        invA: *const ::core::ffi::c_void,
        invAsize: ::core::ffi::c_int,
        strideInvA: hipblasStride,
        computeType: hipDataType,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " \\brief BLAS EX API\n\n\\details\naxpyEx computes constant alpha multiplied by vector x, plus vector y\n\ny := alpha * x + y\n\n- Supported types are determined by the backend. See rocBLAS/cuBLAS documentation.\n\nWith HIPBLAS_V2 define, hipblasAxpyEx accepts hipDataType for alphaType, xType, yType,\nand executionType rather than hipblasDatatype_t. hipblasAxpyEx will only accept hipDataType\nin a future release.\n\n#ifdef HIPBLAS_V2 // available in hipBLAS version 2.0.0 and later with -DHIPBLAS_V2\n\nhipblasStatus_t hipblasAxpyEx(hipblasHandle_t handle,\nint             n,\nconst void*     alpha,\nhipDataType     alphaType,\nconst void*     x,\nhipDataType     xType,\nint             incx,\nvoid*           y,\nhipDataType     yType,\nint             incy,\nhipDataType     executionType)\n\n#else // [DEPRECATED]\n\nhipblasStatus_t hipblasAxpyEx(hipblasHandle_t   handle,\nint               n,\nconst void*       alpha,\nhipblasDatatype_t alphaType,\nconst void*       x,\nhipblasDatatype_t xType,\nint               incx,\nvoid*             y,\nhipblasDatatype_t yType,\nint               incy,\nhipblasDatatype_t executionType)\n\n#endif\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nn         [int]\nthe number of elements in x and y.\n@param[in]\nalpha     device pointer or host pointer to specify the scalar alpha.\n@param[in]\nalphaType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of alpha.\\n\n[hipDataType]\nspecifies the datatype of alpha.\n@param[in]\nx         device pointer storing vector x.\n@param[in]\nxType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of vector x.\\n\n[hipDataType]\nspecifies the datatype of vector x.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of x.\n@param[inout]\ny         device pointer storing vector y.\n@param[in]\nyType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of vector y.\\n\n[hipDataType]\nspecifies the datatype of vector y.\n@param[in]\nincy      [int]\nspecifies the increment for the elements of y.\n@param[in]\nexecutionType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of computation.\\n\n[hipDataType]\nspecifies the datatype of computation.\n"]
    pub fn hipblasAxpyEx(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const ::core::ffi::c_void,
        alphaType: hipblasDatatype_t,
        x: *const ::core::ffi::c_void,
        xType: hipblasDatatype_t,
        incx: ::core::ffi::c_int,
        y: *mut ::core::ffi::c_void,
        yType: hipblasDatatype_t,
        incy: ::core::ffi::c_int,
        executionType: hipblasDatatype_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasAxpyEx_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const ::core::ffi::c_void,
        alphaType: hipDataType,
        x: *const ::core::ffi::c_void,
        xType: hipDataType,
        incx: ::core::ffi::c_int,
        y: *mut ::core::ffi::c_void,
        yType: hipDataType,
        incy: ::core::ffi::c_int,
        executionType: hipDataType,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " \\brief BLAS EX API\n\n\\details\naxpyBatchedEx computes constant alpha multiplied by vector x, plus vector y over\na set of batched vectors.\n\ny := alpha * x + y\n\n- Supported types are determined by the backend. See rocBLAS/cuBLAS documentation.\n\nWith HIPBLAS_V2 define, hipblasAxpyBatchedEx accepts hipDataType for alphaType, xType, yType,\nand executionType rather than hipblasDatatype_t. hipblasAxpyBatchedEx will only accept hipDataType\nin a future release.\n\n#ifdef HIPBLAS_V2 // available in hipBLAS version 2.0.0 and later with -DHIPBLAS_V2\n\nhipblasStatus_t hipblasAxpyBatchedEx(hipblasHandle_t handle,\nint             n,\nconst void*     alpha,\nhipDataType     alphaType,\nconst void*     x,\nhipDataType     xType,\nint             incx,\nvoid*           y,\nhipDataType     yType,\nint             incy,\nint             batchCount,\nhipDataType     executionType)\n\n#else // [DEPRECATED]\n\nhipblasStatus_t hipblasAxpyBatchedEx(hipblasHandle_t   handle,\nint               n,\nconst void*       alpha,\nhipblasDatatype_t alphaType,\nconst void*       x,\nhipblasDatatype_t xType,\nint               incx,\nvoid*             y,\nhipblasDatatype_t yType,\nint               incy,\nint               batchCount,\nhipblasDatatype_t executionType)\n\n#endif\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nn         [int]\nthe number of elements in each x_i and y_i.\n@param[in]\nalpha     device pointer or host pointer to specify the scalar alpha.\n@param[in]\nalphaType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of alpha.\\n\n[hipDataType]\nspecifies the datatype of alpha.\n@param[in]\nx         device array of device pointers storing each vector x_i.\n@param[in]\nxType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of each vector x_i.\\n\n[hipDataType]\nspecifies the datatype of each vector x_i.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of each x_i.\n@param[inout]\ny         device array of device pointers storing each vector y_i.\n@param[in]\nyType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of each vector y_i.\\n\n[hipDataType]\nspecifies the datatype of each vector y_i.\n@param[in]\nincy      [int]\nspecifies the increment for the elements of each y_i.\n@param[in]\nbatchCount [int]\nnumber of instances in the batch.\n@param[in]\nexecutionType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of computation.\\n\n[hipDataType]\nspecifies the datatype of computation.\n"]
    pub fn hipblasAxpyBatchedEx(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const ::core::ffi::c_void,
        alphaType: hipblasDatatype_t,
        x: *const ::core::ffi::c_void,
        xType: hipblasDatatype_t,
        incx: ::core::ffi::c_int,
        y: *mut ::core::ffi::c_void,
        yType: hipblasDatatype_t,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
        executionType: hipblasDatatype_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasAxpyBatchedEx_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const ::core::ffi::c_void,
        alphaType: hipDataType,
        x: *const ::core::ffi::c_void,
        xType: hipDataType,
        incx: ::core::ffi::c_int,
        y: *mut ::core::ffi::c_void,
        yType: hipDataType,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
        executionType: hipDataType,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " \\brief BLAS EX API\n\n\\details\naxpyStridedBatchedEx computes constant alpha multiplied by vector x, plus vector y over\na set of strided batched vectors.\n\ny := alpha * x + y\n\n- Supported types are determined by the backend. See rocBLAS/cuBLAS documentation.\n\nWith HIPBLAS_V2 define, hipblasAxpyStridedBatchedEx accepts hipDataType for alphaType, xType, yType,\nand executionType rather than hipblasDatatype_t. hipblasAxpyStridedBatchedEx will only accept hipDataType\nin a future release.\n\n#ifdef HIPBLAS_V2 // available in hipBLAS version 2.0.0 and later with -DHIPBLAS_V2\n\nhipblasStatus_t hipblasAxpyStridedBatchedEx(hipblasHandle_t handle,\nint             n,\nconst void*     alpha,\nhipDataType     alphaType,\nconst void*     x,\nhipDataType     xType,\nint             incx,\nhipblasStride   stridex,\nvoid*           y,\nhipDataType     yType,\nint             incy,\nhipblasStride   stridey,\nint             batchCount,\nhipDataType     executionType)\n\n#else // [DEPRECATED]\n\nhipblasStatus_t hipblasAxpyStridedBatchedEx(hipblasHandle_t   handle,\nint               n,\nconst void*       alpha,\nhipblasDatatype_t alphaType,\nconst void*       x,\nhipblasDatatype_t xType,\nint               incx,\nhipblasStride     stridex,\nvoid*             y,\nhipblasDatatype_t yType,\nint               incy,\nhipblasStride     stridey,\nint               batchCount,\nhipblasDatatype_t executionType)\n\n#endif\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nn         [int]\nthe number of elements in each x_i and y_i.\n@param[in]\nalpha     device pointer or host pointer to specify the scalar alpha.\n@param[in]\nalphaType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of alpha.\\n\n[hipDataType]\nspecifies the datatype of alpha.\n@param[in]\nx         device pointer to the first vector x_1.\n@param[in]\nxType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of each vector x_i.\\n\n[hipDataType]\nspecifies the datatype of each vector x_i.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of each x_i.\n@param[in]\nstridex   [hipblasStride]\nstride from the start of one vector (x_i) to the next one (x_i+1).\nThere are no restrictions placed on stridex, however the user should\ntake care to ensure that stridex is of appropriate size, for a typical\ncase this means stridex >= n * incx.\n@param[inout]\ny         device pointer to the first vector y_1.\n@param[in]\nyType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of each vector y_i.\\n\n[hipDataType]\nspecifies the datatype of each vector y_i.\n@param[in]\nincy      [int]\nspecifies the increment for the elements of each y_i.\n@param[in]\nstridey   [hipblasStride]\nstride from the start of one vector (y_i) to the next one (y_i+1).\nThere are no restrictions placed on stridey, however the user should\ntake care to ensure that stridey is of appropriate size, for a typical\ncase this means stridey >= n * incy.\n@param[in]\nbatchCount [int]\nnumber of instances in the batch.\n@param[in]\nexecutionType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of computation.\\n\n[hipDataType]\nspecifies the datatype of computation.\n"]
    pub fn hipblasAxpyStridedBatchedEx(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const ::core::ffi::c_void,
        alphaType: hipblasDatatype_t,
        x: *const ::core::ffi::c_void,
        xType: hipblasDatatype_t,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *mut ::core::ffi::c_void,
        yType: hipblasDatatype_t,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
        executionType: hipblasDatatype_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasAxpyStridedBatchedEx_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const ::core::ffi::c_void,
        alphaType: hipDataType,
        x: *const ::core::ffi::c_void,
        xType: hipDataType,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *mut ::core::ffi::c_void,
        yType: hipDataType,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
        executionType: hipDataType,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS EX API\n\n\\details\ndotEx  performs the dot product of vectors x and y\n\nresult = x * y;\n\ndotcEx  performs the dot product of the conjugate of complex vector x and complex vector y\n\nresult = conjugate (x) * y;\n\n- Supported types are determined by the backend. See rocBLAS/cuBLAS documentation.\n\nWith HIPBLAS_V2 define, hipblasDot(c)Ex accepts hipDataType for xType, yType,\nresultType, and executionType rather than hipblasDatatype_t. hipblasDot(c)Ex will only\naccept hipDataType in a future release.\n\n#ifdef HIPBLAS_V2 // available in hipBLAS version 2.0.0 and later with -DHIPBLAS_V2\n\nhipblasStatus_t hipblasDotEx(hipblasHandle_t handle,\nint             n,\nconst void*     x,\nhipDataType     xType,\nint             incx,\nconst void*     y,\nhipDataType     yType,\nint             incy,\nvoid*           result,\nhipDataType     resultType,\nhipDataType     executionType)\n\n#else // [DEPRECATED]\n\nhipblasStatus_t hipblasDotEx(hipblasHandle_t   handle,\nint               n,\nconst void*       x,\nhipblasDatatype_t xType,\nint               incx,\nconst void*       y,\nhipblasDatatype_t yType,\nint               incy,\nvoid*             result,\nhipblasDatatype_t resultType,\nhipblasDatatype_t executionType)\n\n#endif\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nn         [int]\nthe number of elements in x and y.\n@param[in]\nx         device pointer storing vector x.\n@param[in]\nxType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of vector x.\\n\n[hipDataType]\nspecifies the datatype of vector x.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of y.\n@param[in]\ny         device pointer storing vector y.\n@param[in]\nyType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of vector y.\\n\n[hipDataType]\nspecifies the datatype of vector y.\n@param[in]\nincy      [int]\nspecifies the increment for the elements of y.\n@param[inout]\nresult\ndevice pointer or host pointer to store the dot product.\nreturn is 0.0 if n <= 0.\n@param[in]\nresultType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of the result.\\n\n[hipDataType]\nspecifies the datatype of the result.\n@param[in]\nexecutionType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of computation.\\n\n[hipDataType]\nspecifies the datatype of computation.\n"]
    pub fn hipblasDotEx(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const ::core::ffi::c_void,
        xType: hipblasDatatype_t,
        incx: ::core::ffi::c_int,
        y: *const ::core::ffi::c_void,
        yType: hipblasDatatype_t,
        incy: ::core::ffi::c_int,
        result: *mut ::core::ffi::c_void,
        resultType: hipblasDatatype_t,
        executionType: hipblasDatatype_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDotcEx(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const ::core::ffi::c_void,
        xType: hipblasDatatype_t,
        incx: ::core::ffi::c_int,
        y: *const ::core::ffi::c_void,
        yType: hipblasDatatype_t,
        incy: ::core::ffi::c_int,
        result: *mut ::core::ffi::c_void,
        resultType: hipblasDatatype_t,
        executionType: hipblasDatatype_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = "! @}"]
    pub fn hipblasDotEx_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const ::core::ffi::c_void,
        xType: hipDataType,
        incx: ::core::ffi::c_int,
        y: *const ::core::ffi::c_void,
        yType: hipDataType,
        incy: ::core::ffi::c_int,
        result: *mut ::core::ffi::c_void,
        resultType: hipDataType,
        executionType: hipDataType,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDotcEx_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const ::core::ffi::c_void,
        xType: hipDataType,
        incx: ::core::ffi::c_int,
        y: *const ::core::ffi::c_void,
        yType: hipDataType,
        incy: ::core::ffi::c_int,
        result: *mut ::core::ffi::c_void,
        resultType: hipDataType,
        executionType: hipDataType,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS EX API\n\n\\details\ndotBatchedEx performs a batch of dot products of vectors x and y\n\nresult_i = x_i * y_i;\n\ndotcBatchedEx  performs a batch of dot products of the conjugate of complex vector x and complex vector y\n\nresult_i = conjugate (x_i) * y_i;\n\nwhere (x_i, y_i) is the i-th instance of the batch.\nx_i and y_i are vectors, for i = 1, ..., batchCount\n\n- Supported types are determined by the backend. See rocBLAS/cuBLAS documentation.\n\nWith HIPBLAS_V2 define, hipblasDot(c)BatchedEx accepts hipDataType for xType, yType,\nresultType, and executionType rather than hipblasDatatype_t. hipblasDot(c)BatchedEx will only\naccept hipDataType in a future release.\n\n#ifdef HIPBLAS_V2 // available in hipBLAS version 2.0.0 and later with -DHIPBLAS_V2\n\nhipblasStatus_t hipblasDotBatchedEx(hipblasHandle_t handle,\nint             n,\nconst void*     x,\nhipDataType     xType,\nint             incx,\nconst void*     y,\nhipDataType     yType,\nint             incy,\nint             batchCount,\nvoid*           result,\nhipDataType     resultType,\nhipDataType     executionType)\n\n#else // [DEPRECATED]\n\nhipblasStatus_t hipblasDotBatchedEx(hipblasHandle_t   handle,\nint               n,\nconst void*       x,\nhipblasDatatype_t xType,\nint               incx,\nconst void*       y,\nhipblasDatatype_t yType,\nint               incy,\nint               batchCount,\nvoid*             result,\nhipblasDatatype_t resultType,\nhipblasDatatype_t executionType)\n\n#endif\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nn         [int]\nthe number of elements in each x_i and y_i.\n@param[in]\nx         device array of device pointers storing each vector x_i.\n@param[in]\nxType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of each vector x_i.\\n\n[hipDataType]\nspecifies the datatype of each vector x_i.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of each x_i.\n@param[in]\ny         device array of device pointers storing each vector y_i.\n@param[in]\nyType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of each vector y_i.\\n\n[hipDataType]\nspecifies the datatype of each vector y_i.\n@param[in]\nincy      [int]\nspecifies the increment for the elements of each y_i.\n@param[in]\nbatchCount [int]\nnumber of instances in the batch\n@param[inout]\nresult\ndevice array or host array of batchCount size to store the dot products of each batch.\nreturn 0.0 for each element if n <= 0.\n@param[in]\nresultType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of the result.\\n\n[hipDataType]\nspecifies the datatype of the result.\n@param[in]\nexecutionType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of computation.\\n\n[hipDataType]\nspecifies the datatype of computation.\n"]
    pub fn hipblasDotBatchedEx(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const ::core::ffi::c_void,
        xType: hipblasDatatype_t,
        incx: ::core::ffi::c_int,
        y: *const ::core::ffi::c_void,
        yType: hipblasDatatype_t,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
        result: *mut ::core::ffi::c_void,
        resultType: hipblasDatatype_t,
        executionType: hipblasDatatype_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDotcBatchedEx(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const ::core::ffi::c_void,
        xType: hipblasDatatype_t,
        incx: ::core::ffi::c_int,
        y: *const ::core::ffi::c_void,
        yType: hipblasDatatype_t,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
        result: *mut ::core::ffi::c_void,
        resultType: hipblasDatatype_t,
        executionType: hipblasDatatype_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = "! @}"]
    pub fn hipblasDotBatchedEx_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const ::core::ffi::c_void,
        xType: hipDataType,
        incx: ::core::ffi::c_int,
        y: *const ::core::ffi::c_void,
        yType: hipDataType,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
        result: *mut ::core::ffi::c_void,
        resultType: hipDataType,
        executionType: hipDataType,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDotcBatchedEx_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const ::core::ffi::c_void,
        xType: hipDataType,
        incx: ::core::ffi::c_int,
        y: *const ::core::ffi::c_void,
        yType: hipDataType,
        incy: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
        result: *mut ::core::ffi::c_void,
        resultType: hipDataType,
        executionType: hipDataType,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " @{\n\\brief BLAS EX API\n\n\\details\ndotStridedBatchedEx  performs a batch of dot products of vectors x and y\n\nresult_i = x_i * y_i;\n\ndotc_strided_batched_ex  performs a batch of dot products of the conjugate of complex vector x and complex vector y\n\nresult_i = conjugate (x_i) * y_i;\n\nwhere (x_i, y_i) is the i-th instance of the batch.\nx_i and y_i are vectors, for i = 1, ..., batchCount\n\n- Supported types are determined by the backend. See rocBLAS/cuBLAS documentation.\n\nWith HIPBLAS_V2 define, hipblasDot(c)StridedBatchedEx accepts hipDataType for xType, yType,\nresultType, and executionType rather than hipblasDatatype_t. hipblasDot(c)StridedBatchedEx will only\naccept hipDataType in a future release.\n\n#ifdef HIPBLAS_V2 // available in hipBLAS version 2.0.0 and later with -DHIPBLAS_V2\n\nhipblasStatus_t hipblasDotStridedBatchedEx(hipblasHandle_t handle,\nint             n,\nconst void*     x,\nhipDataType     xType,\nint             incx,\nhipblasStride   stridex,\nconst void*     y,\nhipDataType     yType,\nint             incy,\nhipblasStride   stridey,\nint             batchCount,\nvoid*           result,\nhipDataType     resultType,\nhipDataType     executionType)\n\n#else // [DEPRECATED]\n\nhipblasStatus_t hipblasDotStridedBatchedEx(hipblasHandle_t   handle,\nint               n,\nconst void*       x,\nhipblasDatatype_t xType,\nint               incx,\nhipblasStride     stridex,\nconst void*       y,\nhipblasDatatype_t yType,\nint               incy,\nhipblasStride     stridey,\nint               batchCount,\nvoid*             result,\nhipblasDatatype_t resultType,\nhipblasDatatype_t executionType)\n\n#endif\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nn         [int]\nthe number of elements in each x_i and y_i.\n@param[in]\nx         device pointer to the first vector (x_1) in the batch.\n@param[in]\nxType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of each vector x_i.\\n\n[hipDataType]\nspecifies the datatype of each vector x_i.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of each x_i.\n@param[in]\nstridex   [hipblasStride]\nstride from the start of one vector (x_i) and the next one (x_i+1)\n@param[in]\ny         device pointer to the first vector (y_1) in the batch.\n@param[in]\nyType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of each vector y_i.\\n\n[hipDataType]\nspecifies the datatype of each vector y_i.\n@param[in]\nincy      [int]\nspecifies the increment for the elements of each y_i.\n@param[in]\nstridey   [hipblasStride]\nstride from the start of one vector (y_i) and the next one (y_i+1)\n@param[in]\nbatchCount [int]\nnumber of instances in the batch\n@param[inout]\nresult\ndevice array or host array of batchCount size to store the dot products of each batch.\nreturn 0.0 for each element if n <= 0.\n@param[in]\nresultType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of the result.\\n\n[hipDataType]\nspecifies the datatype of the result.\n@param[in]\nexecutionType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of computation.\\n\n[hipDataType]\nspecifies the datatype of computation.\n"]
    pub fn hipblasDotStridedBatchedEx(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const ::core::ffi::c_void,
        xType: hipblasDatatype_t,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *const ::core::ffi::c_void,
        yType: hipblasDatatype_t,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
        result: *mut ::core::ffi::c_void,
        resultType: hipblasDatatype_t,
        executionType: hipblasDatatype_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDotcStridedBatchedEx(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const ::core::ffi::c_void,
        xType: hipblasDatatype_t,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *const ::core::ffi::c_void,
        yType: hipblasDatatype_t,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
        result: *mut ::core::ffi::c_void,
        resultType: hipblasDatatype_t,
        executionType: hipblasDatatype_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = "! @}"]
    pub fn hipblasDotStridedBatchedEx_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const ::core::ffi::c_void,
        xType: hipDataType,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *const ::core::ffi::c_void,
        yType: hipDataType,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
        result: *mut ::core::ffi::c_void,
        resultType: hipDataType,
        executionType: hipDataType,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasDotcStridedBatchedEx_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const ::core::ffi::c_void,
        xType: hipDataType,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *const ::core::ffi::c_void,
        yType: hipDataType,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        batchCount: ::core::ffi::c_int,
        result: *mut ::core::ffi::c_void,
        resultType: hipDataType,
        executionType: hipDataType,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " \\brief BLAS_EX API\n\n\\details\nnrm2Ex computes the euclidean norm of a real or complex vector\n\nresult := sqrt( x'*x ) for real vectors\nresult := sqrt( x**H*x ) for complex vectors\n\n- Supported types are determined by the backend. See rocBLAS/cuBLAS documentation.\n\nWith HIPBLAS_V2 define, hipblasNrm2Ex accepts hipDataType for xType, resultType,\nand executionType rather than hipblasDatatype_t. hipblasNrm2Ex will only accept\nhipDataType in a future release.\n\n#ifdef HIPBLAS_V2 // available in hipBLAS version 2.0.0 and later with -DHIPBLAS_V2\n\nhipblasStatus_t hipblasNrm2Ex(hipblasHandle_t handle,\nint             n,\nconst void*     x,\nhipDataType     xType,\nint             incx,\nvoid*           result,\nhipDataType     resultType,\nhipDataType     executionType)\n\n#else // [DEPRECATED]\n\nhipblasStatus_t hipblasNrm2Ex(hipblasHandle_t   handle,\nint               n,\nconst void*       x,\nhipblasDatatype_t xType,\nint               incx,\nvoid*             result,\nhipblasDatatype_t resultType,\nhipblasDatatype_t executionType)\n\n#endif\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nn         [int]\nthe number of elements in x.\n@param[in]\nx         device pointer storing vector x.\n@param[in]\nxType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of the vector x.\\n\n[hipDataType]\nspecifies the datatype of the vector x.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of y.\n@param[inout]\nresult\ndevice pointer or host pointer to store the nrm2 product.\nreturn is 0.0 if n, incx<=0.\n@param[in]\nresultType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of the result.\\n\n[hipDataType]\nspecifies the datatype of the result.\n@param[in]\nexecutionType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of computation.\\n\n[hipDataType]\nspecifies the datatype of computation."]
    pub fn hipblasNrm2Ex(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const ::core::ffi::c_void,
        xType: hipblasDatatype_t,
        incx: ::core::ffi::c_int,
        result: *mut ::core::ffi::c_void,
        resultType: hipblasDatatype_t,
        executionType: hipblasDatatype_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasNrm2Ex_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const ::core::ffi::c_void,
        xType: hipDataType,
        incx: ::core::ffi::c_int,
        result: *mut ::core::ffi::c_void,
        resultType: hipDataType,
        executionType: hipDataType,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " \\brief BLAS_EX API\n\n\\details\nnrm2BatchedEx computes the euclidean norm over a batch of real or complex vectors\n\nresult := sqrt( x_i'*x_i ) for real vectors x, for i = 1, ..., batchCount\nresult := sqrt( x_i**H*x_i ) for complex vectors x, for i = 1, ..., batchCount\n\n- Supported types are determined by the backend. See rocBLAS/cuBLAS documentation.\n\nWith HIPBLAS_V2 define, hipblasNrm2BatchedEx accepts hipDataType for xType, resultType,\nand executionType rather than hipblasDatatype_t. hipblasNrm2BatchedEx will only accept\nhipDataType in a future release.\n\n#ifdef HIPBLAS_V2 // available in hipBLAS version 2.0.0 and later with -DHIPBLAS_V2\n\nhipblasStatus_t hipblasNrm2BatchedEx(hipblasHandle_t handle,\nint             n,\nconst void*     x,\nhipDataType     xType,\nint             incx,\nint             batchCount,\nvoid*           result,\nhipDataType     resultType,\nhipDataType     executionType)\n\n#else // [DEPRECATED]\n\nhipblasStatus_t hipblasNrm2BatchedEx(hipblasHandle_t   handle,\nint               n,\nconst void*       x,\nhipblasDatatype_t xType,\nint               incx,\nint               batchCount,\nvoid*             result,\nhipblasDatatype_t resultType,\nhipblasDatatype_t executionType)\n\n#endif\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nn         [int]\nnumber of elements in each x_i.\n@param[in]\nx         device array of device pointers storing each vector x_i.\n@param[in]\nxType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of each vector x_i.\\n\n[hipDataType]\nspecifies the datatype of each vector x_i.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of each x_i. incx must be > 0.\n@param[in]\nbatchCount [int]\nnumber of instances in the batch\n@param[out]\nresult\ndevice pointer or host pointer to array of batchCount size for nrm2 results.\nreturn is 0.0 for each element if n <= 0, incx<=0.\n@param[in]\nresultType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of the result.\\n\n[hipDataType]\nspecifies the datatype of the result.\n@param[in]\nexecutionType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of computation.\\n\n[hipDataType]\nspecifies the datatype of computation.\n"]
    pub fn hipblasNrm2BatchedEx(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const ::core::ffi::c_void,
        xType: hipblasDatatype_t,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
        result: *mut ::core::ffi::c_void,
        resultType: hipblasDatatype_t,
        executionType: hipblasDatatype_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasNrm2BatchedEx_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const ::core::ffi::c_void,
        xType: hipDataType,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
        result: *mut ::core::ffi::c_void,
        resultType: hipDataType,
        executionType: hipDataType,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " \\brief BLAS_EX API\n\n\\details\nnrm2StridedBatchedEx computes the euclidean norm over a batch of real or complex vectors\n\n:= sqrt( x_i'*x_i ) for real vectors x, for i = 1, ..., batchCount\n:= sqrt( x_i**H*x_i ) for complex vectors, for i = 1, ..., batchCount\n\n- Supported types are determined by the backend. See rocBLAS/cuBLAS documentation.\n\nWith HIPBLAS_V2 define, hipblasNrm2StridedBatchedEx accepts hipDataType for xType, resultType,\nand executionType rather than hipblasDatatype_t. hipblasNrm2StridedBatchedEx will only accept\nhipDataType in a future release.\n\n#ifdef HIPBLAS_V2 // available in hipBLAS version 2.0.0 and later with -DHIPBLAS_V2\n\nhipblasStatus_t hipblasNrm2StridedBatchedEx(hipblasHandle_t handle,\nint             n,\nconst void*     x,\nhipDataType     xType,\nint             incx,\nhipblasStride   stridex,\nint             batchCount,\nvoid*           result,\nhipDataType     resultType,\nhipDataType     executionType)\n\n#else // [DEPRECATED]\n\nhipblasStatus_t hipblasNrm2StridedBatchedEx(hipblasHandle_t   handle,\nint               n,\nconst void*       x,\nhipblasDatatype_t xType,\nint               incx,\nhipblasStride     stridex,\nint               batchCount,\nvoid*             result,\nhipblasDatatype_t resultType,\nhipblasDatatype_t executionType)\n\n#endif\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nn         [int]\nnumber of elements in each x_i.\n@param[in]\nx         device pointer to the first vector x_1.\n@param[in]\nxType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of each vector x_i.\\n\n[hipDataType]\nspecifies the datatype of each vector x_i.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of each x_i. incx must be > 0.\n@param[in]\nstridex   [hipblasStride]\nstride from the start of one vector (x_i) and the next one (x_i+1).\nThere are no restrictions placed on stride_x, however the user should\ntake care to ensure that stride_x is of appropriate size, for a typical\ncase this means stride_x >= n * incx.\n@param[in]\nbatchCount [int]\nnumber of instances in the batch\n@param[out]\nresult\ndevice pointer or host pointer to array for storing contiguous batchCount results.\nreturn is 0.0 for each element if n <= 0, incx<=0.\n@param[in]\nresultType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of the result.\\n\n[hipDataType]\nspecifies the datatype of the result.\n@param[in]\nexecutionType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of computation.\\n\n[hipDataType]\nspecifies the datatype of computation.\n"]
    pub fn hipblasNrm2StridedBatchedEx(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const ::core::ffi::c_void,
        xType: hipblasDatatype_t,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
        result: *mut ::core::ffi::c_void,
        resultType: hipblasDatatype_t,
        executionType: hipblasDatatype_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasNrm2StridedBatchedEx_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *const ::core::ffi::c_void,
        xType: hipDataType,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
        result: *mut ::core::ffi::c_void,
        resultType: hipDataType,
        executionType: hipDataType,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " \\brief BLAS EX API\n\n\\details\nrotEx applies the Givens rotation matrix defined by c=cos(alpha) and s=sin(alpha) to vectors x and y.\nScalars c and s may be stored in either host or device memory, location is specified by calling hipblasSetPointerMode.\n\nIn the case where cs_type is real:\nx := c * x + s * y\ny := c * y - s * x\n\nIn the case where cs_type is complex, the imaginary part of c is ignored:\nx := real(c) * x + s * y\ny := real(c) * y - conj(s) * x\n\n- Supported types are determined by the backend. See rocBLAS/cuBLAS documentation.\n\nWith HIPBLAS_V2 define, hipblasRotEx accepts hipDataType for xType, yType, csType,\nand executionType rather than hipblasDatatype_t. hipblasRotEx will only accept\nhipDataType in a future release.\n\n#ifdef HIPBLAS_V2 // available in hipBLAS version 2.0.0 and later with -DHIPBLAS_V2\n\nhipblasStatus_t hipblasRotEx(hipblasHandle_t handle,\nint             n,\nvoid*           x,\nhipDataType     xType,\nint             incx,\nvoid*           y,\nhipDataType     yType,\nint             incy,\nconst void*     c,\nconst void*     s,\nhipDataType     csType,\nhipDataType     executionType)\n\n#else // [DEPRECATED]\n\nhipblasStatus_t hipblasRotEx(hipblasHandle_t   handle,\nint               n,\nvoid*             x,\nhipblasDatatype_t xType,\nint               incx,\nvoid*             y,\nhipblasDatatype_t yType,\nint               incy,\nconst void*       c,\nconst void*       s,\nhipblasDatatype_t csType,\nhipblasDatatype_t executionType)\n\n#endif\n\n@param[in]\nhandle  [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nn       [int]\nnumber of elements in the x and y vectors.\n@param[inout]\nx       device pointer storing vector x.\n@param[in]\nxType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of vector x.\\n\n[hipDataType]\nspecifies the datatype of vector x.\n@param[in]\nincx    [int]\nspecifies the increment between elements of x.\n@param[inout]\ny       device pointer storing vector y.\n@param[in]\nyType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of vector y.\\n\n[hipDataType]\nspecifies the datatype of vector y.\n@param[in]\nincy    [int]\nspecifies the increment between elements of y.\n@param[in]\nc       device pointer or host pointer storing scalar cosine component of the rotation matrix.\n@param[in]\ns       device pointer or host pointer storing scalar sine component of the rotation matrix.\n@param[in]\ncsType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of c and s.\\n\n[hipDataType]\nspecifies the datatype of c and s.\n@param[in]\nexecutionType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of computation.\\n\n[hipDataType]\nspecifies the datatype of computation.\n"]
    pub fn hipblasRotEx(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *mut ::core::ffi::c_void,
        xType: hipblasDatatype_t,
        incx: ::core::ffi::c_int,
        y: *mut ::core::ffi::c_void,
        yType: hipblasDatatype_t,
        incy: ::core::ffi::c_int,
        c: *const ::core::ffi::c_void,
        s: *const ::core::ffi::c_void,
        csType: hipblasDatatype_t,
        executionType: hipblasDatatype_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasRotEx_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *mut ::core::ffi::c_void,
        xType: hipDataType,
        incx: ::core::ffi::c_int,
        y: *mut ::core::ffi::c_void,
        yType: hipDataType,
        incy: ::core::ffi::c_int,
        c: *const ::core::ffi::c_void,
        s: *const ::core::ffi::c_void,
        csType: hipDataType,
        executionType: hipDataType,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " \\brief BLAS EX API\n\n\\details\nrotBatchedEx applies the Givens rotation matrix defined by c=cos(alpha) and s=sin(alpha) to batched vectors x_i and y_i, for i = 1, ..., batchCount.\nScalars c and s may be stored in either host or device memory, location is specified by calling hipblasSetPointerMode.\n\nIn the case where cs_type is real:\nx := c * x + s * y\ny := c * y - s * x\n\nIn the case where cs_type is complex, the imaginary part of c is ignored:\nx := real(c) * x + s * y\ny := real(c) * y - conj(s) * x\n\n- Supported types are determined by the backend. See rocBLAS/cuBLAS documentation.\n\nWith HIPBLAS_V2 define, hipblasRotBatchedEx accepts hipDataType for xType, yType, csType,\nand executionType rather than hipblasDatatype_t. hipblasRotBatchedEx will only accept\nhipDataType in a future release.\n\n#ifdef HIPBLAS_V2 // available in hipBLAS version 2.0.0 and later with -DHIPBLAS_V2\n\nhipblasStatus_t hipblasRotBatchedEx(hipblasHandle_t handle,\nint             n,\nvoid*           x,\nhipDataType     xType,\nint             incx,\nvoid*           y,\nhipDataType     yType,\nint             incy,\nconst void*     c,\nconst void*     s,\nhipDataType     csType,\nint             batchCount,\nhipDataType     executionType)\n\n#else // [DEPRECATED]\n\nhipblasStatus_t hipblasRotBatchedEx(hipblasHandle_t   handle,\nint               n,\nvoid*             x,\nhipblasDatatype_t xType,\nint               incx,\nvoid*             y,\nhipblasDatatype_t yType,\nint               incy,\nconst void*       c,\nconst void*       s,\nhipblasDatatype_t csType,\nint               batchCount,\nhipblasDatatype_t executionType)\n\n#endif\n\n@param[in]\nhandle  [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nn       [int]\nnumber of elements in each x_i and y_i vectors.\n@param[inout]\nx       device array of device pointers storing each vector x_i.\n@param[in]\nxType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of each vector x_i.\\n\n[hipDataType]\nspecifies the datatype of each vector x_i.\n@param[in]\nincx    [int]\nspecifies the increment between elements of each x_i.\n@param[inout]\ny       device array of device pointers storing each vector y_i.\n@param[in]\nyType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of each vector y_i.\\n\n[hipDataType]\nspecifies the datatype of each vector y_i.\n@param[in]\nincy    [int]\nspecifies the increment between elements of each y_i.\n@param[in]\nc       device pointer or host pointer to scalar cosine component of the rotation matrix.\n@param[in]\ns       device pointer or host pointer to scalar sine component of the rotation matrix.\n@param[in]\ncsType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of c and s.\\n\n[hipDataType]\nspecifies the datatype of c and s.\n@param[in]\nbatchCount [int]\nthe number of x and y arrays, i.e. the number of batches.\n@param[in]\nexecutionType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of computation.\\n\n[hipDataType]\nspecifies the datatype of computation.\n"]
    pub fn hipblasRotBatchedEx(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *mut ::core::ffi::c_void,
        xType: hipblasDatatype_t,
        incx: ::core::ffi::c_int,
        y: *mut ::core::ffi::c_void,
        yType: hipblasDatatype_t,
        incy: ::core::ffi::c_int,
        c: *const ::core::ffi::c_void,
        s: *const ::core::ffi::c_void,
        csType: hipblasDatatype_t,
        batchCount: ::core::ffi::c_int,
        executionType: hipblasDatatype_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasRotBatchedEx_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *mut ::core::ffi::c_void,
        xType: hipDataType,
        incx: ::core::ffi::c_int,
        y: *mut ::core::ffi::c_void,
        yType: hipDataType,
        incy: ::core::ffi::c_int,
        c: *const ::core::ffi::c_void,
        s: *const ::core::ffi::c_void,
        csType: hipDataType,
        batchCount: ::core::ffi::c_int,
        executionType: hipDataType,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " \\brief BLAS Level 1 API\n\n\\details\nrotStridedBatchedEx applies the Givens rotation matrix defined by c=cos(alpha) and s=sin(alpha) to strided batched vectors x_i and y_i, for i = 1, ..., batchCount.\nScalars c and s may be stored in either host or device memory, location is specified by calling hipblasSetPointerMode.\n\nIn the case where cs_type is real:\nx := c * x + s * y\ny := c * y - s * x\n\nIn the case where cs_type is complex, the imaginary part of c is ignored:\nx := real(c) * x + s * y\ny := real(c) * y - conj(s) * x\n\n- Supported types are determined by the backend. See rocBLAS/cuBLAS documentation.\n\nWith HIPBLAS_V2 define, hipblasRotStridedBatchedEx accepts hipDataType for xType, yType, csType,\nand executionType rather than hipblasDatatype_t. hipblasRotStridedBatchedEx will only accept\nhipDataType in a future release.\n\n#ifdef HIPBLAS_V2 // available in hipBLAS version 2.0.0 and later with -DHIPBLAS_V2\n\nhipblasStatus_t hipblasRotStridedBatchedEx(hipblasHandle_t handle,\nint             n,\nvoid*           x,\nhipDataType     xType,\nint             incx,\nhipblasStride   stridex,\nvoid*           y,\nhipDataType     yType,\nint             incy,\nhipblasStride   stridey,\nconst void*     c,\nconst void*     s,\nhipDataType     csType,\nint             batchCount,\nhipDataType     executionType)\n\n#else // [DEPRECATED]\n\nhipblasStatus_t hipblasRotStridedBatchedEx(hipblasHandle_t   handle,\nint               n,\nvoid*             x,\nhipblasDatatype_t xType,\nint               incx,\nhipblasStride     stridex,\nvoid*             y,\nhipblasDatatype_t yType,\nint               incy,\nhipblasStride     stridey,\nconst void*       c,\nconst void*       s,\nhipblasDatatype_t csType,\nint               batchCount,\nhipblasDatatype_t executionType)\n\n#endif\n\n@param[in]\nhandle  [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nn       [int]\nnumber of elements in each x_i and y_i vectors.\n@param[inout]\nx       device pointer to the first vector x_1.\n@param[in]\nxType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of each vector x_i.\\n\n[hipDataType]\nspecifies the datatype of each vector x_i.\n@param[in]\nincx    [int]\nspecifies the increment between elements of each x_i.\n@param[in]\nstridex [hipblasStride]\nspecifies the increment from the beginning of x_i to the beginning of x_(i+1)\n@param[inout]\ny       device pointer to the first vector y_1.\n@param[in]\nyType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of each vector y_i.\\n\n[hipDataType]\nspecifies the datatype of each vector y_i.\n@param[in]\nincy    [int]\nspecifies the increment between elements of each y_i.\n@param[in]\nstridey [hipblasStride]\nspecifies the increment from the beginning of y_i to the beginning of y_(i+1)\n@param[in]\nc       device pointer or host pointer to scalar cosine component of the rotation matrix.\n@param[in]\ns       device pointer or host pointer to scalar sine component of the rotation matrix.\n@param[in]\ncsType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of c and s.\\n\n[hipDataType]\nspecifies the datatype of c and s.\n@param[in]\nbatchCount [int]\nthe number of x and y arrays, i.e. the number of batches.\n@param[in]\nexecutionType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of computation.\\n\n[hipDataType]\nspecifies the datatype of computation.\n"]
    pub fn hipblasRotStridedBatchedEx(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *mut ::core::ffi::c_void,
        xType: hipblasDatatype_t,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *mut ::core::ffi::c_void,
        yType: hipblasDatatype_t,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        c: *const ::core::ffi::c_void,
        s: *const ::core::ffi::c_void,
        csType: hipblasDatatype_t,
        batchCount: ::core::ffi::c_int,
        executionType: hipblasDatatype_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasRotStridedBatchedEx_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        x: *mut ::core::ffi::c_void,
        xType: hipDataType,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        y: *mut ::core::ffi::c_void,
        yType: hipDataType,
        incy: ::core::ffi::c_int,
        stridey: hipblasStride,
        c: *const ::core::ffi::c_void,
        s: *const ::core::ffi::c_void,
        csType: hipDataType,
        batchCount: ::core::ffi::c_int,
        executionType: hipDataType,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " \\brief BLAS EX API\n\n\\details\nscalEx  scales each element of vector x with scalar alpha.\n\nx := alpha * x\n\n- Supported types are determined by the backend. See rocBLAS/cuBLAS documentation.\n\nWith HIPBLAS_V2 define, hipblasScalEx accepts hipDataType for alphaType,\nxType, and executionType rather than hipblasDatatype_t. hipblasScalEx will only\naccept hipDataType in a future release.\n\n#ifdef HIPBLAS_V2 // available in hipBLAS version 2.0.0 and later with -DHIPBLAS_V2\n\nhipblasStatus_t hipblasScalEx(hipblasHandle_t handle,a\nint             n,\nconst void*     alpha,\nhipDataType     alphaType,\nvoid*           x,\nhipDataType     xType,\nint             incx,\nhipDataType     executionType)\n\n#else // [DEPRECATED]\n\nhipblasStatus_t hipblasScalEx(hipblasHandle_t   handle,\nint               n,\nconst void*       alpha,\nhipblasDatatype_t alphaType,\nvoid*             x,\nhipblasDatatype_t xType,\nint               incx,\nhipblasDatatype_t executionType)\n\n#endif\n\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nn         [int]\nthe number of elements in x.\n@param[in]\nalpha     device pointer or host pointer for the scalar alpha.\n@param[in]\nalphaType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of alpha.\\n\n[hipDataType]\nspecifies the datatype of alpha.\n@param[inout]\nx         device pointer storing vector x.\n@param[in]\nxType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of vector x.\\n\n[hipDataType]\nspecifies the datatype of vector x.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of x.\n@param[in]\nexecutionType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of computation.\\n\n[hipDataType]\nspecifies the datatype of computation.\n"]
    pub fn hipblasScalEx(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const ::core::ffi::c_void,
        alphaType: hipblasDatatype_t,
        x: *mut ::core::ffi::c_void,
        xType: hipblasDatatype_t,
        incx: ::core::ffi::c_int,
        executionType: hipblasDatatype_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasScalEx_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const ::core::ffi::c_void,
        alphaType: hipDataType,
        x: *mut ::core::ffi::c_void,
        xType: hipDataType,
        incx: ::core::ffi::c_int,
        executionType: hipDataType,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " \\brief BLAS EX API\n\n\\details\nscalBatchedEx  scales each element of each vector x_i with scalar alpha.\n\nx_i := alpha * x_i\n\n- Supported types are determined by the backend. See rocBLAS/cuBLAS documentation.\n\nWith HIPBLAS_V2 define, hipblasScalBatchedEx accepts hipDataType for alphaType,\nxType, and executionType rather than hipblasDatatype_t. hipblasScalBatchedEx will only\naccept hipDataType in a future release.\n\\code{.cpp}\n#ifdef HIPBLAS_V2 // available in hipBLAS version 2.0.0 and later with -DHIPBLAS_V2\n\nhipblasStatus_t hipblasScalBatchedEx(hipblasHandle_t handle,\nint             n,\nconst void*     alpha,\nhipDataType     alphaType,\nvoid*           x,\nhipDataType     xType,\nint             incx,\nint             batchCount,\nhipDataType     executionType)\n\n#else // [DEPRECATED]\n\nhipblasStatus_t hipblasScalBatchedEx(hipblasHandle_t   handle,\nint               n,\nconst void*       alpha,\nhipblasDatatype_t alphaType,\nvoid*             x,\nhipblasDatatype_t xType,\nint               incx,\nint               batchCount,\nhipblasDatatype_t executionType)\n\n#endif\n\\endcode\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nn         [int]\nthe number of elements in x.\n@param[in]\nalpha     device pointer or host pointer for the scalar alpha.\n@param[in]\nalphaType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of alpha.\\n\n[hipDataType]\nspecifies the datatype of alpha.\n@param[inout]\nx         device array of device pointers storing each vector x_i.\n@param[in]\nxType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of each vector x_i.\\n\n[hipDataType]\nspecifies the datatype of each vector x_i.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of each x_i.\n@param[in]\nbatchCount [int]\nnumber of instances in the batch.\n@param[in]\nexecutionType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of computation.\\n\n[hipDataType]\nspecifies the datatype of computation.\n"]
    pub fn hipblasScalBatchedEx(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const ::core::ffi::c_void,
        alphaType: hipblasDatatype_t,
        x: *mut ::core::ffi::c_void,
        xType: hipblasDatatype_t,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
        executionType: hipblasDatatype_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasScalBatchedEx_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const ::core::ffi::c_void,
        alphaType: hipDataType,
        x: *mut ::core::ffi::c_void,
        xType: hipDataType,
        incx: ::core::ffi::c_int,
        batchCount: ::core::ffi::c_int,
        executionType: hipDataType,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " \\brief BLAS EX API\n\n\\details\nscalStridedBatchedEx  scales each element of vector x with scalar alpha over a set\nof strided batched vectors.\n\nx := alpha * x\n\n- Supported types are determined by the backend. See rocBLAS/cuBLAS documentation.\n\nWith HIPBLAS_V2 define, hipblasScalStridedBatchedEx accepts hipDataType for alphaType,\nxType, and executionType rather than hipblasDatatype_t. hipblasScalStridedBatchedEx will only\naccept hipDataType in a future release.\n\\code{.cpp}\n#ifdef HIPBLAS_V2 // available in hipBLAS version 2.0.0 and later with -DHIPBLAS_V2\n\nhipblasStatus_t hipblasScalStridedBatchedEx(hipblasHandle_t handle,\nint             n,\nconst void*     alpha,\nhipDataType     alphaType,\nvoid*           x,\nhipDataType     xType,\nint             incx,\nhipblasStride   stridex,\nint             batchCount,\nhipDataType     executionType)\n\n#else // [DEPRECATED]\n\nhipblasStatus_t hipblasScalStridedBatchedEx(hipblasHandle_t   handle,\nint               n,\nconst void*       alpha,\nhipblasDatatype_t alphaType,\nvoid*             x,\nhipblasDatatype_t xType,\nint               incx,\nhipblasStride     stridex,\nint               batchCount,\nhipblasDatatype_t executionType)\n\n#endif\n\\endcode\n@param[in]\nhandle    [hipblasHandle_t]\nhandle to the hipblas library context queue.\n@param[in]\nn         [int]\nthe number of elements in x.\n@param[in]\nalpha     device pointer or host pointer for the scalar alpha.\n@param[in]\nalphaType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of alpha.\\n\n[hipDataType]\nspecifies the datatype of alpha.\n@param[inout]\nx         device pointer to the first vector x_1.\n@param[in]\nxType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of each vector x_i.\\n\n[hipDataType]\nspecifies the datatype of each vector x_i.\n@param[in]\nincx      [int]\nspecifies the increment for the elements of each x_i.\n@param[in]\nstridex   [hipblasStride]\nstride from the start of one vector (x_i) to the next one (x_i+1).\nThere are no restrictions placed on stridex, however the user should\ntake care to ensure that stridex is of appropriate size, for a typical\ncase this means stridex >= n * incx.\n@param[in]\nbatchCount [int]\nnumber of instances in the batch.\n@param[in]\nexecutionType\n[hipblasDatatype_t] [DEPRECATED]\nspecifies the datatype of computation.\\n\n[hipDataType]\nspecifies the datatype of computation.\n"]
    pub fn hipblasScalStridedBatchedEx(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const ::core::ffi::c_void,
        alphaType: hipblasDatatype_t,
        x: *mut ::core::ffi::c_void,
        xType: hipblasDatatype_t,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
        executionType: hipblasDatatype_t,
    ) -> hipblasStatus_t;
}
extern "C" {
    pub fn hipblasScalStridedBatchedEx_v2(
        handle: hipblasHandle_t,
        n: ::core::ffi::c_int,
        alpha: *const ::core::ffi::c_void,
        alphaType: hipDataType,
        x: *mut ::core::ffi::c_void,
        xType: hipDataType,
        incx: ::core::ffi::c_int,
        stridex: hipblasStride,
        batchCount: ::core::ffi::c_int,
        executionType: hipDataType,
    ) -> hipblasStatus_t;
}
extern "C" {
    #[doc = " HIPBLAS Auxiliary API\n\n\\details\nhipblasStatusToString\n\nReturns string representing hipblasStatus_t value\n\n@param[in]\nstatus  [hipblasStatus_t]\nhipBLAS status to convert to string"]
    pub fn hipblasStatusToString(status: hipblasStatus_t) -> *const ::core::ffi::c_char;
}
